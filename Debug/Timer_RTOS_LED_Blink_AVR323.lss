
Timer_RTOS_LED_Blink_AVR323.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007850  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000cc  00800060  00007850  000078e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000696  0080012c  0080012c  000079b0  2**0
                  ALLOC
  3 .stab         00009ccc  00000000  00000000  000079b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000624f  00000000  00000000  0001167c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  000178cb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00017a0b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00017b7b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  000197c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0001a6af  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0001b45c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0001b5bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0001b849  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001c017  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 28 00 	jmp	0x50	; 0x50 <__ctors_end>
       4:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
       8:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
       c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      10:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      14:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      18:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      1c:	0c 94 cc 11 	jmp	0x2398	; 0x2398 <__vector_7>
      20:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      24:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      28:	0c 94 d4 05 	jmp	0xba8	; 0xba8 <__vector_10>
      2c:	0c 94 a1 05 	jmp	0xb42	; 0xb42 <__vector_11>
      30:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      34:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      38:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      3c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      40:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      44:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      48:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      4c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>

00000050 <__ctors_end>:
      50:	11 24       	eor	r1, r1
      52:	1f be       	out	0x3f, r1	; 63
      54:	cf e5       	ldi	r28, 0x5F	; 95
      56:	d8 e0       	ldi	r29, 0x08	; 8
      58:	de bf       	out	0x3e, r29	; 62
      5a:	cd bf       	out	0x3d, r28	; 61

0000005c <__do_copy_data>:
      5c:	11 e0       	ldi	r17, 0x01	; 1
      5e:	a0 e6       	ldi	r26, 0x60	; 96
      60:	b0 e0       	ldi	r27, 0x00	; 0
      62:	e0 e5       	ldi	r30, 0x50	; 80
      64:	f8 e7       	ldi	r31, 0x78	; 120
      66:	02 c0       	rjmp	.+4      	; 0x6c <.do_copy_data_start>

00000068 <.do_copy_data_loop>:
      68:	05 90       	lpm	r0, Z+
      6a:	0d 92       	st	X+, r0

0000006c <.do_copy_data_start>:
      6c:	ac 32       	cpi	r26, 0x2C	; 44
      6e:	b1 07       	cpc	r27, r17
      70:	d9 f7       	brne	.-10     	; 0x68 <.do_copy_data_loop>

00000072 <__do_clear_bss>:
      72:	17 e0       	ldi	r17, 0x07	; 7
      74:	ac e2       	ldi	r26, 0x2C	; 44
      76:	b1 e0       	ldi	r27, 0x01	; 1
      78:	01 c0       	rjmp	.+2      	; 0x7c <.do_clear_bss_start>

0000007a <.do_clear_bss_loop>:
      7a:	1d 92       	st	X+, r1

0000007c <.do_clear_bss_start>:
      7c:	a2 3c       	cpi	r26, 0xC2	; 194
      7e:	b1 07       	cpc	r27, r17
      80:	e1 f7       	brne	.-8      	; 0x7a <.do_clear_bss_loop>
      82:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <main>
      86:	0c 94 26 3c 	jmp	0x784c	; 0x784c <_exit>

0000008a <__bad_interrupt>:
      8a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000008e <__fixunssfsi>:
      8e:	ef 92       	push	r14
      90:	ff 92       	push	r15
      92:	0f 93       	push	r16
      94:	1f 93       	push	r17
      96:	7b 01       	movw	r14, r22
      98:	8c 01       	movw	r16, r24
      9a:	20 e0       	ldi	r18, 0x00	; 0
      9c:	30 e0       	ldi	r19, 0x00	; 0
      9e:	40 e0       	ldi	r20, 0x00	; 0
      a0:	5f e4       	ldi	r21, 0x4F	; 79
      a2:	0e 94 47 03 	call	0x68e	; 0x68e <__gesf2>
      a6:	88 23       	and	r24, r24
      a8:	8c f0       	brlt	.+34     	; 0xcc <__fixunssfsi+0x3e>
      aa:	c8 01       	movw	r24, r16
      ac:	b7 01       	movw	r22, r14
      ae:	20 e0       	ldi	r18, 0x00	; 0
      b0:	30 e0       	ldi	r19, 0x00	; 0
      b2:	40 e0       	ldi	r20, 0x00	; 0
      b4:	5f e4       	ldi	r21, 0x4F	; 79
      b6:	0e 94 bf 01 	call	0x37e	; 0x37e <__subsf3>
      ba:	0e 94 a7 03 	call	0x74e	; 0x74e <__fixsfsi>
      be:	9b 01       	movw	r18, r22
      c0:	ac 01       	movw	r20, r24
      c2:	20 50       	subi	r18, 0x00	; 0
      c4:	30 40       	sbci	r19, 0x00	; 0
      c6:	40 40       	sbci	r20, 0x00	; 0
      c8:	50 48       	sbci	r21, 0x80	; 128
      ca:	06 c0       	rjmp	.+12     	; 0xd8 <__fixunssfsi+0x4a>
      cc:	c8 01       	movw	r24, r16
      ce:	b7 01       	movw	r22, r14
      d0:	0e 94 a7 03 	call	0x74e	; 0x74e <__fixsfsi>
      d4:	9b 01       	movw	r18, r22
      d6:	ac 01       	movw	r20, r24
      d8:	b9 01       	movw	r22, r18
      da:	ca 01       	movw	r24, r20
      dc:	1f 91       	pop	r17
      de:	0f 91       	pop	r16
      e0:	ff 90       	pop	r15
      e2:	ef 90       	pop	r14
      e4:	08 95       	ret

000000e6 <_fpadd_parts>:
      e6:	a0 e0       	ldi	r26, 0x00	; 0
      e8:	b0 e0       	ldi	r27, 0x00	; 0
      ea:	e9 e7       	ldi	r30, 0x79	; 121
      ec:	f0 e0       	ldi	r31, 0x00	; 0
      ee:	0c 94 df 3b 	jmp	0x77be	; 0x77be <__prologue_saves__>
      f2:	dc 01       	movw	r26, r24
      f4:	2b 01       	movw	r4, r22
      f6:	fa 01       	movw	r30, r20
      f8:	9c 91       	ld	r25, X
      fa:	92 30       	cpi	r25, 0x02	; 2
      fc:	08 f4       	brcc	.+2      	; 0x100 <_fpadd_parts+0x1a>
      fe:	39 c1       	rjmp	.+626    	; 0x372 <_fpadd_parts+0x28c>
     100:	eb 01       	movw	r28, r22
     102:	88 81       	ld	r24, Y
     104:	82 30       	cpi	r24, 0x02	; 2
     106:	08 f4       	brcc	.+2      	; 0x10a <_fpadd_parts+0x24>
     108:	33 c1       	rjmp	.+614    	; 0x370 <_fpadd_parts+0x28a>
     10a:	94 30       	cpi	r25, 0x04	; 4
     10c:	69 f4       	brne	.+26     	; 0x128 <_fpadd_parts+0x42>
     10e:	84 30       	cpi	r24, 0x04	; 4
     110:	09 f0       	breq	.+2      	; 0x114 <_fpadd_parts+0x2e>
     112:	2f c1       	rjmp	.+606    	; 0x372 <_fpadd_parts+0x28c>
     114:	11 96       	adiw	r26, 0x01	; 1
     116:	9c 91       	ld	r25, X
     118:	11 97       	sbiw	r26, 0x01	; 1
     11a:	89 81       	ldd	r24, Y+1	; 0x01
     11c:	98 17       	cp	r25, r24
     11e:	09 f4       	brne	.+2      	; 0x122 <_fpadd_parts+0x3c>
     120:	28 c1       	rjmp	.+592    	; 0x372 <_fpadd_parts+0x28c>
     122:	a2 e8       	ldi	r26, 0x82	; 130
     124:	b0 e0       	ldi	r27, 0x00	; 0
     126:	25 c1       	rjmp	.+586    	; 0x372 <_fpadd_parts+0x28c>
     128:	84 30       	cpi	r24, 0x04	; 4
     12a:	09 f4       	brne	.+2      	; 0x12e <_fpadd_parts+0x48>
     12c:	21 c1       	rjmp	.+578    	; 0x370 <_fpadd_parts+0x28a>
     12e:	82 30       	cpi	r24, 0x02	; 2
     130:	a9 f4       	brne	.+42     	; 0x15c <_fpadd_parts+0x76>
     132:	92 30       	cpi	r25, 0x02	; 2
     134:	09 f0       	breq	.+2      	; 0x138 <_fpadd_parts+0x52>
     136:	1d c1       	rjmp	.+570    	; 0x372 <_fpadd_parts+0x28c>
     138:	9a 01       	movw	r18, r20
     13a:	ad 01       	movw	r20, r26
     13c:	88 e0       	ldi	r24, 0x08	; 8
     13e:	ea 01       	movw	r28, r20
     140:	09 90       	ld	r0, Y+
     142:	ae 01       	movw	r20, r28
     144:	e9 01       	movw	r28, r18
     146:	09 92       	st	Y+, r0
     148:	9e 01       	movw	r18, r28
     14a:	81 50       	subi	r24, 0x01	; 1
     14c:	c1 f7       	brne	.-16     	; 0x13e <_fpadd_parts+0x58>
     14e:	e2 01       	movw	r28, r4
     150:	89 81       	ldd	r24, Y+1	; 0x01
     152:	11 96       	adiw	r26, 0x01	; 1
     154:	9c 91       	ld	r25, X
     156:	89 23       	and	r24, r25
     158:	81 83       	std	Z+1, r24	; 0x01
     15a:	08 c1       	rjmp	.+528    	; 0x36c <_fpadd_parts+0x286>
     15c:	92 30       	cpi	r25, 0x02	; 2
     15e:	09 f4       	brne	.+2      	; 0x162 <_fpadd_parts+0x7c>
     160:	07 c1       	rjmp	.+526    	; 0x370 <_fpadd_parts+0x28a>
     162:	12 96       	adiw	r26, 0x02	; 2
     164:	2d 90       	ld	r2, X+
     166:	3c 90       	ld	r3, X
     168:	13 97       	sbiw	r26, 0x03	; 3
     16a:	eb 01       	movw	r28, r22
     16c:	8a 81       	ldd	r24, Y+2	; 0x02
     16e:	9b 81       	ldd	r25, Y+3	; 0x03
     170:	14 96       	adiw	r26, 0x04	; 4
     172:	ad 90       	ld	r10, X+
     174:	bd 90       	ld	r11, X+
     176:	cd 90       	ld	r12, X+
     178:	dc 90       	ld	r13, X
     17a:	17 97       	sbiw	r26, 0x07	; 7
     17c:	ec 80       	ldd	r14, Y+4	; 0x04
     17e:	fd 80       	ldd	r15, Y+5	; 0x05
     180:	0e 81       	ldd	r16, Y+6	; 0x06
     182:	1f 81       	ldd	r17, Y+7	; 0x07
     184:	91 01       	movw	r18, r2
     186:	28 1b       	sub	r18, r24
     188:	39 0b       	sbc	r19, r25
     18a:	b9 01       	movw	r22, r18
     18c:	37 ff       	sbrs	r19, 7
     18e:	04 c0       	rjmp	.+8      	; 0x198 <_fpadd_parts+0xb2>
     190:	66 27       	eor	r22, r22
     192:	77 27       	eor	r23, r23
     194:	62 1b       	sub	r22, r18
     196:	73 0b       	sbc	r23, r19
     198:	60 32       	cpi	r22, 0x20	; 32
     19a:	71 05       	cpc	r23, r1
     19c:	0c f0       	brlt	.+2      	; 0x1a0 <_fpadd_parts+0xba>
     19e:	61 c0       	rjmp	.+194    	; 0x262 <_fpadd_parts+0x17c>
     1a0:	12 16       	cp	r1, r18
     1a2:	13 06       	cpc	r1, r19
     1a4:	6c f5       	brge	.+90     	; 0x200 <_fpadd_parts+0x11a>
     1a6:	37 01       	movw	r6, r14
     1a8:	48 01       	movw	r8, r16
     1aa:	06 2e       	mov	r0, r22
     1ac:	04 c0       	rjmp	.+8      	; 0x1b6 <_fpadd_parts+0xd0>
     1ae:	96 94       	lsr	r9
     1b0:	87 94       	ror	r8
     1b2:	77 94       	ror	r7
     1b4:	67 94       	ror	r6
     1b6:	0a 94       	dec	r0
     1b8:	d2 f7       	brpl	.-12     	; 0x1ae <_fpadd_parts+0xc8>
     1ba:	21 e0       	ldi	r18, 0x01	; 1
     1bc:	30 e0       	ldi	r19, 0x00	; 0
     1be:	40 e0       	ldi	r20, 0x00	; 0
     1c0:	50 e0       	ldi	r21, 0x00	; 0
     1c2:	04 c0       	rjmp	.+8      	; 0x1cc <_fpadd_parts+0xe6>
     1c4:	22 0f       	add	r18, r18
     1c6:	33 1f       	adc	r19, r19
     1c8:	44 1f       	adc	r20, r20
     1ca:	55 1f       	adc	r21, r21
     1cc:	6a 95       	dec	r22
     1ce:	d2 f7       	brpl	.-12     	; 0x1c4 <_fpadd_parts+0xde>
     1d0:	21 50       	subi	r18, 0x01	; 1
     1d2:	30 40       	sbci	r19, 0x00	; 0
     1d4:	40 40       	sbci	r20, 0x00	; 0
     1d6:	50 40       	sbci	r21, 0x00	; 0
     1d8:	2e 21       	and	r18, r14
     1da:	3f 21       	and	r19, r15
     1dc:	40 23       	and	r20, r16
     1de:	51 23       	and	r21, r17
     1e0:	21 15       	cp	r18, r1
     1e2:	31 05       	cpc	r19, r1
     1e4:	41 05       	cpc	r20, r1
     1e6:	51 05       	cpc	r21, r1
     1e8:	21 f0       	breq	.+8      	; 0x1f2 <_fpadd_parts+0x10c>
     1ea:	21 e0       	ldi	r18, 0x01	; 1
     1ec:	30 e0       	ldi	r19, 0x00	; 0
     1ee:	40 e0       	ldi	r20, 0x00	; 0
     1f0:	50 e0       	ldi	r21, 0x00	; 0
     1f2:	79 01       	movw	r14, r18
     1f4:	8a 01       	movw	r16, r20
     1f6:	e6 28       	or	r14, r6
     1f8:	f7 28       	or	r15, r7
     1fa:	08 29       	or	r16, r8
     1fc:	19 29       	or	r17, r9
     1fe:	3c c0       	rjmp	.+120    	; 0x278 <_fpadd_parts+0x192>
     200:	23 2b       	or	r18, r19
     202:	d1 f1       	breq	.+116    	; 0x278 <_fpadd_parts+0x192>
     204:	26 0e       	add	r2, r22
     206:	37 1e       	adc	r3, r23
     208:	35 01       	movw	r6, r10
     20a:	46 01       	movw	r8, r12
     20c:	06 2e       	mov	r0, r22
     20e:	04 c0       	rjmp	.+8      	; 0x218 <_fpadd_parts+0x132>
     210:	96 94       	lsr	r9
     212:	87 94       	ror	r8
     214:	77 94       	ror	r7
     216:	67 94       	ror	r6
     218:	0a 94       	dec	r0
     21a:	d2 f7       	brpl	.-12     	; 0x210 <_fpadd_parts+0x12a>
     21c:	21 e0       	ldi	r18, 0x01	; 1
     21e:	30 e0       	ldi	r19, 0x00	; 0
     220:	40 e0       	ldi	r20, 0x00	; 0
     222:	50 e0       	ldi	r21, 0x00	; 0
     224:	04 c0       	rjmp	.+8      	; 0x22e <_fpadd_parts+0x148>
     226:	22 0f       	add	r18, r18
     228:	33 1f       	adc	r19, r19
     22a:	44 1f       	adc	r20, r20
     22c:	55 1f       	adc	r21, r21
     22e:	6a 95       	dec	r22
     230:	d2 f7       	brpl	.-12     	; 0x226 <_fpadd_parts+0x140>
     232:	21 50       	subi	r18, 0x01	; 1
     234:	30 40       	sbci	r19, 0x00	; 0
     236:	40 40       	sbci	r20, 0x00	; 0
     238:	50 40       	sbci	r21, 0x00	; 0
     23a:	2a 21       	and	r18, r10
     23c:	3b 21       	and	r19, r11
     23e:	4c 21       	and	r20, r12
     240:	5d 21       	and	r21, r13
     242:	21 15       	cp	r18, r1
     244:	31 05       	cpc	r19, r1
     246:	41 05       	cpc	r20, r1
     248:	51 05       	cpc	r21, r1
     24a:	21 f0       	breq	.+8      	; 0x254 <_fpadd_parts+0x16e>
     24c:	21 e0       	ldi	r18, 0x01	; 1
     24e:	30 e0       	ldi	r19, 0x00	; 0
     250:	40 e0       	ldi	r20, 0x00	; 0
     252:	50 e0       	ldi	r21, 0x00	; 0
     254:	59 01       	movw	r10, r18
     256:	6a 01       	movw	r12, r20
     258:	a6 28       	or	r10, r6
     25a:	b7 28       	or	r11, r7
     25c:	c8 28       	or	r12, r8
     25e:	d9 28       	or	r13, r9
     260:	0b c0       	rjmp	.+22     	; 0x278 <_fpadd_parts+0x192>
     262:	82 15       	cp	r24, r2
     264:	93 05       	cpc	r25, r3
     266:	2c f0       	brlt	.+10     	; 0x272 <_fpadd_parts+0x18c>
     268:	1c 01       	movw	r2, r24
     26a:	aa 24       	eor	r10, r10
     26c:	bb 24       	eor	r11, r11
     26e:	65 01       	movw	r12, r10
     270:	03 c0       	rjmp	.+6      	; 0x278 <_fpadd_parts+0x192>
     272:	ee 24       	eor	r14, r14
     274:	ff 24       	eor	r15, r15
     276:	87 01       	movw	r16, r14
     278:	11 96       	adiw	r26, 0x01	; 1
     27a:	9c 91       	ld	r25, X
     27c:	d2 01       	movw	r26, r4
     27e:	11 96       	adiw	r26, 0x01	; 1
     280:	8c 91       	ld	r24, X
     282:	98 17       	cp	r25, r24
     284:	09 f4       	brne	.+2      	; 0x288 <_fpadd_parts+0x1a2>
     286:	45 c0       	rjmp	.+138    	; 0x312 <_fpadd_parts+0x22c>
     288:	99 23       	and	r25, r25
     28a:	39 f0       	breq	.+14     	; 0x29a <_fpadd_parts+0x1b4>
     28c:	a8 01       	movw	r20, r16
     28e:	97 01       	movw	r18, r14
     290:	2a 19       	sub	r18, r10
     292:	3b 09       	sbc	r19, r11
     294:	4c 09       	sbc	r20, r12
     296:	5d 09       	sbc	r21, r13
     298:	06 c0       	rjmp	.+12     	; 0x2a6 <_fpadd_parts+0x1c0>
     29a:	a6 01       	movw	r20, r12
     29c:	95 01       	movw	r18, r10
     29e:	2e 19       	sub	r18, r14
     2a0:	3f 09       	sbc	r19, r15
     2a2:	40 0b       	sbc	r20, r16
     2a4:	51 0b       	sbc	r21, r17
     2a6:	57 fd       	sbrc	r21, 7
     2a8:	08 c0       	rjmp	.+16     	; 0x2ba <_fpadd_parts+0x1d4>
     2aa:	11 82       	std	Z+1, r1	; 0x01
     2ac:	33 82       	std	Z+3, r3	; 0x03
     2ae:	22 82       	std	Z+2, r2	; 0x02
     2b0:	24 83       	std	Z+4, r18	; 0x04
     2b2:	35 83       	std	Z+5, r19	; 0x05
     2b4:	46 83       	std	Z+6, r20	; 0x06
     2b6:	57 83       	std	Z+7, r21	; 0x07
     2b8:	1d c0       	rjmp	.+58     	; 0x2f4 <_fpadd_parts+0x20e>
     2ba:	81 e0       	ldi	r24, 0x01	; 1
     2bc:	81 83       	std	Z+1, r24	; 0x01
     2be:	33 82       	std	Z+3, r3	; 0x03
     2c0:	22 82       	std	Z+2, r2	; 0x02
     2c2:	88 27       	eor	r24, r24
     2c4:	99 27       	eor	r25, r25
     2c6:	dc 01       	movw	r26, r24
     2c8:	82 1b       	sub	r24, r18
     2ca:	93 0b       	sbc	r25, r19
     2cc:	a4 0b       	sbc	r26, r20
     2ce:	b5 0b       	sbc	r27, r21
     2d0:	84 83       	std	Z+4, r24	; 0x04
     2d2:	95 83       	std	Z+5, r25	; 0x05
     2d4:	a6 83       	std	Z+6, r26	; 0x06
     2d6:	b7 83       	std	Z+7, r27	; 0x07
     2d8:	0d c0       	rjmp	.+26     	; 0x2f4 <_fpadd_parts+0x20e>
     2da:	22 0f       	add	r18, r18
     2dc:	33 1f       	adc	r19, r19
     2de:	44 1f       	adc	r20, r20
     2e0:	55 1f       	adc	r21, r21
     2e2:	24 83       	std	Z+4, r18	; 0x04
     2e4:	35 83       	std	Z+5, r19	; 0x05
     2e6:	46 83       	std	Z+6, r20	; 0x06
     2e8:	57 83       	std	Z+7, r21	; 0x07
     2ea:	82 81       	ldd	r24, Z+2	; 0x02
     2ec:	93 81       	ldd	r25, Z+3	; 0x03
     2ee:	01 97       	sbiw	r24, 0x01	; 1
     2f0:	93 83       	std	Z+3, r25	; 0x03
     2f2:	82 83       	std	Z+2, r24	; 0x02
     2f4:	24 81       	ldd	r18, Z+4	; 0x04
     2f6:	35 81       	ldd	r19, Z+5	; 0x05
     2f8:	46 81       	ldd	r20, Z+6	; 0x06
     2fa:	57 81       	ldd	r21, Z+7	; 0x07
     2fc:	da 01       	movw	r26, r20
     2fe:	c9 01       	movw	r24, r18
     300:	01 97       	sbiw	r24, 0x01	; 1
     302:	a1 09       	sbc	r26, r1
     304:	b1 09       	sbc	r27, r1
     306:	8f 5f       	subi	r24, 0xFF	; 255
     308:	9f 4f       	sbci	r25, 0xFF	; 255
     30a:	af 4f       	sbci	r26, 0xFF	; 255
     30c:	bf 43       	sbci	r27, 0x3F	; 63
     30e:	28 f3       	brcs	.-54     	; 0x2da <_fpadd_parts+0x1f4>
     310:	0b c0       	rjmp	.+22     	; 0x328 <_fpadd_parts+0x242>
     312:	91 83       	std	Z+1, r25	; 0x01
     314:	33 82       	std	Z+3, r3	; 0x03
     316:	22 82       	std	Z+2, r2	; 0x02
     318:	ea 0c       	add	r14, r10
     31a:	fb 1c       	adc	r15, r11
     31c:	0c 1d       	adc	r16, r12
     31e:	1d 1d       	adc	r17, r13
     320:	e4 82       	std	Z+4, r14	; 0x04
     322:	f5 82       	std	Z+5, r15	; 0x05
     324:	06 83       	std	Z+6, r16	; 0x06
     326:	17 83       	std	Z+7, r17	; 0x07
     328:	83 e0       	ldi	r24, 0x03	; 3
     32a:	80 83       	st	Z, r24
     32c:	24 81       	ldd	r18, Z+4	; 0x04
     32e:	35 81       	ldd	r19, Z+5	; 0x05
     330:	46 81       	ldd	r20, Z+6	; 0x06
     332:	57 81       	ldd	r21, Z+7	; 0x07
     334:	57 ff       	sbrs	r21, 7
     336:	1a c0       	rjmp	.+52     	; 0x36c <_fpadd_parts+0x286>
     338:	c9 01       	movw	r24, r18
     33a:	aa 27       	eor	r26, r26
     33c:	97 fd       	sbrc	r25, 7
     33e:	a0 95       	com	r26
     340:	ba 2f       	mov	r27, r26
     342:	81 70       	andi	r24, 0x01	; 1
     344:	90 70       	andi	r25, 0x00	; 0
     346:	a0 70       	andi	r26, 0x00	; 0
     348:	b0 70       	andi	r27, 0x00	; 0
     34a:	56 95       	lsr	r21
     34c:	47 95       	ror	r20
     34e:	37 95       	ror	r19
     350:	27 95       	ror	r18
     352:	82 2b       	or	r24, r18
     354:	93 2b       	or	r25, r19
     356:	a4 2b       	or	r26, r20
     358:	b5 2b       	or	r27, r21
     35a:	84 83       	std	Z+4, r24	; 0x04
     35c:	95 83       	std	Z+5, r25	; 0x05
     35e:	a6 83       	std	Z+6, r26	; 0x06
     360:	b7 83       	std	Z+7, r27	; 0x07
     362:	82 81       	ldd	r24, Z+2	; 0x02
     364:	93 81       	ldd	r25, Z+3	; 0x03
     366:	01 96       	adiw	r24, 0x01	; 1
     368:	93 83       	std	Z+3, r25	; 0x03
     36a:	82 83       	std	Z+2, r24	; 0x02
     36c:	df 01       	movw	r26, r30
     36e:	01 c0       	rjmp	.+2      	; 0x372 <_fpadd_parts+0x28c>
     370:	d2 01       	movw	r26, r4
     372:	cd 01       	movw	r24, r26
     374:	cd b7       	in	r28, 0x3d	; 61
     376:	de b7       	in	r29, 0x3e	; 62
     378:	e2 e1       	ldi	r30, 0x12	; 18
     37a:	0c 94 fb 3b 	jmp	0x77f6	; 0x77f6 <__epilogue_restores__>

0000037e <__subsf3>:
     37e:	a0 e2       	ldi	r26, 0x20	; 32
     380:	b0 e0       	ldi	r27, 0x00	; 0
     382:	e5 ec       	ldi	r30, 0xC5	; 197
     384:	f1 e0       	ldi	r31, 0x01	; 1
     386:	0c 94 eb 3b 	jmp	0x77d6	; 0x77d6 <__prologue_saves__+0x18>
     38a:	69 83       	std	Y+1, r22	; 0x01
     38c:	7a 83       	std	Y+2, r23	; 0x02
     38e:	8b 83       	std	Y+3, r24	; 0x03
     390:	9c 83       	std	Y+4, r25	; 0x04
     392:	2d 83       	std	Y+5, r18	; 0x05
     394:	3e 83       	std	Y+6, r19	; 0x06
     396:	4f 83       	std	Y+7, r20	; 0x07
     398:	58 87       	std	Y+8, r21	; 0x08
     39a:	e9 e0       	ldi	r30, 0x09	; 9
     39c:	ee 2e       	mov	r14, r30
     39e:	f1 2c       	mov	r15, r1
     3a0:	ec 0e       	add	r14, r28
     3a2:	fd 1e       	adc	r15, r29
     3a4:	ce 01       	movw	r24, r28
     3a6:	01 96       	adiw	r24, 0x01	; 1
     3a8:	b7 01       	movw	r22, r14
     3aa:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     3ae:	8e 01       	movw	r16, r28
     3b0:	0f 5e       	subi	r16, 0xEF	; 239
     3b2:	1f 4f       	sbci	r17, 0xFF	; 255
     3b4:	ce 01       	movw	r24, r28
     3b6:	05 96       	adiw	r24, 0x05	; 5
     3b8:	b8 01       	movw	r22, r16
     3ba:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     3be:	8a 89       	ldd	r24, Y+18	; 0x12
     3c0:	91 e0       	ldi	r25, 0x01	; 1
     3c2:	89 27       	eor	r24, r25
     3c4:	8a 8b       	std	Y+18, r24	; 0x12
     3c6:	c7 01       	movw	r24, r14
     3c8:	b8 01       	movw	r22, r16
     3ca:	ae 01       	movw	r20, r28
     3cc:	47 5e       	subi	r20, 0xE7	; 231
     3ce:	5f 4f       	sbci	r21, 0xFF	; 255
     3d0:	0e 94 73 00 	call	0xe6	; 0xe6 <_fpadd_parts>
     3d4:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <__pack_f>
     3d8:	a0 96       	adiw	r28, 0x20	; 32
     3da:	e6 e0       	ldi	r30, 0x06	; 6
     3dc:	0c 94 07 3c 	jmp	0x780e	; 0x780e <__epilogue_restores__+0x18>

000003e0 <__addsf3>:
     3e0:	a0 e2       	ldi	r26, 0x20	; 32
     3e2:	b0 e0       	ldi	r27, 0x00	; 0
     3e4:	e6 ef       	ldi	r30, 0xF6	; 246
     3e6:	f1 e0       	ldi	r31, 0x01	; 1
     3e8:	0c 94 eb 3b 	jmp	0x77d6	; 0x77d6 <__prologue_saves__+0x18>
     3ec:	69 83       	std	Y+1, r22	; 0x01
     3ee:	7a 83       	std	Y+2, r23	; 0x02
     3f0:	8b 83       	std	Y+3, r24	; 0x03
     3f2:	9c 83       	std	Y+4, r25	; 0x04
     3f4:	2d 83       	std	Y+5, r18	; 0x05
     3f6:	3e 83       	std	Y+6, r19	; 0x06
     3f8:	4f 83       	std	Y+7, r20	; 0x07
     3fa:	58 87       	std	Y+8, r21	; 0x08
     3fc:	f9 e0       	ldi	r31, 0x09	; 9
     3fe:	ef 2e       	mov	r14, r31
     400:	f1 2c       	mov	r15, r1
     402:	ec 0e       	add	r14, r28
     404:	fd 1e       	adc	r15, r29
     406:	ce 01       	movw	r24, r28
     408:	01 96       	adiw	r24, 0x01	; 1
     40a:	b7 01       	movw	r22, r14
     40c:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     410:	8e 01       	movw	r16, r28
     412:	0f 5e       	subi	r16, 0xEF	; 239
     414:	1f 4f       	sbci	r17, 0xFF	; 255
     416:	ce 01       	movw	r24, r28
     418:	05 96       	adiw	r24, 0x05	; 5
     41a:	b8 01       	movw	r22, r16
     41c:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     420:	c7 01       	movw	r24, r14
     422:	b8 01       	movw	r22, r16
     424:	ae 01       	movw	r20, r28
     426:	47 5e       	subi	r20, 0xE7	; 231
     428:	5f 4f       	sbci	r21, 0xFF	; 255
     42a:	0e 94 73 00 	call	0xe6	; 0xe6 <_fpadd_parts>
     42e:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <__pack_f>
     432:	a0 96       	adiw	r28, 0x20	; 32
     434:	e6 e0       	ldi	r30, 0x06	; 6
     436:	0c 94 07 3c 	jmp	0x780e	; 0x780e <__epilogue_restores__+0x18>

0000043a <__mulsf3>:
     43a:	a0 e2       	ldi	r26, 0x20	; 32
     43c:	b0 e0       	ldi	r27, 0x00	; 0
     43e:	e3 e2       	ldi	r30, 0x23	; 35
     440:	f2 e0       	ldi	r31, 0x02	; 2
     442:	0c 94 df 3b 	jmp	0x77be	; 0x77be <__prologue_saves__>
     446:	69 83       	std	Y+1, r22	; 0x01
     448:	7a 83       	std	Y+2, r23	; 0x02
     44a:	8b 83       	std	Y+3, r24	; 0x03
     44c:	9c 83       	std	Y+4, r25	; 0x04
     44e:	2d 83       	std	Y+5, r18	; 0x05
     450:	3e 83       	std	Y+6, r19	; 0x06
     452:	4f 83       	std	Y+7, r20	; 0x07
     454:	58 87       	std	Y+8, r21	; 0x08
     456:	ce 01       	movw	r24, r28
     458:	01 96       	adiw	r24, 0x01	; 1
     45a:	be 01       	movw	r22, r28
     45c:	67 5f       	subi	r22, 0xF7	; 247
     45e:	7f 4f       	sbci	r23, 0xFF	; 255
     460:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     464:	ce 01       	movw	r24, r28
     466:	05 96       	adiw	r24, 0x05	; 5
     468:	be 01       	movw	r22, r28
     46a:	6f 5e       	subi	r22, 0xEF	; 239
     46c:	7f 4f       	sbci	r23, 0xFF	; 255
     46e:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     472:	99 85       	ldd	r25, Y+9	; 0x09
     474:	92 30       	cpi	r25, 0x02	; 2
     476:	88 f0       	brcs	.+34     	; 0x49a <__mulsf3+0x60>
     478:	89 89       	ldd	r24, Y+17	; 0x11
     47a:	82 30       	cpi	r24, 0x02	; 2
     47c:	c8 f0       	brcs	.+50     	; 0x4b0 <__mulsf3+0x76>
     47e:	94 30       	cpi	r25, 0x04	; 4
     480:	19 f4       	brne	.+6      	; 0x488 <__mulsf3+0x4e>
     482:	82 30       	cpi	r24, 0x02	; 2
     484:	51 f4       	brne	.+20     	; 0x49a <__mulsf3+0x60>
     486:	04 c0       	rjmp	.+8      	; 0x490 <__mulsf3+0x56>
     488:	84 30       	cpi	r24, 0x04	; 4
     48a:	29 f4       	brne	.+10     	; 0x496 <__mulsf3+0x5c>
     48c:	92 30       	cpi	r25, 0x02	; 2
     48e:	81 f4       	brne	.+32     	; 0x4b0 <__mulsf3+0x76>
     490:	82 e8       	ldi	r24, 0x82	; 130
     492:	90 e0       	ldi	r25, 0x00	; 0
     494:	c6 c0       	rjmp	.+396    	; 0x622 <__mulsf3+0x1e8>
     496:	92 30       	cpi	r25, 0x02	; 2
     498:	49 f4       	brne	.+18     	; 0x4ac <__mulsf3+0x72>
     49a:	20 e0       	ldi	r18, 0x00	; 0
     49c:	9a 85       	ldd	r25, Y+10	; 0x0a
     49e:	8a 89       	ldd	r24, Y+18	; 0x12
     4a0:	98 13       	cpse	r25, r24
     4a2:	21 e0       	ldi	r18, 0x01	; 1
     4a4:	2a 87       	std	Y+10, r18	; 0x0a
     4a6:	ce 01       	movw	r24, r28
     4a8:	09 96       	adiw	r24, 0x09	; 9
     4aa:	bb c0       	rjmp	.+374    	; 0x622 <__mulsf3+0x1e8>
     4ac:	82 30       	cpi	r24, 0x02	; 2
     4ae:	49 f4       	brne	.+18     	; 0x4c2 <__mulsf3+0x88>
     4b0:	20 e0       	ldi	r18, 0x00	; 0
     4b2:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b4:	8a 89       	ldd	r24, Y+18	; 0x12
     4b6:	98 13       	cpse	r25, r24
     4b8:	21 e0       	ldi	r18, 0x01	; 1
     4ba:	2a 8b       	std	Y+18, r18	; 0x12
     4bc:	ce 01       	movw	r24, r28
     4be:	41 96       	adiw	r24, 0x11	; 17
     4c0:	b0 c0       	rjmp	.+352    	; 0x622 <__mulsf3+0x1e8>
     4c2:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c4:	3e 84       	ldd	r3, Y+14	; 0x0e
     4c6:	4f 84       	ldd	r4, Y+15	; 0x0f
     4c8:	58 88       	ldd	r5, Y+16	; 0x10
     4ca:	6d 88       	ldd	r6, Y+21	; 0x15
     4cc:	7e 88       	ldd	r7, Y+22	; 0x16
     4ce:	8f 88       	ldd	r8, Y+23	; 0x17
     4d0:	98 8c       	ldd	r9, Y+24	; 0x18
     4d2:	ee 24       	eor	r14, r14
     4d4:	ff 24       	eor	r15, r15
     4d6:	87 01       	movw	r16, r14
     4d8:	aa 24       	eor	r10, r10
     4da:	bb 24       	eor	r11, r11
     4dc:	65 01       	movw	r12, r10
     4de:	40 e0       	ldi	r20, 0x00	; 0
     4e0:	50 e0       	ldi	r21, 0x00	; 0
     4e2:	60 e0       	ldi	r22, 0x00	; 0
     4e4:	70 e0       	ldi	r23, 0x00	; 0
     4e6:	e0 e0       	ldi	r30, 0x00	; 0
     4e8:	f0 e0       	ldi	r31, 0x00	; 0
     4ea:	c1 01       	movw	r24, r2
     4ec:	81 70       	andi	r24, 0x01	; 1
     4ee:	90 70       	andi	r25, 0x00	; 0
     4f0:	89 2b       	or	r24, r25
     4f2:	e9 f0       	breq	.+58     	; 0x52e <__mulsf3+0xf4>
     4f4:	e6 0c       	add	r14, r6
     4f6:	f7 1c       	adc	r15, r7
     4f8:	08 1d       	adc	r16, r8
     4fa:	19 1d       	adc	r17, r9
     4fc:	9a 01       	movw	r18, r20
     4fe:	ab 01       	movw	r20, r22
     500:	2a 0d       	add	r18, r10
     502:	3b 1d       	adc	r19, r11
     504:	4c 1d       	adc	r20, r12
     506:	5d 1d       	adc	r21, r13
     508:	80 e0       	ldi	r24, 0x00	; 0
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	a0 e0       	ldi	r26, 0x00	; 0
     50e:	b0 e0       	ldi	r27, 0x00	; 0
     510:	e6 14       	cp	r14, r6
     512:	f7 04       	cpc	r15, r7
     514:	08 05       	cpc	r16, r8
     516:	19 05       	cpc	r17, r9
     518:	20 f4       	brcc	.+8      	; 0x522 <__mulsf3+0xe8>
     51a:	81 e0       	ldi	r24, 0x01	; 1
     51c:	90 e0       	ldi	r25, 0x00	; 0
     51e:	a0 e0       	ldi	r26, 0x00	; 0
     520:	b0 e0       	ldi	r27, 0x00	; 0
     522:	ba 01       	movw	r22, r20
     524:	a9 01       	movw	r20, r18
     526:	48 0f       	add	r20, r24
     528:	59 1f       	adc	r21, r25
     52a:	6a 1f       	adc	r22, r26
     52c:	7b 1f       	adc	r23, r27
     52e:	aa 0c       	add	r10, r10
     530:	bb 1c       	adc	r11, r11
     532:	cc 1c       	adc	r12, r12
     534:	dd 1c       	adc	r13, r13
     536:	97 fe       	sbrs	r9, 7
     538:	08 c0       	rjmp	.+16     	; 0x54a <__mulsf3+0x110>
     53a:	81 e0       	ldi	r24, 0x01	; 1
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	a0 e0       	ldi	r26, 0x00	; 0
     540:	b0 e0       	ldi	r27, 0x00	; 0
     542:	a8 2a       	or	r10, r24
     544:	b9 2a       	or	r11, r25
     546:	ca 2a       	or	r12, r26
     548:	db 2a       	or	r13, r27
     54a:	31 96       	adiw	r30, 0x01	; 1
     54c:	e0 32       	cpi	r30, 0x20	; 32
     54e:	f1 05       	cpc	r31, r1
     550:	49 f0       	breq	.+18     	; 0x564 <__mulsf3+0x12a>
     552:	66 0c       	add	r6, r6
     554:	77 1c       	adc	r7, r7
     556:	88 1c       	adc	r8, r8
     558:	99 1c       	adc	r9, r9
     55a:	56 94       	lsr	r5
     55c:	47 94       	ror	r4
     55e:	37 94       	ror	r3
     560:	27 94       	ror	r2
     562:	c3 cf       	rjmp	.-122    	; 0x4ea <__mulsf3+0xb0>
     564:	fa 85       	ldd	r31, Y+10	; 0x0a
     566:	ea 89       	ldd	r30, Y+18	; 0x12
     568:	2b 89       	ldd	r18, Y+19	; 0x13
     56a:	3c 89       	ldd	r19, Y+20	; 0x14
     56c:	8b 85       	ldd	r24, Y+11	; 0x0b
     56e:	9c 85       	ldd	r25, Y+12	; 0x0c
     570:	28 0f       	add	r18, r24
     572:	39 1f       	adc	r19, r25
     574:	2e 5f       	subi	r18, 0xFE	; 254
     576:	3f 4f       	sbci	r19, 0xFF	; 255
     578:	17 c0       	rjmp	.+46     	; 0x5a8 <__mulsf3+0x16e>
     57a:	ca 01       	movw	r24, r20
     57c:	81 70       	andi	r24, 0x01	; 1
     57e:	90 70       	andi	r25, 0x00	; 0
     580:	89 2b       	or	r24, r25
     582:	61 f0       	breq	.+24     	; 0x59c <__mulsf3+0x162>
     584:	16 95       	lsr	r17
     586:	07 95       	ror	r16
     588:	f7 94       	ror	r15
     58a:	e7 94       	ror	r14
     58c:	80 e0       	ldi	r24, 0x00	; 0
     58e:	90 e0       	ldi	r25, 0x00	; 0
     590:	a0 e0       	ldi	r26, 0x00	; 0
     592:	b0 e8       	ldi	r27, 0x80	; 128
     594:	e8 2a       	or	r14, r24
     596:	f9 2a       	or	r15, r25
     598:	0a 2b       	or	r16, r26
     59a:	1b 2b       	or	r17, r27
     59c:	76 95       	lsr	r23
     59e:	67 95       	ror	r22
     5a0:	57 95       	ror	r21
     5a2:	47 95       	ror	r20
     5a4:	2f 5f       	subi	r18, 0xFF	; 255
     5a6:	3f 4f       	sbci	r19, 0xFF	; 255
     5a8:	77 fd       	sbrc	r23, 7
     5aa:	e7 cf       	rjmp	.-50     	; 0x57a <__mulsf3+0x140>
     5ac:	0c c0       	rjmp	.+24     	; 0x5c6 <__mulsf3+0x18c>
     5ae:	44 0f       	add	r20, r20
     5b0:	55 1f       	adc	r21, r21
     5b2:	66 1f       	adc	r22, r22
     5b4:	77 1f       	adc	r23, r23
     5b6:	17 fd       	sbrc	r17, 7
     5b8:	41 60       	ori	r20, 0x01	; 1
     5ba:	ee 0c       	add	r14, r14
     5bc:	ff 1c       	adc	r15, r15
     5be:	00 1f       	adc	r16, r16
     5c0:	11 1f       	adc	r17, r17
     5c2:	21 50       	subi	r18, 0x01	; 1
     5c4:	30 40       	sbci	r19, 0x00	; 0
     5c6:	40 30       	cpi	r20, 0x00	; 0
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	59 07       	cpc	r21, r25
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	69 07       	cpc	r22, r25
     5d0:	90 e4       	ldi	r25, 0x40	; 64
     5d2:	79 07       	cpc	r23, r25
     5d4:	60 f3       	brcs	.-40     	; 0x5ae <__mulsf3+0x174>
     5d6:	2b 8f       	std	Y+27, r18	; 0x1b
     5d8:	3c 8f       	std	Y+28, r19	; 0x1c
     5da:	db 01       	movw	r26, r22
     5dc:	ca 01       	movw	r24, r20
     5de:	8f 77       	andi	r24, 0x7F	; 127
     5e0:	90 70       	andi	r25, 0x00	; 0
     5e2:	a0 70       	andi	r26, 0x00	; 0
     5e4:	b0 70       	andi	r27, 0x00	; 0
     5e6:	80 34       	cpi	r24, 0x40	; 64
     5e8:	91 05       	cpc	r25, r1
     5ea:	a1 05       	cpc	r26, r1
     5ec:	b1 05       	cpc	r27, r1
     5ee:	61 f4       	brne	.+24     	; 0x608 <__mulsf3+0x1ce>
     5f0:	47 fd       	sbrc	r20, 7
     5f2:	0a c0       	rjmp	.+20     	; 0x608 <__mulsf3+0x1ce>
     5f4:	e1 14       	cp	r14, r1
     5f6:	f1 04       	cpc	r15, r1
     5f8:	01 05       	cpc	r16, r1
     5fa:	11 05       	cpc	r17, r1
     5fc:	29 f0       	breq	.+10     	; 0x608 <__mulsf3+0x1ce>
     5fe:	40 5c       	subi	r20, 0xC0	; 192
     600:	5f 4f       	sbci	r21, 0xFF	; 255
     602:	6f 4f       	sbci	r22, 0xFF	; 255
     604:	7f 4f       	sbci	r23, 0xFF	; 255
     606:	40 78       	andi	r20, 0x80	; 128
     608:	1a 8e       	std	Y+26, r1	; 0x1a
     60a:	fe 17       	cp	r31, r30
     60c:	11 f0       	breq	.+4      	; 0x612 <__mulsf3+0x1d8>
     60e:	81 e0       	ldi	r24, 0x01	; 1
     610:	8a 8f       	std	Y+26, r24	; 0x1a
     612:	4d 8f       	std	Y+29, r20	; 0x1d
     614:	5e 8f       	std	Y+30, r21	; 0x1e
     616:	6f 8f       	std	Y+31, r22	; 0x1f
     618:	78 a3       	std	Y+32, r23	; 0x20
     61a:	83 e0       	ldi	r24, 0x03	; 3
     61c:	89 8f       	std	Y+25, r24	; 0x19
     61e:	ce 01       	movw	r24, r28
     620:	49 96       	adiw	r24, 0x19	; 25
     622:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <__pack_f>
     626:	a0 96       	adiw	r28, 0x20	; 32
     628:	e2 e1       	ldi	r30, 0x12	; 18
     62a:	0c 94 fb 3b 	jmp	0x77f6	; 0x77f6 <__epilogue_restores__>

0000062e <__gtsf2>:
     62e:	a8 e1       	ldi	r26, 0x18	; 24
     630:	b0 e0       	ldi	r27, 0x00	; 0
     632:	ed e1       	ldi	r30, 0x1D	; 29
     634:	f3 e0       	ldi	r31, 0x03	; 3
     636:	0c 94 eb 3b 	jmp	0x77d6	; 0x77d6 <__prologue_saves__+0x18>
     63a:	69 83       	std	Y+1, r22	; 0x01
     63c:	7a 83       	std	Y+2, r23	; 0x02
     63e:	8b 83       	std	Y+3, r24	; 0x03
     640:	9c 83       	std	Y+4, r25	; 0x04
     642:	2d 83       	std	Y+5, r18	; 0x05
     644:	3e 83       	std	Y+6, r19	; 0x06
     646:	4f 83       	std	Y+7, r20	; 0x07
     648:	58 87       	std	Y+8, r21	; 0x08
     64a:	89 e0       	ldi	r24, 0x09	; 9
     64c:	e8 2e       	mov	r14, r24
     64e:	f1 2c       	mov	r15, r1
     650:	ec 0e       	add	r14, r28
     652:	fd 1e       	adc	r15, r29
     654:	ce 01       	movw	r24, r28
     656:	01 96       	adiw	r24, 0x01	; 1
     658:	b7 01       	movw	r22, r14
     65a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     65e:	8e 01       	movw	r16, r28
     660:	0f 5e       	subi	r16, 0xEF	; 239
     662:	1f 4f       	sbci	r17, 0xFF	; 255
     664:	ce 01       	movw	r24, r28
     666:	05 96       	adiw	r24, 0x05	; 5
     668:	b8 01       	movw	r22, r16
     66a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     66e:	89 85       	ldd	r24, Y+9	; 0x09
     670:	82 30       	cpi	r24, 0x02	; 2
     672:	40 f0       	brcs	.+16     	; 0x684 <__gtsf2+0x56>
     674:	89 89       	ldd	r24, Y+17	; 0x11
     676:	82 30       	cpi	r24, 0x02	; 2
     678:	28 f0       	brcs	.+10     	; 0x684 <__gtsf2+0x56>
     67a:	c7 01       	movw	r24, r14
     67c:	b8 01       	movw	r22, r16
     67e:	0e 94 48 05 	call	0xa90	; 0xa90 <__fpcmp_parts_f>
     682:	01 c0       	rjmp	.+2      	; 0x686 <__gtsf2+0x58>
     684:	8f ef       	ldi	r24, 0xFF	; 255
     686:	68 96       	adiw	r28, 0x18	; 24
     688:	e6 e0       	ldi	r30, 0x06	; 6
     68a:	0c 94 07 3c 	jmp	0x780e	; 0x780e <__epilogue_restores__+0x18>

0000068e <__gesf2>:
     68e:	a8 e1       	ldi	r26, 0x18	; 24
     690:	b0 e0       	ldi	r27, 0x00	; 0
     692:	ed e4       	ldi	r30, 0x4D	; 77
     694:	f3 e0       	ldi	r31, 0x03	; 3
     696:	0c 94 eb 3b 	jmp	0x77d6	; 0x77d6 <__prologue_saves__+0x18>
     69a:	69 83       	std	Y+1, r22	; 0x01
     69c:	7a 83       	std	Y+2, r23	; 0x02
     69e:	8b 83       	std	Y+3, r24	; 0x03
     6a0:	9c 83       	std	Y+4, r25	; 0x04
     6a2:	2d 83       	std	Y+5, r18	; 0x05
     6a4:	3e 83       	std	Y+6, r19	; 0x06
     6a6:	4f 83       	std	Y+7, r20	; 0x07
     6a8:	58 87       	std	Y+8, r21	; 0x08
     6aa:	89 e0       	ldi	r24, 0x09	; 9
     6ac:	e8 2e       	mov	r14, r24
     6ae:	f1 2c       	mov	r15, r1
     6b0:	ec 0e       	add	r14, r28
     6b2:	fd 1e       	adc	r15, r29
     6b4:	ce 01       	movw	r24, r28
     6b6:	01 96       	adiw	r24, 0x01	; 1
     6b8:	b7 01       	movw	r22, r14
     6ba:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     6be:	8e 01       	movw	r16, r28
     6c0:	0f 5e       	subi	r16, 0xEF	; 239
     6c2:	1f 4f       	sbci	r17, 0xFF	; 255
     6c4:	ce 01       	movw	r24, r28
     6c6:	05 96       	adiw	r24, 0x05	; 5
     6c8:	b8 01       	movw	r22, r16
     6ca:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     6ce:	89 85       	ldd	r24, Y+9	; 0x09
     6d0:	82 30       	cpi	r24, 0x02	; 2
     6d2:	40 f0       	brcs	.+16     	; 0x6e4 <__gesf2+0x56>
     6d4:	89 89       	ldd	r24, Y+17	; 0x11
     6d6:	82 30       	cpi	r24, 0x02	; 2
     6d8:	28 f0       	brcs	.+10     	; 0x6e4 <__gesf2+0x56>
     6da:	c7 01       	movw	r24, r14
     6dc:	b8 01       	movw	r22, r16
     6de:	0e 94 48 05 	call	0xa90	; 0xa90 <__fpcmp_parts_f>
     6e2:	01 c0       	rjmp	.+2      	; 0x6e6 <__gesf2+0x58>
     6e4:	8f ef       	ldi	r24, 0xFF	; 255
     6e6:	68 96       	adiw	r28, 0x18	; 24
     6e8:	e6 e0       	ldi	r30, 0x06	; 6
     6ea:	0c 94 07 3c 	jmp	0x780e	; 0x780e <__epilogue_restores__+0x18>

000006ee <__ltsf2>:
     6ee:	a8 e1       	ldi	r26, 0x18	; 24
     6f0:	b0 e0       	ldi	r27, 0x00	; 0
     6f2:	ed e7       	ldi	r30, 0x7D	; 125
     6f4:	f3 e0       	ldi	r31, 0x03	; 3
     6f6:	0c 94 eb 3b 	jmp	0x77d6	; 0x77d6 <__prologue_saves__+0x18>
     6fa:	69 83       	std	Y+1, r22	; 0x01
     6fc:	7a 83       	std	Y+2, r23	; 0x02
     6fe:	8b 83       	std	Y+3, r24	; 0x03
     700:	9c 83       	std	Y+4, r25	; 0x04
     702:	2d 83       	std	Y+5, r18	; 0x05
     704:	3e 83       	std	Y+6, r19	; 0x06
     706:	4f 83       	std	Y+7, r20	; 0x07
     708:	58 87       	std	Y+8, r21	; 0x08
     70a:	89 e0       	ldi	r24, 0x09	; 9
     70c:	e8 2e       	mov	r14, r24
     70e:	f1 2c       	mov	r15, r1
     710:	ec 0e       	add	r14, r28
     712:	fd 1e       	adc	r15, r29
     714:	ce 01       	movw	r24, r28
     716:	01 96       	adiw	r24, 0x01	; 1
     718:	b7 01       	movw	r22, r14
     71a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     71e:	8e 01       	movw	r16, r28
     720:	0f 5e       	subi	r16, 0xEF	; 239
     722:	1f 4f       	sbci	r17, 0xFF	; 255
     724:	ce 01       	movw	r24, r28
     726:	05 96       	adiw	r24, 0x05	; 5
     728:	b8 01       	movw	r22, r16
     72a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     72e:	89 85       	ldd	r24, Y+9	; 0x09
     730:	82 30       	cpi	r24, 0x02	; 2
     732:	40 f0       	brcs	.+16     	; 0x744 <__ltsf2+0x56>
     734:	89 89       	ldd	r24, Y+17	; 0x11
     736:	82 30       	cpi	r24, 0x02	; 2
     738:	28 f0       	brcs	.+10     	; 0x744 <__ltsf2+0x56>
     73a:	c7 01       	movw	r24, r14
     73c:	b8 01       	movw	r22, r16
     73e:	0e 94 48 05 	call	0xa90	; 0xa90 <__fpcmp_parts_f>
     742:	01 c0       	rjmp	.+2      	; 0x746 <__ltsf2+0x58>
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	68 96       	adiw	r28, 0x18	; 24
     748:	e6 e0       	ldi	r30, 0x06	; 6
     74a:	0c 94 07 3c 	jmp	0x780e	; 0x780e <__epilogue_restores__+0x18>

0000074e <__fixsfsi>:
     74e:	ac e0       	ldi	r26, 0x0C	; 12
     750:	b0 e0       	ldi	r27, 0x00	; 0
     752:	ed ea       	ldi	r30, 0xAD	; 173
     754:	f3 e0       	ldi	r31, 0x03	; 3
     756:	0c 94 ef 3b 	jmp	0x77de	; 0x77de <__prologue_saves__+0x20>
     75a:	69 83       	std	Y+1, r22	; 0x01
     75c:	7a 83       	std	Y+2, r23	; 0x02
     75e:	8b 83       	std	Y+3, r24	; 0x03
     760:	9c 83       	std	Y+4, r25	; 0x04
     762:	ce 01       	movw	r24, r28
     764:	01 96       	adiw	r24, 0x01	; 1
     766:	be 01       	movw	r22, r28
     768:	6b 5f       	subi	r22, 0xFB	; 251
     76a:	7f 4f       	sbci	r23, 0xFF	; 255
     76c:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__unpack_f>
     770:	8d 81       	ldd	r24, Y+5	; 0x05
     772:	82 30       	cpi	r24, 0x02	; 2
     774:	61 f1       	breq	.+88     	; 0x7ce <__fixsfsi+0x80>
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	50 f1       	brcs	.+84     	; 0x7ce <__fixsfsi+0x80>
     77a:	84 30       	cpi	r24, 0x04	; 4
     77c:	21 f4       	brne	.+8      	; 0x786 <__fixsfsi+0x38>
     77e:	8e 81       	ldd	r24, Y+6	; 0x06
     780:	88 23       	and	r24, r24
     782:	51 f1       	breq	.+84     	; 0x7d8 <__fixsfsi+0x8a>
     784:	2e c0       	rjmp	.+92     	; 0x7e2 <__fixsfsi+0x94>
     786:	2f 81       	ldd	r18, Y+7	; 0x07
     788:	38 85       	ldd	r19, Y+8	; 0x08
     78a:	37 fd       	sbrc	r19, 7
     78c:	20 c0       	rjmp	.+64     	; 0x7ce <__fixsfsi+0x80>
     78e:	6e 81       	ldd	r22, Y+6	; 0x06
     790:	2f 31       	cpi	r18, 0x1F	; 31
     792:	31 05       	cpc	r19, r1
     794:	1c f0       	brlt	.+6      	; 0x79c <__fixsfsi+0x4e>
     796:	66 23       	and	r22, r22
     798:	f9 f0       	breq	.+62     	; 0x7d8 <__fixsfsi+0x8a>
     79a:	23 c0       	rjmp	.+70     	; 0x7e2 <__fixsfsi+0x94>
     79c:	8e e1       	ldi	r24, 0x1E	; 30
     79e:	90 e0       	ldi	r25, 0x00	; 0
     7a0:	82 1b       	sub	r24, r18
     7a2:	93 0b       	sbc	r25, r19
     7a4:	29 85       	ldd	r18, Y+9	; 0x09
     7a6:	3a 85       	ldd	r19, Y+10	; 0x0a
     7a8:	4b 85       	ldd	r20, Y+11	; 0x0b
     7aa:	5c 85       	ldd	r21, Y+12	; 0x0c
     7ac:	04 c0       	rjmp	.+8      	; 0x7b6 <__fixsfsi+0x68>
     7ae:	56 95       	lsr	r21
     7b0:	47 95       	ror	r20
     7b2:	37 95       	ror	r19
     7b4:	27 95       	ror	r18
     7b6:	8a 95       	dec	r24
     7b8:	d2 f7       	brpl	.-12     	; 0x7ae <__fixsfsi+0x60>
     7ba:	66 23       	and	r22, r22
     7bc:	b1 f0       	breq	.+44     	; 0x7ea <__fixsfsi+0x9c>
     7be:	50 95       	com	r21
     7c0:	40 95       	com	r20
     7c2:	30 95       	com	r19
     7c4:	21 95       	neg	r18
     7c6:	3f 4f       	sbci	r19, 0xFF	; 255
     7c8:	4f 4f       	sbci	r20, 0xFF	; 255
     7ca:	5f 4f       	sbci	r21, 0xFF	; 255
     7cc:	0e c0       	rjmp	.+28     	; 0x7ea <__fixsfsi+0x9c>
     7ce:	20 e0       	ldi	r18, 0x00	; 0
     7d0:	30 e0       	ldi	r19, 0x00	; 0
     7d2:	40 e0       	ldi	r20, 0x00	; 0
     7d4:	50 e0       	ldi	r21, 0x00	; 0
     7d6:	09 c0       	rjmp	.+18     	; 0x7ea <__fixsfsi+0x9c>
     7d8:	2f ef       	ldi	r18, 0xFF	; 255
     7da:	3f ef       	ldi	r19, 0xFF	; 255
     7dc:	4f ef       	ldi	r20, 0xFF	; 255
     7de:	5f e7       	ldi	r21, 0x7F	; 127
     7e0:	04 c0       	rjmp	.+8      	; 0x7ea <__fixsfsi+0x9c>
     7e2:	20 e0       	ldi	r18, 0x00	; 0
     7e4:	30 e0       	ldi	r19, 0x00	; 0
     7e6:	40 e0       	ldi	r20, 0x00	; 0
     7e8:	50 e8       	ldi	r21, 0x80	; 128
     7ea:	b9 01       	movw	r22, r18
     7ec:	ca 01       	movw	r24, r20
     7ee:	2c 96       	adiw	r28, 0x0c	; 12
     7f0:	e2 e0       	ldi	r30, 0x02	; 2
     7f2:	0c 94 0b 3c 	jmp	0x7816	; 0x7816 <__epilogue_restores__+0x20>

000007f6 <__pack_f>:
     7f6:	df 92       	push	r13
     7f8:	ef 92       	push	r14
     7fa:	ff 92       	push	r15
     7fc:	0f 93       	push	r16
     7fe:	1f 93       	push	r17
     800:	fc 01       	movw	r30, r24
     802:	e4 80       	ldd	r14, Z+4	; 0x04
     804:	f5 80       	ldd	r15, Z+5	; 0x05
     806:	06 81       	ldd	r16, Z+6	; 0x06
     808:	17 81       	ldd	r17, Z+7	; 0x07
     80a:	d1 80       	ldd	r13, Z+1	; 0x01
     80c:	80 81       	ld	r24, Z
     80e:	82 30       	cpi	r24, 0x02	; 2
     810:	48 f4       	brcc	.+18     	; 0x824 <__pack_f+0x2e>
     812:	80 e0       	ldi	r24, 0x00	; 0
     814:	90 e0       	ldi	r25, 0x00	; 0
     816:	a0 e1       	ldi	r26, 0x10	; 16
     818:	b0 e0       	ldi	r27, 0x00	; 0
     81a:	e8 2a       	or	r14, r24
     81c:	f9 2a       	or	r15, r25
     81e:	0a 2b       	or	r16, r26
     820:	1b 2b       	or	r17, r27
     822:	a5 c0       	rjmp	.+330    	; 0x96e <__stack+0x10f>
     824:	84 30       	cpi	r24, 0x04	; 4
     826:	09 f4       	brne	.+2      	; 0x82a <__pack_f+0x34>
     828:	9f c0       	rjmp	.+318    	; 0x968 <__stack+0x109>
     82a:	82 30       	cpi	r24, 0x02	; 2
     82c:	21 f4       	brne	.+8      	; 0x836 <__pack_f+0x40>
     82e:	ee 24       	eor	r14, r14
     830:	ff 24       	eor	r15, r15
     832:	87 01       	movw	r16, r14
     834:	05 c0       	rjmp	.+10     	; 0x840 <__pack_f+0x4a>
     836:	e1 14       	cp	r14, r1
     838:	f1 04       	cpc	r15, r1
     83a:	01 05       	cpc	r16, r1
     83c:	11 05       	cpc	r17, r1
     83e:	19 f4       	brne	.+6      	; 0x846 <__pack_f+0x50>
     840:	e0 e0       	ldi	r30, 0x00	; 0
     842:	f0 e0       	ldi	r31, 0x00	; 0
     844:	96 c0       	rjmp	.+300    	; 0x972 <__stack+0x113>
     846:	62 81       	ldd	r22, Z+2	; 0x02
     848:	73 81       	ldd	r23, Z+3	; 0x03
     84a:	9f ef       	ldi	r25, 0xFF	; 255
     84c:	62 38       	cpi	r22, 0x82	; 130
     84e:	79 07       	cpc	r23, r25
     850:	0c f0       	brlt	.+2      	; 0x854 <__pack_f+0x5e>
     852:	5b c0       	rjmp	.+182    	; 0x90a <__stack+0xab>
     854:	22 e8       	ldi	r18, 0x82	; 130
     856:	3f ef       	ldi	r19, 0xFF	; 255
     858:	26 1b       	sub	r18, r22
     85a:	37 0b       	sbc	r19, r23
     85c:	2a 31       	cpi	r18, 0x1A	; 26
     85e:	31 05       	cpc	r19, r1
     860:	2c f0       	brlt	.+10     	; 0x86c <__stack+0xd>
     862:	20 e0       	ldi	r18, 0x00	; 0
     864:	30 e0       	ldi	r19, 0x00	; 0
     866:	40 e0       	ldi	r20, 0x00	; 0
     868:	50 e0       	ldi	r21, 0x00	; 0
     86a:	2a c0       	rjmp	.+84     	; 0x8c0 <__stack+0x61>
     86c:	b8 01       	movw	r22, r16
     86e:	a7 01       	movw	r20, r14
     870:	02 2e       	mov	r0, r18
     872:	04 c0       	rjmp	.+8      	; 0x87c <__stack+0x1d>
     874:	76 95       	lsr	r23
     876:	67 95       	ror	r22
     878:	57 95       	ror	r21
     87a:	47 95       	ror	r20
     87c:	0a 94       	dec	r0
     87e:	d2 f7       	brpl	.-12     	; 0x874 <__stack+0x15>
     880:	81 e0       	ldi	r24, 0x01	; 1
     882:	90 e0       	ldi	r25, 0x00	; 0
     884:	a0 e0       	ldi	r26, 0x00	; 0
     886:	b0 e0       	ldi	r27, 0x00	; 0
     888:	04 c0       	rjmp	.+8      	; 0x892 <__stack+0x33>
     88a:	88 0f       	add	r24, r24
     88c:	99 1f       	adc	r25, r25
     88e:	aa 1f       	adc	r26, r26
     890:	bb 1f       	adc	r27, r27
     892:	2a 95       	dec	r18
     894:	d2 f7       	brpl	.-12     	; 0x88a <__stack+0x2b>
     896:	01 97       	sbiw	r24, 0x01	; 1
     898:	a1 09       	sbc	r26, r1
     89a:	b1 09       	sbc	r27, r1
     89c:	8e 21       	and	r24, r14
     89e:	9f 21       	and	r25, r15
     8a0:	a0 23       	and	r26, r16
     8a2:	b1 23       	and	r27, r17
     8a4:	00 97       	sbiw	r24, 0x00	; 0
     8a6:	a1 05       	cpc	r26, r1
     8a8:	b1 05       	cpc	r27, r1
     8aa:	21 f0       	breq	.+8      	; 0x8b4 <__stack+0x55>
     8ac:	81 e0       	ldi	r24, 0x01	; 1
     8ae:	90 e0       	ldi	r25, 0x00	; 0
     8b0:	a0 e0       	ldi	r26, 0x00	; 0
     8b2:	b0 e0       	ldi	r27, 0x00	; 0
     8b4:	9a 01       	movw	r18, r20
     8b6:	ab 01       	movw	r20, r22
     8b8:	28 2b       	or	r18, r24
     8ba:	39 2b       	or	r19, r25
     8bc:	4a 2b       	or	r20, r26
     8be:	5b 2b       	or	r21, r27
     8c0:	da 01       	movw	r26, r20
     8c2:	c9 01       	movw	r24, r18
     8c4:	8f 77       	andi	r24, 0x7F	; 127
     8c6:	90 70       	andi	r25, 0x00	; 0
     8c8:	a0 70       	andi	r26, 0x00	; 0
     8ca:	b0 70       	andi	r27, 0x00	; 0
     8cc:	80 34       	cpi	r24, 0x40	; 64
     8ce:	91 05       	cpc	r25, r1
     8d0:	a1 05       	cpc	r26, r1
     8d2:	b1 05       	cpc	r27, r1
     8d4:	39 f4       	brne	.+14     	; 0x8e4 <__stack+0x85>
     8d6:	27 ff       	sbrs	r18, 7
     8d8:	09 c0       	rjmp	.+18     	; 0x8ec <__stack+0x8d>
     8da:	20 5c       	subi	r18, 0xC0	; 192
     8dc:	3f 4f       	sbci	r19, 0xFF	; 255
     8de:	4f 4f       	sbci	r20, 0xFF	; 255
     8e0:	5f 4f       	sbci	r21, 0xFF	; 255
     8e2:	04 c0       	rjmp	.+8      	; 0x8ec <__stack+0x8d>
     8e4:	21 5c       	subi	r18, 0xC1	; 193
     8e6:	3f 4f       	sbci	r19, 0xFF	; 255
     8e8:	4f 4f       	sbci	r20, 0xFF	; 255
     8ea:	5f 4f       	sbci	r21, 0xFF	; 255
     8ec:	e0 e0       	ldi	r30, 0x00	; 0
     8ee:	f0 e0       	ldi	r31, 0x00	; 0
     8f0:	20 30       	cpi	r18, 0x00	; 0
     8f2:	a0 e0       	ldi	r26, 0x00	; 0
     8f4:	3a 07       	cpc	r19, r26
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	4a 07       	cpc	r20, r26
     8fa:	a0 e4       	ldi	r26, 0x40	; 64
     8fc:	5a 07       	cpc	r21, r26
     8fe:	10 f0       	brcs	.+4      	; 0x904 <__stack+0xa5>
     900:	e1 e0       	ldi	r30, 0x01	; 1
     902:	f0 e0       	ldi	r31, 0x00	; 0
     904:	79 01       	movw	r14, r18
     906:	8a 01       	movw	r16, r20
     908:	27 c0       	rjmp	.+78     	; 0x958 <__stack+0xf9>
     90a:	60 38       	cpi	r22, 0x80	; 128
     90c:	71 05       	cpc	r23, r1
     90e:	64 f5       	brge	.+88     	; 0x968 <__stack+0x109>
     910:	fb 01       	movw	r30, r22
     912:	e1 58       	subi	r30, 0x81	; 129
     914:	ff 4f       	sbci	r31, 0xFF	; 255
     916:	d8 01       	movw	r26, r16
     918:	c7 01       	movw	r24, r14
     91a:	8f 77       	andi	r24, 0x7F	; 127
     91c:	90 70       	andi	r25, 0x00	; 0
     91e:	a0 70       	andi	r26, 0x00	; 0
     920:	b0 70       	andi	r27, 0x00	; 0
     922:	80 34       	cpi	r24, 0x40	; 64
     924:	91 05       	cpc	r25, r1
     926:	a1 05       	cpc	r26, r1
     928:	b1 05       	cpc	r27, r1
     92a:	39 f4       	brne	.+14     	; 0x93a <__stack+0xdb>
     92c:	e7 fe       	sbrs	r14, 7
     92e:	0d c0       	rjmp	.+26     	; 0x94a <__stack+0xeb>
     930:	80 e4       	ldi	r24, 0x40	; 64
     932:	90 e0       	ldi	r25, 0x00	; 0
     934:	a0 e0       	ldi	r26, 0x00	; 0
     936:	b0 e0       	ldi	r27, 0x00	; 0
     938:	04 c0       	rjmp	.+8      	; 0x942 <__stack+0xe3>
     93a:	8f e3       	ldi	r24, 0x3F	; 63
     93c:	90 e0       	ldi	r25, 0x00	; 0
     93e:	a0 e0       	ldi	r26, 0x00	; 0
     940:	b0 e0       	ldi	r27, 0x00	; 0
     942:	e8 0e       	add	r14, r24
     944:	f9 1e       	adc	r15, r25
     946:	0a 1f       	adc	r16, r26
     948:	1b 1f       	adc	r17, r27
     94a:	17 ff       	sbrs	r17, 7
     94c:	05 c0       	rjmp	.+10     	; 0x958 <__stack+0xf9>
     94e:	16 95       	lsr	r17
     950:	07 95       	ror	r16
     952:	f7 94       	ror	r15
     954:	e7 94       	ror	r14
     956:	31 96       	adiw	r30, 0x01	; 1
     958:	87 e0       	ldi	r24, 0x07	; 7
     95a:	16 95       	lsr	r17
     95c:	07 95       	ror	r16
     95e:	f7 94       	ror	r15
     960:	e7 94       	ror	r14
     962:	8a 95       	dec	r24
     964:	d1 f7       	brne	.-12     	; 0x95a <__stack+0xfb>
     966:	05 c0       	rjmp	.+10     	; 0x972 <__stack+0x113>
     968:	ee 24       	eor	r14, r14
     96a:	ff 24       	eor	r15, r15
     96c:	87 01       	movw	r16, r14
     96e:	ef ef       	ldi	r30, 0xFF	; 255
     970:	f0 e0       	ldi	r31, 0x00	; 0
     972:	6e 2f       	mov	r22, r30
     974:	67 95       	ror	r22
     976:	66 27       	eor	r22, r22
     978:	67 95       	ror	r22
     97a:	90 2f       	mov	r25, r16
     97c:	9f 77       	andi	r25, 0x7F	; 127
     97e:	d7 94       	ror	r13
     980:	dd 24       	eor	r13, r13
     982:	d7 94       	ror	r13
     984:	8e 2f       	mov	r24, r30
     986:	86 95       	lsr	r24
     988:	49 2f       	mov	r20, r25
     98a:	46 2b       	or	r20, r22
     98c:	58 2f       	mov	r21, r24
     98e:	5d 29       	or	r21, r13
     990:	b7 01       	movw	r22, r14
     992:	ca 01       	movw	r24, r20
     994:	1f 91       	pop	r17
     996:	0f 91       	pop	r16
     998:	ff 90       	pop	r15
     99a:	ef 90       	pop	r14
     99c:	df 90       	pop	r13
     99e:	08 95       	ret

000009a0 <__unpack_f>:
     9a0:	fc 01       	movw	r30, r24
     9a2:	db 01       	movw	r26, r22
     9a4:	40 81       	ld	r20, Z
     9a6:	51 81       	ldd	r21, Z+1	; 0x01
     9a8:	22 81       	ldd	r18, Z+2	; 0x02
     9aa:	62 2f       	mov	r22, r18
     9ac:	6f 77       	andi	r22, 0x7F	; 127
     9ae:	70 e0       	ldi	r23, 0x00	; 0
     9b0:	22 1f       	adc	r18, r18
     9b2:	22 27       	eor	r18, r18
     9b4:	22 1f       	adc	r18, r18
     9b6:	93 81       	ldd	r25, Z+3	; 0x03
     9b8:	89 2f       	mov	r24, r25
     9ba:	88 0f       	add	r24, r24
     9bc:	82 2b       	or	r24, r18
     9be:	28 2f       	mov	r18, r24
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	99 1f       	adc	r25, r25
     9c4:	99 27       	eor	r25, r25
     9c6:	99 1f       	adc	r25, r25
     9c8:	11 96       	adiw	r26, 0x01	; 1
     9ca:	9c 93       	st	X, r25
     9cc:	11 97       	sbiw	r26, 0x01	; 1
     9ce:	21 15       	cp	r18, r1
     9d0:	31 05       	cpc	r19, r1
     9d2:	a9 f5       	brne	.+106    	; 0xa3e <__unpack_f+0x9e>
     9d4:	41 15       	cp	r20, r1
     9d6:	51 05       	cpc	r21, r1
     9d8:	61 05       	cpc	r22, r1
     9da:	71 05       	cpc	r23, r1
     9dc:	11 f4       	brne	.+4      	; 0x9e2 <__unpack_f+0x42>
     9de:	82 e0       	ldi	r24, 0x02	; 2
     9e0:	37 c0       	rjmp	.+110    	; 0xa50 <__unpack_f+0xb0>
     9e2:	82 e8       	ldi	r24, 0x82	; 130
     9e4:	9f ef       	ldi	r25, 0xFF	; 255
     9e6:	13 96       	adiw	r26, 0x03	; 3
     9e8:	9c 93       	st	X, r25
     9ea:	8e 93       	st	-X, r24
     9ec:	12 97       	sbiw	r26, 0x02	; 2
     9ee:	9a 01       	movw	r18, r20
     9f0:	ab 01       	movw	r20, r22
     9f2:	67 e0       	ldi	r22, 0x07	; 7
     9f4:	22 0f       	add	r18, r18
     9f6:	33 1f       	adc	r19, r19
     9f8:	44 1f       	adc	r20, r20
     9fa:	55 1f       	adc	r21, r21
     9fc:	6a 95       	dec	r22
     9fe:	d1 f7       	brne	.-12     	; 0x9f4 <__unpack_f+0x54>
     a00:	83 e0       	ldi	r24, 0x03	; 3
     a02:	8c 93       	st	X, r24
     a04:	0d c0       	rjmp	.+26     	; 0xa20 <__unpack_f+0x80>
     a06:	22 0f       	add	r18, r18
     a08:	33 1f       	adc	r19, r19
     a0a:	44 1f       	adc	r20, r20
     a0c:	55 1f       	adc	r21, r21
     a0e:	12 96       	adiw	r26, 0x02	; 2
     a10:	8d 91       	ld	r24, X+
     a12:	9c 91       	ld	r25, X
     a14:	13 97       	sbiw	r26, 0x03	; 3
     a16:	01 97       	sbiw	r24, 0x01	; 1
     a18:	13 96       	adiw	r26, 0x03	; 3
     a1a:	9c 93       	st	X, r25
     a1c:	8e 93       	st	-X, r24
     a1e:	12 97       	sbiw	r26, 0x02	; 2
     a20:	20 30       	cpi	r18, 0x00	; 0
     a22:	80 e0       	ldi	r24, 0x00	; 0
     a24:	38 07       	cpc	r19, r24
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	48 07       	cpc	r20, r24
     a2a:	80 e4       	ldi	r24, 0x40	; 64
     a2c:	58 07       	cpc	r21, r24
     a2e:	58 f3       	brcs	.-42     	; 0xa06 <__unpack_f+0x66>
     a30:	14 96       	adiw	r26, 0x04	; 4
     a32:	2d 93       	st	X+, r18
     a34:	3d 93       	st	X+, r19
     a36:	4d 93       	st	X+, r20
     a38:	5c 93       	st	X, r21
     a3a:	17 97       	sbiw	r26, 0x07	; 7
     a3c:	08 95       	ret
     a3e:	2f 3f       	cpi	r18, 0xFF	; 255
     a40:	31 05       	cpc	r19, r1
     a42:	79 f4       	brne	.+30     	; 0xa62 <__unpack_f+0xc2>
     a44:	41 15       	cp	r20, r1
     a46:	51 05       	cpc	r21, r1
     a48:	61 05       	cpc	r22, r1
     a4a:	71 05       	cpc	r23, r1
     a4c:	19 f4       	brne	.+6      	; 0xa54 <__unpack_f+0xb4>
     a4e:	84 e0       	ldi	r24, 0x04	; 4
     a50:	8c 93       	st	X, r24
     a52:	08 95       	ret
     a54:	64 ff       	sbrs	r22, 4
     a56:	03 c0       	rjmp	.+6      	; 0xa5e <__unpack_f+0xbe>
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	8c 93       	st	X, r24
     a5c:	12 c0       	rjmp	.+36     	; 0xa82 <__unpack_f+0xe2>
     a5e:	1c 92       	st	X, r1
     a60:	10 c0       	rjmp	.+32     	; 0xa82 <__unpack_f+0xe2>
     a62:	2f 57       	subi	r18, 0x7F	; 127
     a64:	30 40       	sbci	r19, 0x00	; 0
     a66:	13 96       	adiw	r26, 0x03	; 3
     a68:	3c 93       	st	X, r19
     a6a:	2e 93       	st	-X, r18
     a6c:	12 97       	sbiw	r26, 0x02	; 2
     a6e:	83 e0       	ldi	r24, 0x03	; 3
     a70:	8c 93       	st	X, r24
     a72:	87 e0       	ldi	r24, 0x07	; 7
     a74:	44 0f       	add	r20, r20
     a76:	55 1f       	adc	r21, r21
     a78:	66 1f       	adc	r22, r22
     a7a:	77 1f       	adc	r23, r23
     a7c:	8a 95       	dec	r24
     a7e:	d1 f7       	brne	.-12     	; 0xa74 <__unpack_f+0xd4>
     a80:	70 64       	ori	r23, 0x40	; 64
     a82:	14 96       	adiw	r26, 0x04	; 4
     a84:	4d 93       	st	X+, r20
     a86:	5d 93       	st	X+, r21
     a88:	6d 93       	st	X+, r22
     a8a:	7c 93       	st	X, r23
     a8c:	17 97       	sbiw	r26, 0x07	; 7
     a8e:	08 95       	ret

00000a90 <__fpcmp_parts_f>:
     a90:	1f 93       	push	r17
     a92:	dc 01       	movw	r26, r24
     a94:	fb 01       	movw	r30, r22
     a96:	9c 91       	ld	r25, X
     a98:	92 30       	cpi	r25, 0x02	; 2
     a9a:	08 f4       	brcc	.+2      	; 0xa9e <__fpcmp_parts_f+0xe>
     a9c:	47 c0       	rjmp	.+142    	; 0xb2c <__fpcmp_parts_f+0x9c>
     a9e:	80 81       	ld	r24, Z
     aa0:	82 30       	cpi	r24, 0x02	; 2
     aa2:	08 f4       	brcc	.+2      	; 0xaa6 <__fpcmp_parts_f+0x16>
     aa4:	43 c0       	rjmp	.+134    	; 0xb2c <__fpcmp_parts_f+0x9c>
     aa6:	94 30       	cpi	r25, 0x04	; 4
     aa8:	51 f4       	brne	.+20     	; 0xabe <__fpcmp_parts_f+0x2e>
     aaa:	11 96       	adiw	r26, 0x01	; 1
     aac:	1c 91       	ld	r17, X
     aae:	84 30       	cpi	r24, 0x04	; 4
     ab0:	99 f5       	brne	.+102    	; 0xb18 <__fpcmp_parts_f+0x88>
     ab2:	81 81       	ldd	r24, Z+1	; 0x01
     ab4:	68 2f       	mov	r22, r24
     ab6:	70 e0       	ldi	r23, 0x00	; 0
     ab8:	61 1b       	sub	r22, r17
     aba:	71 09       	sbc	r23, r1
     abc:	3f c0       	rjmp	.+126    	; 0xb3c <__fpcmp_parts_f+0xac>
     abe:	84 30       	cpi	r24, 0x04	; 4
     ac0:	21 f0       	breq	.+8      	; 0xaca <__fpcmp_parts_f+0x3a>
     ac2:	92 30       	cpi	r25, 0x02	; 2
     ac4:	31 f4       	brne	.+12     	; 0xad2 <__fpcmp_parts_f+0x42>
     ac6:	82 30       	cpi	r24, 0x02	; 2
     ac8:	b9 f1       	breq	.+110    	; 0xb38 <__fpcmp_parts_f+0xa8>
     aca:	81 81       	ldd	r24, Z+1	; 0x01
     acc:	88 23       	and	r24, r24
     ace:	89 f1       	breq	.+98     	; 0xb32 <__fpcmp_parts_f+0xa2>
     ad0:	2d c0       	rjmp	.+90     	; 0xb2c <__fpcmp_parts_f+0x9c>
     ad2:	11 96       	adiw	r26, 0x01	; 1
     ad4:	1c 91       	ld	r17, X
     ad6:	11 97       	sbiw	r26, 0x01	; 1
     ad8:	82 30       	cpi	r24, 0x02	; 2
     ada:	f1 f0       	breq	.+60     	; 0xb18 <__fpcmp_parts_f+0x88>
     adc:	81 81       	ldd	r24, Z+1	; 0x01
     ade:	18 17       	cp	r17, r24
     ae0:	d9 f4       	brne	.+54     	; 0xb18 <__fpcmp_parts_f+0x88>
     ae2:	12 96       	adiw	r26, 0x02	; 2
     ae4:	2d 91       	ld	r18, X+
     ae6:	3c 91       	ld	r19, X
     ae8:	13 97       	sbiw	r26, 0x03	; 3
     aea:	82 81       	ldd	r24, Z+2	; 0x02
     aec:	93 81       	ldd	r25, Z+3	; 0x03
     aee:	82 17       	cp	r24, r18
     af0:	93 07       	cpc	r25, r19
     af2:	94 f0       	brlt	.+36     	; 0xb18 <__fpcmp_parts_f+0x88>
     af4:	28 17       	cp	r18, r24
     af6:	39 07       	cpc	r19, r25
     af8:	bc f0       	brlt	.+46     	; 0xb28 <__fpcmp_parts_f+0x98>
     afa:	14 96       	adiw	r26, 0x04	; 4
     afc:	8d 91       	ld	r24, X+
     afe:	9d 91       	ld	r25, X+
     b00:	0d 90       	ld	r0, X+
     b02:	bc 91       	ld	r27, X
     b04:	a0 2d       	mov	r26, r0
     b06:	24 81       	ldd	r18, Z+4	; 0x04
     b08:	35 81       	ldd	r19, Z+5	; 0x05
     b0a:	46 81       	ldd	r20, Z+6	; 0x06
     b0c:	57 81       	ldd	r21, Z+7	; 0x07
     b0e:	28 17       	cp	r18, r24
     b10:	39 07       	cpc	r19, r25
     b12:	4a 07       	cpc	r20, r26
     b14:	5b 07       	cpc	r21, r27
     b16:	18 f4       	brcc	.+6      	; 0xb1e <__fpcmp_parts_f+0x8e>
     b18:	11 23       	and	r17, r17
     b1a:	41 f0       	breq	.+16     	; 0xb2c <__fpcmp_parts_f+0x9c>
     b1c:	0a c0       	rjmp	.+20     	; 0xb32 <__fpcmp_parts_f+0xa2>
     b1e:	82 17       	cp	r24, r18
     b20:	93 07       	cpc	r25, r19
     b22:	a4 07       	cpc	r26, r20
     b24:	b5 07       	cpc	r27, r21
     b26:	40 f4       	brcc	.+16     	; 0xb38 <__fpcmp_parts_f+0xa8>
     b28:	11 23       	and	r17, r17
     b2a:	19 f0       	breq	.+6      	; 0xb32 <__fpcmp_parts_f+0xa2>
     b2c:	61 e0       	ldi	r22, 0x01	; 1
     b2e:	70 e0       	ldi	r23, 0x00	; 0
     b30:	05 c0       	rjmp	.+10     	; 0xb3c <__fpcmp_parts_f+0xac>
     b32:	6f ef       	ldi	r22, 0xFF	; 255
     b34:	7f ef       	ldi	r23, 0xFF	; 255
     b36:	02 c0       	rjmp	.+4      	; 0xb3c <__fpcmp_parts_f+0xac>
     b38:	60 e0       	ldi	r22, 0x00	; 0
     b3a:	70 e0       	ldi	r23, 0x00	; 0
     b3c:	cb 01       	movw	r24, r22
     b3e:	1f 91       	pop	r17
     b40:	08 95       	ret

00000b42 <__vector_11>:

/* Global variables to hold the address of the call back function in the application */
static volatile void (*g_callBackPtr)(void) = NULL_PTR;

ISR (TIMER0_OVF_vect)
{
     b42:	1f 92       	push	r1
     b44:	0f 92       	push	r0
     b46:	0f b6       	in	r0, 0x3f	; 63
     b48:	0f 92       	push	r0
     b4a:	11 24       	eor	r1, r1
     b4c:	2f 93       	push	r18
     b4e:	3f 93       	push	r19
     b50:	4f 93       	push	r20
     b52:	5f 93       	push	r21
     b54:	6f 93       	push	r22
     b56:	7f 93       	push	r23
     b58:	8f 93       	push	r24
     b5a:	9f 93       	push	r25
     b5c:	af 93       	push	r26
     b5e:	bf 93       	push	r27
     b60:	ef 93       	push	r30
     b62:	ff 93       	push	r31
     b64:	df 93       	push	r29
     b66:	cf 93       	push	r28
     b68:	cd b7       	in	r28, 0x3d	; 61
     b6a:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
     b6c:	80 91 2c 01 	lds	r24, 0x012C
     b70:	90 91 2d 01 	lds	r25, 0x012D
     b74:	00 97       	sbiw	r24, 0x00	; 0
     b76:	29 f0       	breq	.+10     	; 0xb82 <__vector_11+0x40>
		{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
     b78:	e0 91 2c 01 	lds	r30, 0x012C
     b7c:	f0 91 2d 01 	lds	r31, 0x012D
     b80:	09 95       	icall
		}
}
     b82:	cf 91       	pop	r28
     b84:	df 91       	pop	r29
     b86:	ff 91       	pop	r31
     b88:	ef 91       	pop	r30
     b8a:	bf 91       	pop	r27
     b8c:	af 91       	pop	r26
     b8e:	9f 91       	pop	r25
     b90:	8f 91       	pop	r24
     b92:	7f 91       	pop	r23
     b94:	6f 91       	pop	r22
     b96:	5f 91       	pop	r21
     b98:	4f 91       	pop	r20
     b9a:	3f 91       	pop	r19
     b9c:	2f 91       	pop	r18
     b9e:	0f 90       	pop	r0
     ba0:	0f be       	out	0x3f, r0	; 63
     ba2:	0f 90       	pop	r0
     ba4:	1f 90       	pop	r1
     ba6:	18 95       	reti

00000ba8 <__vector_10>:

ISR (TIMER0_COMP_vect)
{
     ba8:	1f 92       	push	r1
     baa:	0f 92       	push	r0
     bac:	0f b6       	in	r0, 0x3f	; 63
     bae:	0f 92       	push	r0
     bb0:	11 24       	eor	r1, r1
     bb2:	2f 93       	push	r18
     bb4:	3f 93       	push	r19
     bb6:	4f 93       	push	r20
     bb8:	5f 93       	push	r21
     bba:	6f 93       	push	r22
     bbc:	7f 93       	push	r23
     bbe:	8f 93       	push	r24
     bc0:	9f 93       	push	r25
     bc2:	af 93       	push	r26
     bc4:	bf 93       	push	r27
     bc6:	ef 93       	push	r30
     bc8:	ff 93       	push	r31
     bca:	df 93       	push	r29
     bcc:	cf 93       	push	r28
     bce:	cd b7       	in	r28, 0x3d	; 61
     bd0:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
     bd2:	80 91 2c 01 	lds	r24, 0x012C
     bd6:	90 91 2d 01 	lds	r25, 0x012D
     bda:	00 97       	sbiw	r24, 0x00	; 0
     bdc:	29 f0       	breq	.+10     	; 0xbe8 <__vector_10+0x40>
		{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
     bde:	e0 91 2c 01 	lds	r30, 0x012C
     be2:	f0 91 2d 01 	lds	r31, 0x012D
     be6:	09 95       	icall
		}
}
     be8:	cf 91       	pop	r28
     bea:	df 91       	pop	r29
     bec:	ff 91       	pop	r31
     bee:	ef 91       	pop	r30
     bf0:	bf 91       	pop	r27
     bf2:	af 91       	pop	r26
     bf4:	9f 91       	pop	r25
     bf6:	8f 91       	pop	r24
     bf8:	7f 91       	pop	r23
     bfa:	6f 91       	pop	r22
     bfc:	5f 91       	pop	r21
     bfe:	4f 91       	pop	r20
     c00:	3f 91       	pop	r19
     c02:	2f 91       	pop	r18
     c04:	0f 90       	pop	r0
     c06:	0f be       	out	0x3f, r0	; 63
     c08:	0f 90       	pop	r0
     c0a:	1f 90       	pop	r1
     c0c:	18 95       	reti

00000c0e <Timer0_init>:

void Timer0_init(const Timer0_ConfigType *Config_ptr)
{
     c0e:	df 93       	push	r29
     c10:	cf 93       	push	r28
     c12:	00 d0       	rcall	.+0      	; 0xc14 <Timer0_init+0x6>
     c14:	cd b7       	in	r28, 0x3d	; 61
     c16:	de b7       	in	r29, 0x3e	; 62
     c18:	9a 83       	std	Y+2, r25	; 0x02
     c1a:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = Config_ptr->initialValue;
     c1c:	a2 e5       	ldi	r26, 0x52	; 82
     c1e:	b0 e0       	ldi	r27, 0x00	; 0
     c20:	e9 81       	ldd	r30, Y+1	; 0x01
     c22:	fa 81       	ldd	r31, Y+2	; 0x02
     c24:	82 81       	ldd	r24, Z+2	; 0x02
     c26:	8c 93       	st	X, r24
	if (Config_ptr->mode == NORMAL_MODE)
     c28:	e9 81       	ldd	r30, Y+1	; 0x01
     c2a:	fa 81       	ldd	r31, Y+2	; 0x02
     c2c:	80 81       	ld	r24, Z
     c2e:	88 23       	and	r24, r24
     c30:	d9 f4       	brne	.+54     	; 0xc68 <Timer0_init+0x5a>
	{
		TCCR0|=(1<<FOC0);
     c32:	a3 e5       	ldi	r26, 0x53	; 83
     c34:	b0 e0       	ldi	r27, 0x00	; 0
     c36:	e3 e5       	ldi	r30, 0x53	; 83
     c38:	f0 e0       	ldi	r31, 0x00	; 0
     c3a:	80 81       	ld	r24, Z
     c3c:	80 68       	ori	r24, 0x80	; 128
     c3e:	8c 93       	st	X, r24
		TIMSK|=(1<<TOIE0);
     c40:	a9 e5       	ldi	r26, 0x59	; 89
     c42:	b0 e0       	ldi	r27, 0x00	; 0
     c44:	e9 e5       	ldi	r30, 0x59	; 89
     c46:	f0 e0       	ldi	r31, 0x00	; 0
     c48:	80 81       	ld	r24, Z
     c4a:	81 60       	ori	r24, 0x01	; 1
     c4c:	8c 93       	st	X, r24
		TCCR0 = (TCCR0 & 0xF8) | (Config_ptr->clock);
     c4e:	a3 e5       	ldi	r26, 0x53	; 83
     c50:	b0 e0       	ldi	r27, 0x00	; 0
     c52:	e3 e5       	ldi	r30, 0x53	; 83
     c54:	f0 e0       	ldi	r31, 0x00	; 0
     c56:	80 81       	ld	r24, Z
     c58:	98 2f       	mov	r25, r24
     c5a:	98 7f       	andi	r25, 0xF8	; 248
     c5c:	e9 81       	ldd	r30, Y+1	; 0x01
     c5e:	fa 81       	ldd	r31, Y+2	; 0x02
     c60:	81 81       	ldd	r24, Z+1	; 0x01
     c62:	89 2b       	or	r24, r25
     c64:	8c 93       	st	X, r24
     c66:	25 c0       	rjmp	.+74     	; 0xcb2 <Timer0_init+0xa4>
	}
	else if (Config_ptr->mode == COMPARE_MODE)
     c68:	e9 81       	ldd	r30, Y+1	; 0x01
     c6a:	fa 81       	ldd	r31, Y+2	; 0x02
     c6c:	80 81       	ld	r24, Z
     c6e:	82 30       	cpi	r24, 0x02	; 2
     c70:	01 f5       	brne	.+64     	; 0xcb2 <Timer0_init+0xa4>
	{
		TCCR0 |= (1 << FOC0);
     c72:	a3 e5       	ldi	r26, 0x53	; 83
     c74:	b0 e0       	ldi	r27, 0x00	; 0
     c76:	e3 e5       	ldi	r30, 0x53	; 83
     c78:	f0 e0       	ldi	r31, 0x00	; 0
     c7a:	80 81       	ld	r24, Z
     c7c:	80 68       	ori	r24, 0x80	; 128
     c7e:	8c 93       	st	X, r24
//		TCCR0 |= (1 << WGM01);
		TIMSK |= (1 << OCIE0);
     c80:	a9 e5       	ldi	r26, 0x59	; 89
     c82:	b0 e0       	ldi	r27, 0x00	; 0
     c84:	e9 e5       	ldi	r30, 0x59	; 89
     c86:	f0 e0       	ldi	r31, 0x00	; 0
     c88:	80 81       	ld	r24, Z
     c8a:	82 60       	ori	r24, 0x02	; 2
     c8c:	8c 93       	st	X, r24
		OCR0 = Config_ptr->compareValue;
     c8e:	ac e5       	ldi	r26, 0x5C	; 92
     c90:	b0 e0       	ldi	r27, 0x00	; 0
     c92:	e9 81       	ldd	r30, Y+1	; 0x01
     c94:	fa 81       	ldd	r31, Y+2	; 0x02
     c96:	83 81       	ldd	r24, Z+3	; 0x03
     c98:	8c 93       	st	X, r24
		TCCR0 = (TCCR0 & 0xF8) | (Config_ptr->clock);
     c9a:	a3 e5       	ldi	r26, 0x53	; 83
     c9c:	b0 e0       	ldi	r27, 0x00	; 0
     c9e:	e3 e5       	ldi	r30, 0x53	; 83
     ca0:	f0 e0       	ldi	r31, 0x00	; 0
     ca2:	80 81       	ld	r24, Z
     ca4:	98 2f       	mov	r25, r24
     ca6:	98 7f       	andi	r25, 0xF8	; 248
     ca8:	e9 81       	ldd	r30, Y+1	; 0x01
     caa:	fa 81       	ldd	r31, Y+2	; 0x02
     cac:	81 81       	ldd	r24, Z+1	; 0x01
     cae:	89 2b       	or	r24, r25
     cb0:	8c 93       	st	X, r24
	}
}
     cb2:	0f 90       	pop	r0
     cb4:	0f 90       	pop	r0
     cb6:	cf 91       	pop	r28
     cb8:	df 91       	pop	r29
     cba:	08 95       	ret

00000cbc <Timer0_setCallBack>:

void Timer0_setCallBack( void(*a_ptr)(void) )
{
     cbc:	df 93       	push	r29
     cbe:	cf 93       	push	r28
     cc0:	00 d0       	rcall	.+0      	; 0xcc2 <Timer0_setCallBack+0x6>
     cc2:	cd b7       	in	r28, 0x3d	; 61
     cc4:	de b7       	in	r29, 0x3e	; 62
     cc6:	9a 83       	std	Y+2, r25	; 0x02
     cc8:	89 83       	std	Y+1, r24	; 0x01
	g_callBackPtr=a_ptr;
     cca:	89 81       	ldd	r24, Y+1	; 0x01
     ccc:	9a 81       	ldd	r25, Y+2	; 0x02
     cce:	90 93 2d 01 	sts	0x012D, r25
     cd2:	80 93 2c 01 	sts	0x012C, r24
}
     cd6:	0f 90       	pop	r0
     cd8:	0f 90       	pop	r0
     cda:	cf 91       	pop	r28
     cdc:	df 91       	pop	r29
     cde:	08 95       	ret

00000ce0 <Timer0_DeInit>:

void Timer0_DeInit(void)
{
     ce0:	df 93       	push	r29
     ce2:	cf 93       	push	r28
     ce4:	cd b7       	in	r28, 0x3d	; 61
     ce6:	de b7       	in	r29, 0x3e	; 62
	TCCR0=0;
     ce8:	e3 e5       	ldi	r30, 0x53	; 83
     cea:	f0 e0       	ldi	r31, 0x00	; 0
     cec:	10 82       	st	Z, r1
	TIMSK=0;
     cee:	e9 e5       	ldi	r30, 0x59	; 89
     cf0:	f0 e0       	ldi	r31, 0x00	; 0
     cf2:	10 82       	st	Z, r1
//	g_callBackPtr=NULL_PTR;
}
     cf4:	cf 91       	pop	r28
     cf6:	df 91       	pop	r29
     cf8:	08 95       	ret

00000cfa <EnableInterrupt>:

void EnableInterrupt(void){}
     cfa:	df 93       	push	r29
     cfc:	cf 93       	push	r28
     cfe:	cd b7       	in	r28, 0x3d	; 61
     d00:	de b7       	in	r29, 0x3e	; 62
     d02:	cf 91       	pop	r28
     d04:	df 91       	pop	r29
     d06:	08 95       	ret

00000d08 <DisableInterrupt>:


void DisableInterrupt(void){}
     d08:	df 93       	push	r29
     d0a:	cf 93       	push	r28
     d0c:	cd b7       	in	r28, 0x3d	; 61
     d0e:	de b7       	in	r29, 0x3e	; 62
     d10:	cf 91       	pop	r28
     d12:	df 91       	pop	r29
     d14:	08 95       	ret

00000d16 <SPI_initMaster>:
/*
 * Description :
 * Initialize the SPI device as Master.
 */
void SPI_initMaster(void) 
{
     d16:	df 93       	push	r29
     d18:	cf 93       	push	r28
     d1a:	cd b7       	in	r28, 0x3d	; 61
     d1c:	de b7       	in	r29, 0x3e	; 62
	 * SS(PB4)   --> Output
	 * MOSI(PB5) --> Output 
	 * MISO(PB6) --> Input
	 * SCK(PB7) --> Output
	 ********************************************/
	GPIO_setupPinDirection(PORTB_ID,PIN4_ID,PIN_OUTPUT);
     d1e:	81 e0       	ldi	r24, 0x01	; 1
     d20:	64 e0       	ldi	r22, 0x04	; 4
     d22:	41 e0       	ldi	r20, 0x01	; 1
     d24:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN5_ID,PIN_OUTPUT);
     d28:	81 e0       	ldi	r24, 0x01	; 1
     d2a:	65 e0       	ldi	r22, 0x05	; 5
     d2c:	41 e0       	ldi	r20, 0x01	; 1
     d2e:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN6_ID,PIN_INPUT);
     d32:	81 e0       	ldi	r24, 0x01	; 1
     d34:	66 e0       	ldi	r22, 0x06	; 6
     d36:	40 e0       	ldi	r20, 0x00	; 0
     d38:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN7_ID,PIN_OUTPUT);
     d3c:	81 e0       	ldi	r24, 0x01	; 1
     d3e:	67 e0       	ldi	r22, 0x07	; 7
     d40:	41 e0       	ldi	r20, 0x01	; 1
     d42:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
     * MSTR    = 1 Enable Master
     * CPOL    = 0 SCK is low when idle
     * CPHA    = 0 Sample Data with the raising edge
     * SPR1:0  = 00 Choose SPI clock = Fosc/4
     ***********************************************************************/
	SPCR = (1<<SPE) | (1<<MSTR)| (1<<CPHA);
     d46:	ed e2       	ldi	r30, 0x2D	; 45
     d48:	f0 e0       	ldi	r31, 0x00	; 0
     d4a:	84 e5       	ldi	r24, 0x54	; 84
     d4c:	80 83       	st	Z, r24

	/* Clear the SPI2X bit in SPSR to Choose SPI clock = Fosc/4 */
	SPSR &= ~(1<<SPI2X);
     d4e:	ae e2       	ldi	r26, 0x2E	; 46
     d50:	b0 e0       	ldi	r27, 0x00	; 0
     d52:	ee e2       	ldi	r30, 0x2E	; 46
     d54:	f0 e0       	ldi	r31, 0x00	; 0
     d56:	80 81       	ld	r24, Z
     d58:	8e 7f       	andi	r24, 0xFE	; 254
     d5a:	8c 93       	st	X, r24
}
     d5c:	cf 91       	pop	r28
     d5e:	df 91       	pop	r29
     d60:	08 95       	ret

00000d62 <SPI_initSlave>:
/*
 * Description :
 * Initialize the SPI device as Slave.
 */
void SPI_initSlave(void)
{ 
     d62:	df 93       	push	r29
     d64:	cf 93       	push	r28
     d66:	cd b7       	in	r28, 0x3d	; 61
     d68:	de b7       	in	r29, 0x3e	; 62
	 * SS(PB4)   --> Input
	 * MOSI(PB5) --> Input
	 * MISO(PB6) --> Output
	 * SCK(PB7) --> Input
	 ********************************************/
	GPIO_setupPinDirection(PORTB_ID,PIN4_ID,PIN_INPUT);
     d6a:	81 e0       	ldi	r24, 0x01	; 1
     d6c:	64 e0       	ldi	r22, 0x04	; 4
     d6e:	40 e0       	ldi	r20, 0x00	; 0
     d70:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN5_ID,PIN_INPUT);
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	65 e0       	ldi	r22, 0x05	; 5
     d78:	40 e0       	ldi	r20, 0x00	; 0
     d7a:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN6_ID,PIN_OUTPUT);
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	66 e0       	ldi	r22, 0x06	; 6
     d82:	41 e0       	ldi	r20, 0x01	; 1
     d84:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	GPIO_setupPinDirection(PORTB_ID,PIN7_ID,PIN_INPUT);
     d88:	81 e0       	ldi	r24, 0x01	; 1
     d8a:	67 e0       	ldi	r22, 0x07	; 7
     d8c:	40 e0       	ldi	r20, 0x00	; 0
     d8e:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>
	 * MSTR    = 0 Disable Master
	 * CPOL    = 0 SCK is low when idle
	 * CPHA    = 0 Sample Data with the raising edge
	 * SPR1:0  = 00 Choose SPI clock = Fosc/4
	 ***********************************************************************/
	SPCR = (1<<SPE);
     d92:	ed e2       	ldi	r30, 0x2D	; 45
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	80 e4       	ldi	r24, 0x40	; 64
     d98:	80 83       	st	Z, r24

	/* Clear the SPI2X bit in SPSR to Choose SPI clock = Fosc/4 */
	SPSR &= ~(1<<SPI2X);
     d9a:	ae e2       	ldi	r26, 0x2E	; 46
     d9c:	b0 e0       	ldi	r27, 0x00	; 0
     d9e:	ee e2       	ldi	r30, 0x2E	; 46
     da0:	f0 e0       	ldi	r31, 0x00	; 0
     da2:	80 81       	ld	r24, Z
     da4:	8e 7f       	andi	r24, 0xFE	; 254
     da6:	8c 93       	st	X, r24
}
     da8:	cf 91       	pop	r28
     daa:	df 91       	pop	r29
     dac:	08 95       	ret

00000dae <SPI_sendReceiveByte>:
 * Description :
 * Send the required data through SPI to the other SPI device.
 * In the same time data will be received from the other device.
 */
uint8 SPI_sendReceiveByte(uint8 data)
{
     dae:	df 93       	push	r29
     db0:	cf 93       	push	r28
     db2:	0f 92       	push	r0
     db4:	cd b7       	in	r28, 0x3d	; 61
     db6:	de b7       	in	r29, 0x3e	; 62
     db8:	89 83       	std	Y+1, r24	; 0x01
	/* Initiate the communication and send data by SPI */
	SPDR = data;
     dba:	ef e2       	ldi	r30, 0x2F	; 47
     dbc:	f0 e0       	ldi	r31, 0x00	; 0
     dbe:	89 81       	ldd	r24, Y+1	; 0x01
     dc0:	80 83       	st	Z, r24

	/* Wait until SPI interrupt flag SPIF = 1 (data has been sent/received correctly) */
	while(BIT_IS_CLEAR(SPSR,SPIF)){}
     dc2:	ee e2       	ldi	r30, 0x2E	; 46
     dc4:	f0 e0       	ldi	r31, 0x00	; 0
     dc6:	80 81       	ld	r24, Z
     dc8:	88 23       	and	r24, r24
     dca:	dc f7       	brge	.-10     	; 0xdc2 <SPI_sendReceiveByte+0x14>

	/*
	 * Note: SPIF flag is cleared by first reading SPSR (with SPIF set) which is done in the previous step.
	 * and then accessing SPDR like the below line.
	 */
	return SPDR;
     dcc:	ef e2       	ldi	r30, 0x2F	; 47
     dce:	f0 e0       	ldi	r31, 0x00	; 0
     dd0:	80 81       	ld	r24, Z
}
     dd2:	0f 90       	pop	r0
     dd4:	cf 91       	pop	r28
     dd6:	df 91       	pop	r29
     dd8:	08 95       	ret

00000dda <SPI_sendString>:
/*
 * Description :
 * Send the required string through SPI to the other SPI device.
 */
void SPI_sendString(const uint8 *str)
{
     dda:	df 93       	push	r29
     ddc:	cf 93       	push	r28
     dde:	00 d0       	rcall	.+0      	; 0xde0 <SPI_sendString+0x6>
     de0:	00 d0       	rcall	.+0      	; 0xde2 <SPI_sendString+0x8>
     de2:	cd b7       	in	r28, 0x3d	; 61
     de4:	de b7       	in	r29, 0x3e	; 62
     de6:	9c 83       	std	Y+4, r25	; 0x04
     de8:	8b 83       	std	Y+3, r24	; 0x03
	uint8 i = 0;
     dea:	1a 82       	std	Y+2, r1	; 0x02
	uint8 received_data = 0;
     dec:	19 82       	std	Y+1, r1	; 0x01
     dee:	0f c0       	rjmp	.+30     	; 0xe0e <SPI_sendString+0x34>
	{
		/*
		 * received_data contains the received data from the other device.
		 * It is a dummy data variable as we just need to send the string to other device.
		 */
		received_data = SPI_sendReceiveByte(str[i]);
     df0:	8a 81       	ldd	r24, Y+2	; 0x02
     df2:	28 2f       	mov	r18, r24
     df4:	30 e0       	ldi	r19, 0x00	; 0
     df6:	8b 81       	ldd	r24, Y+3	; 0x03
     df8:	9c 81       	ldd	r25, Y+4	; 0x04
     dfa:	fc 01       	movw	r30, r24
     dfc:	e2 0f       	add	r30, r18
     dfe:	f3 1f       	adc	r31, r19
     e00:	80 81       	ld	r24, Z
     e02:	0e 94 d7 06 	call	0xdae	; 0xdae <SPI_sendReceiveByte>
     e06:	89 83       	std	Y+1, r24	; 0x01
		i++;
     e08:	8a 81       	ldd	r24, Y+2	; 0x02
     e0a:	8f 5f       	subi	r24, 0xFF	; 255
     e0c:	8a 83       	std	Y+2, r24	; 0x02
{
	uint8 i = 0;
	uint8 received_data = 0;

	/* Send the whole string */
	while(str[i] != '\0')
     e0e:	8a 81       	ldd	r24, Y+2	; 0x02
     e10:	28 2f       	mov	r18, r24
     e12:	30 e0       	ldi	r19, 0x00	; 0
     e14:	8b 81       	ldd	r24, Y+3	; 0x03
     e16:	9c 81       	ldd	r25, Y+4	; 0x04
     e18:	fc 01       	movw	r30, r24
     e1a:	e2 0f       	add	r30, r18
     e1c:	f3 1f       	adc	r31, r19
     e1e:	80 81       	ld	r24, Z
     e20:	88 23       	and	r24, r24
     e22:	31 f7       	brne	.-52     	; 0xdf0 <SPI_sendString+0x16>
		 * It is a dummy data variable as we just need to send the string to other device.
		 */
		received_data = SPI_sendReceiveByte(str[i]);
		i++;
	}
}
     e24:	0f 90       	pop	r0
     e26:	0f 90       	pop	r0
     e28:	0f 90       	pop	r0
     e2a:	0f 90       	pop	r0
     e2c:	cf 91       	pop	r28
     e2e:	df 91       	pop	r29
     e30:	08 95       	ret

00000e32 <SPI_receiveString>:
/*
 * Description :
 * Receive the required string until the '#' symbol through SPI from the other SPI device.
 */
void SPI_receiveString(uint8 *str)
{
     e32:	0f 93       	push	r16
     e34:	1f 93       	push	r17
     e36:	df 93       	push	r29
     e38:	cf 93       	push	r28
     e3a:	00 d0       	rcall	.+0      	; 0xe3c <SPI_receiveString+0xa>
     e3c:	0f 92       	push	r0
     e3e:	cd b7       	in	r28, 0x3d	; 61
     e40:	de b7       	in	r29, 0x3e	; 62
     e42:	9b 83       	std	Y+3, r25	; 0x03
     e44:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
     e46:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);
     e48:	89 81       	ldd	r24, Y+1	; 0x01
     e4a:	28 2f       	mov	r18, r24
     e4c:	30 e0       	ldi	r19, 0x00	; 0
     e4e:	8a 81       	ldd	r24, Y+2	; 0x02
     e50:	9b 81       	ldd	r25, Y+3	; 0x03
     e52:	8c 01       	movw	r16, r24
     e54:	02 0f       	add	r16, r18
     e56:	13 1f       	adc	r17, r19
     e58:	8f ef       	ldi	r24, 0xFF	; 255
     e5a:	0e 94 d7 06 	call	0xdae	; 0xdae <SPI_sendReceiveByte>
     e5e:	f8 01       	movw	r30, r16
     e60:	80 83       	st	Z, r24
     e62:	10 c0       	rjmp	.+32     	; 0xe84 <SPI_receiveString+0x52>

	/* Receive the whole string until the '#' */
	while(str[i] != '#')
	{
		i++;
     e64:	89 81       	ldd	r24, Y+1	; 0x01
     e66:	8f 5f       	subi	r24, 0xFF	; 255
     e68:	89 83       	std	Y+1, r24	; 0x01
		str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);
     e6a:	89 81       	ldd	r24, Y+1	; 0x01
     e6c:	28 2f       	mov	r18, r24
     e6e:	30 e0       	ldi	r19, 0x00	; 0
     e70:	8a 81       	ldd	r24, Y+2	; 0x02
     e72:	9b 81       	ldd	r25, Y+3	; 0x03
     e74:	8c 01       	movw	r16, r24
     e76:	02 0f       	add	r16, r18
     e78:	13 1f       	adc	r17, r19
     e7a:	8f ef       	ldi	r24, 0xFF	; 255
     e7c:	0e 94 d7 06 	call	0xdae	; 0xdae <SPI_sendReceiveByte>
     e80:	f8 01       	movw	r30, r16
     e82:	80 83       	st	Z, r24

	/* Receive the first byte */
	str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);

	/* Receive the whole string until the '#' */
	while(str[i] != '#')
     e84:	89 81       	ldd	r24, Y+1	; 0x01
     e86:	28 2f       	mov	r18, r24
     e88:	30 e0       	ldi	r19, 0x00	; 0
     e8a:	8a 81       	ldd	r24, Y+2	; 0x02
     e8c:	9b 81       	ldd	r25, Y+3	; 0x03
     e8e:	fc 01       	movw	r30, r24
     e90:	e2 0f       	add	r30, r18
     e92:	f3 1f       	adc	r31, r19
     e94:	80 81       	ld	r24, Z
     e96:	83 32       	cpi	r24, 0x23	; 35
     e98:	29 f7       	brne	.-54     	; 0xe64 <SPI_receiveString+0x32>
		i++;
		str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	str[i] = '\0';
     e9a:	89 81       	ldd	r24, Y+1	; 0x01
     e9c:	28 2f       	mov	r18, r24
     e9e:	30 e0       	ldi	r19, 0x00	; 0
     ea0:	8a 81       	ldd	r24, Y+2	; 0x02
     ea2:	9b 81       	ldd	r25, Y+3	; 0x03
     ea4:	fc 01       	movw	r30, r24
     ea6:	e2 0f       	add	r30, r18
     ea8:	f3 1f       	adc	r31, r19
     eaa:	10 82       	st	Z, r1
}
     eac:	0f 90       	pop	r0
     eae:	0f 90       	pop	r0
     eb0:	0f 90       	pop	r0
     eb2:	cf 91       	pop	r28
     eb4:	df 91       	pop	r29
     eb6:	1f 91       	pop	r17
     eb8:	0f 91       	pop	r16
     eba:	08 95       	ret

00000ebc <GPIO_Init>:
 * Description :
 * configure every pin in the gpio.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_Init(const GPIO_ConfigType GPIO_ConfigPtr[])
{
     ebc:	df 93       	push	r29
     ebe:	cf 93       	push	r28
     ec0:	00 d0       	rcall	.+0      	; 0xec2 <GPIO_Init+0x6>
     ec2:	0f 92       	push	r0
     ec4:	cd b7       	in	r28, 0x3d	; 61
     ec6:	de b7       	in	r29, 0x3e	; 62
     ec8:	9b 83       	std	Y+3, r25	; 0x03
     eca:	8a 83       	std	Y+2, r24	; 0x02
    uint8 i = 0;
     ecc:	19 82       	std	Y+1, r1	; 0x01
     ece:	ca c0       	rjmp	.+404    	; 0x1064 <GPIO_Init+0x1a8>
    for (; i < TOTAL_PINS_NUM; ++i)
    {
	if(((GPIO_ConfigPtr[i].pin_num) >= NUM_OF_PINS_PER_PORT) || ((GPIO_ConfigPtr[i].port_num )>= NUM_OF_PORTS) )
     ed0:	89 81       	ldd	r24, Y+1	; 0x01
     ed2:	28 2f       	mov	r18, r24
     ed4:	30 e0       	ldi	r19, 0x00	; 0
     ed6:	c9 01       	movw	r24, r18
     ed8:	88 0f       	add	r24, r24
     eda:	99 1f       	adc	r25, r25
     edc:	88 0f       	add	r24, r24
     ede:	99 1f       	adc	r25, r25
     ee0:	28 0f       	add	r18, r24
     ee2:	39 1f       	adc	r19, r25
     ee4:	8a 81       	ldd	r24, Y+2	; 0x02
     ee6:	9b 81       	ldd	r25, Y+3	; 0x03
     ee8:	fc 01       	movw	r30, r24
     eea:	e2 0f       	add	r30, r18
     eec:	f3 1f       	adc	r31, r19
     eee:	81 81       	ldd	r24, Z+1	; 0x01
     ef0:	88 30       	cpi	r24, 0x08	; 8
     ef2:	08 f0       	brcs	.+2      	; 0xef6 <GPIO_Init+0x3a>
     ef4:	b4 c0       	rjmp	.+360    	; 0x105e <GPIO_Init+0x1a2>
     ef6:	89 81       	ldd	r24, Y+1	; 0x01
     ef8:	28 2f       	mov	r18, r24
     efa:	30 e0       	ldi	r19, 0x00	; 0
     efc:	c9 01       	movw	r24, r18
     efe:	88 0f       	add	r24, r24
     f00:	99 1f       	adc	r25, r25
     f02:	88 0f       	add	r24, r24
     f04:	99 1f       	adc	r25, r25
     f06:	28 0f       	add	r18, r24
     f08:	39 1f       	adc	r19, r25
     f0a:	8a 81       	ldd	r24, Y+2	; 0x02
     f0c:	9b 81       	ldd	r25, Y+3	; 0x03
     f0e:	fc 01       	movw	r30, r24
     f10:	e2 0f       	add	r30, r18
     f12:	f3 1f       	adc	r31, r19
     f14:	80 81       	ld	r24, Z
     f16:	84 30       	cpi	r24, 0x04	; 4
     f18:	08 f0       	brcs	.+2      	; 0xf1c <GPIO_Init+0x60>
     f1a:	a1 c0       	rjmp	.+322    	; 0x105e <GPIO_Init+0x1a2>
		/* Do Nothing */
	}
	else
	{

		GPIO_setupPinDirection(GPIO_ConfigPtr[i].port_num, GPIO_ConfigPtr[i].pin_num, GPIO_ConfigPtr[i].direction);
     f1c:	89 81       	ldd	r24, Y+1	; 0x01
     f1e:	28 2f       	mov	r18, r24
     f20:	30 e0       	ldi	r19, 0x00	; 0
     f22:	c9 01       	movw	r24, r18
     f24:	88 0f       	add	r24, r24
     f26:	99 1f       	adc	r25, r25
     f28:	88 0f       	add	r24, r24
     f2a:	99 1f       	adc	r25, r25
     f2c:	28 0f       	add	r18, r24
     f2e:	39 1f       	adc	r19, r25
     f30:	8a 81       	ldd	r24, Y+2	; 0x02
     f32:	9b 81       	ldd	r25, Y+3	; 0x03
     f34:	fc 01       	movw	r30, r24
     f36:	e2 0f       	add	r30, r18
     f38:	f3 1f       	adc	r31, r19
     f3a:	50 81       	ld	r21, Z
     f3c:	89 81       	ldd	r24, Y+1	; 0x01
     f3e:	28 2f       	mov	r18, r24
     f40:	30 e0       	ldi	r19, 0x00	; 0
     f42:	c9 01       	movw	r24, r18
     f44:	88 0f       	add	r24, r24
     f46:	99 1f       	adc	r25, r25
     f48:	88 0f       	add	r24, r24
     f4a:	99 1f       	adc	r25, r25
     f4c:	28 0f       	add	r18, r24
     f4e:	39 1f       	adc	r19, r25
     f50:	8a 81       	ldd	r24, Y+2	; 0x02
     f52:	9b 81       	ldd	r25, Y+3	; 0x03
     f54:	fc 01       	movw	r30, r24
     f56:	e2 0f       	add	r30, r18
     f58:	f3 1f       	adc	r31, r19
     f5a:	41 81       	ldd	r20, Z+1	; 0x01
     f5c:	89 81       	ldd	r24, Y+1	; 0x01
     f5e:	28 2f       	mov	r18, r24
     f60:	30 e0       	ldi	r19, 0x00	; 0
     f62:	c9 01       	movw	r24, r18
     f64:	88 0f       	add	r24, r24
     f66:	99 1f       	adc	r25, r25
     f68:	88 0f       	add	r24, r24
     f6a:	99 1f       	adc	r25, r25
     f6c:	28 0f       	add	r18, r24
     f6e:	39 1f       	adc	r19, r25
     f70:	8a 81       	ldd	r24, Y+2	; 0x02
     f72:	9b 81       	ldd	r25, Y+3	; 0x03
     f74:	fc 01       	movw	r30, r24
     f76:	e2 0f       	add	r30, r18
     f78:	f3 1f       	adc	r31, r19
     f7a:	92 81       	ldd	r25, Z+2	; 0x02
     f7c:	85 2f       	mov	r24, r21
     f7e:	64 2f       	mov	r22, r20
     f80:	49 2f       	mov	r20, r25
     f82:	0e 94 16 0a 	call	0x142c	; 0x142c <GPIO_setupPinDirection>

		GPIO_writePin(GPIO_ConfigPtr[i].port_num, GPIO_ConfigPtr[i].pin_num, GPIO_ConfigPtr[i].initial_value);
     f86:	89 81       	ldd	r24, Y+1	; 0x01
     f88:	28 2f       	mov	r18, r24
     f8a:	30 e0       	ldi	r19, 0x00	; 0
     f8c:	c9 01       	movw	r24, r18
     f8e:	88 0f       	add	r24, r24
     f90:	99 1f       	adc	r25, r25
     f92:	88 0f       	add	r24, r24
     f94:	99 1f       	adc	r25, r25
     f96:	28 0f       	add	r18, r24
     f98:	39 1f       	adc	r19, r25
     f9a:	8a 81       	ldd	r24, Y+2	; 0x02
     f9c:	9b 81       	ldd	r25, Y+3	; 0x03
     f9e:	fc 01       	movw	r30, r24
     fa0:	e2 0f       	add	r30, r18
     fa2:	f3 1f       	adc	r31, r19
     fa4:	50 81       	ld	r21, Z
     fa6:	89 81       	ldd	r24, Y+1	; 0x01
     fa8:	28 2f       	mov	r18, r24
     faa:	30 e0       	ldi	r19, 0x00	; 0
     fac:	c9 01       	movw	r24, r18
     fae:	88 0f       	add	r24, r24
     fb0:	99 1f       	adc	r25, r25
     fb2:	88 0f       	add	r24, r24
     fb4:	99 1f       	adc	r25, r25
     fb6:	28 0f       	add	r18, r24
     fb8:	39 1f       	adc	r19, r25
     fba:	8a 81       	ldd	r24, Y+2	; 0x02
     fbc:	9b 81       	ldd	r25, Y+3	; 0x03
     fbe:	fc 01       	movw	r30, r24
     fc0:	e2 0f       	add	r30, r18
     fc2:	f3 1f       	adc	r31, r19
     fc4:	41 81       	ldd	r20, Z+1	; 0x01
     fc6:	89 81       	ldd	r24, Y+1	; 0x01
     fc8:	28 2f       	mov	r18, r24
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	c9 01       	movw	r24, r18
     fce:	88 0f       	add	r24, r24
     fd0:	99 1f       	adc	r25, r25
     fd2:	88 0f       	add	r24, r24
     fd4:	99 1f       	adc	r25, r25
     fd6:	28 0f       	add	r18, r24
     fd8:	39 1f       	adc	r19, r25
     fda:	8a 81       	ldd	r24, Y+2	; 0x02
     fdc:	9b 81       	ldd	r25, Y+3	; 0x03
     fde:	fc 01       	movw	r30, r24
     fe0:	e2 0f       	add	r30, r18
     fe2:	f3 1f       	adc	r31, r19
     fe4:	94 81       	ldd	r25, Z+4	; 0x04
     fe6:	85 2f       	mov	r24, r21
     fe8:	64 2f       	mov	r22, r20
     fea:	49 2f       	mov	r20, r25
     fec:	0e 94 01 0b 	call	0x1602	; 0x1602 <GPIO_writePin>


		if(GPIO_ConfigPtr[i].resistor == GPIO_PULL_UP)
     ff0:	89 81       	ldd	r24, Y+1	; 0x01
     ff2:	28 2f       	mov	r18, r24
     ff4:	30 e0       	ldi	r19, 0x00	; 0
     ff6:	c9 01       	movw	r24, r18
     ff8:	88 0f       	add	r24, r24
     ffa:	99 1f       	adc	r25, r25
     ffc:	88 0f       	add	r24, r24
     ffe:	99 1f       	adc	r25, r25
    1000:	28 0f       	add	r18, r24
    1002:	39 1f       	adc	r19, r25
    1004:	8a 81       	ldd	r24, Y+2	; 0x02
    1006:	9b 81       	ldd	r25, Y+3	; 0x03
    1008:	fc 01       	movw	r30, r24
    100a:	e2 0f       	add	r30, r18
    100c:	f3 1f       	adc	r31, r19
    100e:	83 81       	ldd	r24, Z+3	; 0x03
    1010:	81 30       	cpi	r24, 0x01	; 1
    1012:	29 f5       	brne	.+74     	; 0x105e <GPIO_Init+0x1a2>
		{
			GPIO_writePin(GPIO_ConfigPtr[i].port_num, GPIO_ConfigPtr[i].pin_num,LOGIC_HIGH);
    1014:	89 81       	ldd	r24, Y+1	; 0x01
    1016:	28 2f       	mov	r18, r24
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	c9 01       	movw	r24, r18
    101c:	88 0f       	add	r24, r24
    101e:	99 1f       	adc	r25, r25
    1020:	88 0f       	add	r24, r24
    1022:	99 1f       	adc	r25, r25
    1024:	28 0f       	add	r18, r24
    1026:	39 1f       	adc	r19, r25
    1028:	8a 81       	ldd	r24, Y+2	; 0x02
    102a:	9b 81       	ldd	r25, Y+3	; 0x03
    102c:	fc 01       	movw	r30, r24
    102e:	e2 0f       	add	r30, r18
    1030:	f3 1f       	adc	r31, r19
    1032:	40 81       	ld	r20, Z
    1034:	89 81       	ldd	r24, Y+1	; 0x01
    1036:	28 2f       	mov	r18, r24
    1038:	30 e0       	ldi	r19, 0x00	; 0
    103a:	c9 01       	movw	r24, r18
    103c:	88 0f       	add	r24, r24
    103e:	99 1f       	adc	r25, r25
    1040:	88 0f       	add	r24, r24
    1042:	99 1f       	adc	r25, r25
    1044:	28 0f       	add	r18, r24
    1046:	39 1f       	adc	r19, r25
    1048:	8a 81       	ldd	r24, Y+2	; 0x02
    104a:	9b 81       	ldd	r25, Y+3	; 0x03
    104c:	fc 01       	movw	r30, r24
    104e:	e2 0f       	add	r30, r18
    1050:	f3 1f       	adc	r31, r19
    1052:	91 81       	ldd	r25, Z+1	; 0x01
    1054:	84 2f       	mov	r24, r20
    1056:	69 2f       	mov	r22, r25
    1058:	41 e0       	ldi	r20, 0x01	; 1
    105a:	0e 94 01 0b 	call	0x1602	; 0x1602 <GPIO_writePin>
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_Init(const GPIO_ConfigType GPIO_ConfigPtr[])
{
    uint8 i = 0;
    for (; i < TOTAL_PINS_NUM; ++i)
    105e:	89 81       	ldd	r24, Y+1	; 0x01
    1060:	8f 5f       	subi	r24, 0xFF	; 255
    1062:	89 83       	std	Y+1, r24	; 0x01
    1064:	89 81       	ldd	r24, Y+1	; 0x01
    1066:	80 32       	cpi	r24, 0x20	; 32
    1068:	08 f4       	brcc	.+2      	; 0x106c <GPIO_Init+0x1b0>
    106a:	32 cf       	rjmp	.-412    	; 0xed0 <GPIO_Init+0x14>
		{

		}
	}
}
}
    106c:	0f 90       	pop	r0
    106e:	0f 90       	pop	r0
    1070:	0f 90       	pop	r0
    1072:	cf 91       	pop	r28
    1074:	df 91       	pop	r29
    1076:	08 95       	ret

00001078 <GPIO_ChannelGroupWrite>:
/*
 *  Description :
 *  write in a group of of pin
 */
void GPIO_ChannelGroupWrite(ChannelGroupType* ChannelID ,uint8 dataPtr[]){
    1078:	df 93       	push	r29
    107a:	cf 93       	push	r28
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	28 97       	sbiw	r28, 0x08	; 8
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	9e 83       	std	Y+6, r25	; 0x06
    108e:	8d 83       	std	Y+5, r24	; 0x05
    1090:	78 87       	std	Y+8, r23	; 0x08
    1092:	6f 83       	std	Y+7, r22	; 0x07
    uint8 i = 0;
    1094:	1c 82       	std	Y+4, r1	; 0x04
    uint8 id=0;
    1096:	1b 82       	std	Y+3, r1	; 0x03
    uint8 port_num=0;
    1098:	1a 82       	std	Y+2, r1	; 0x02
    uint8 pin_num=0;
    109a:	19 82       	std	Y+1, r1	; 0x01
    109c:	40 c0       	rjmp	.+128    	; 0x111e <GPIO_ChannelGroupWrite+0xa6>
	for(; i < ChannelID->no_of_channels; ++i)
	{
	    id= ChannelID->group_ids[i];
    109e:	8c 81       	ldd	r24, Y+4	; 0x04
    10a0:	28 2f       	mov	r18, r24
    10a2:	30 e0       	ldi	r19, 0x00	; 0
    10a4:	8d 81       	ldd	r24, Y+5	; 0x05
    10a6:	9e 81       	ldd	r25, Y+6	; 0x06
    10a8:	82 0f       	add	r24, r18
    10aa:	93 1f       	adc	r25, r19
    10ac:	fc 01       	movw	r30, r24
    10ae:	31 96       	adiw	r30, 0x01	; 1
    10b0:	80 81       	ld	r24, Z
    10b2:	8b 83       	std	Y+3, r24	; 0x03
	    port_num = GPIO_ConfigPin[id].port_num;
    10b4:	8b 81       	ldd	r24, Y+3	; 0x03
    10b6:	28 2f       	mov	r18, r24
    10b8:	30 e0       	ldi	r19, 0x00	; 0
    10ba:	c9 01       	movw	r24, r18
    10bc:	88 0f       	add	r24, r24
    10be:	99 1f       	adc	r25, r25
    10c0:	88 0f       	add	r24, r24
    10c2:	99 1f       	adc	r25, r25
    10c4:	82 0f       	add	r24, r18
    10c6:	93 1f       	adc	r25, r19
    10c8:	fc 01       	movw	r30, r24
    10ca:	e5 57       	subi	r30, 0x75	; 117
    10cc:	ff 4f       	sbci	r31, 0xFF	; 255
    10ce:	80 81       	ld	r24, Z
    10d0:	8a 83       	std	Y+2, r24	; 0x02
	    pin_num=GPIO_ConfigPin[id].pin_num;
    10d2:	8b 81       	ldd	r24, Y+3	; 0x03
    10d4:	28 2f       	mov	r18, r24
    10d6:	30 e0       	ldi	r19, 0x00	; 0
    10d8:	c9 01       	movw	r24, r18
    10da:	88 0f       	add	r24, r24
    10dc:	99 1f       	adc	r25, r25
    10de:	88 0f       	add	r24, r24
    10e0:	99 1f       	adc	r25, r25
    10e2:	82 0f       	add	r24, r18
    10e4:	93 1f       	adc	r25, r19
    10e6:	fc 01       	movw	r30, r24
    10e8:	e4 57       	subi	r30, 0x74	; 116
    10ea:	ff 4f       	sbci	r31, 0xFF	; 255
    10ec:	80 81       	ld	r24, Z
    10ee:	89 83       	std	Y+1, r24	; 0x01

		if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS) )
    10f0:	89 81       	ldd	r24, Y+1	; 0x01
    10f2:	88 30       	cpi	r24, 0x08	; 8
    10f4:	88 f4       	brcc	.+34     	; 0x1118 <GPIO_ChannelGroupWrite+0xa0>
    10f6:	8a 81       	ldd	r24, Y+2	; 0x02
    10f8:	84 30       	cpi	r24, 0x04	; 4
    10fa:	70 f4       	brcc	.+28     	; 0x1118 <GPIO_ChannelGroupWrite+0xa0>
		}
		else
		{


			GPIO_writePin(port_num, pin_num,dataPtr[i]);
    10fc:	8c 81       	ldd	r24, Y+4	; 0x04
    10fe:	28 2f       	mov	r18, r24
    1100:	30 e0       	ldi	r19, 0x00	; 0
    1102:	8f 81       	ldd	r24, Y+7	; 0x07
    1104:	98 85       	ldd	r25, Y+8	; 0x08
    1106:	fc 01       	movw	r30, r24
    1108:	e2 0f       	add	r30, r18
    110a:	f3 1f       	adc	r31, r19
    110c:	90 81       	ld	r25, Z
    110e:	8a 81       	ldd	r24, Y+2	; 0x02
    1110:	69 81       	ldd	r22, Y+1	; 0x01
    1112:	49 2f       	mov	r20, r25
    1114:	0e 94 01 0b 	call	0x1602	; 0x1602 <GPIO_writePin>
void GPIO_ChannelGroupWrite(ChannelGroupType* ChannelID ,uint8 dataPtr[]){
    uint8 i = 0;
    uint8 id=0;
    uint8 port_num=0;
    uint8 pin_num=0;
	for(; i < ChannelID->no_of_channels; ++i)
    1118:	8c 81       	ldd	r24, Y+4	; 0x04
    111a:	8f 5f       	subi	r24, 0xFF	; 255
    111c:	8c 83       	std	Y+4, r24	; 0x04
    111e:	ed 81       	ldd	r30, Y+5	; 0x05
    1120:	fe 81       	ldd	r31, Y+6	; 0x06
    1122:	90 81       	ld	r25, Z
    1124:	8c 81       	ldd	r24, Y+4	; 0x04
    1126:	89 17       	cp	r24, r25
    1128:	08 f4       	brcc	.+2      	; 0x112c <GPIO_ChannelGroupWrite+0xb4>
    112a:	b9 cf       	rjmp	.-142    	; 0x109e <GPIO_ChannelGroupWrite+0x26>

			GPIO_writePin(port_num, pin_num,dataPtr[i]);

		}
	}
}
    112c:	28 96       	adiw	r28, 0x08	; 8
    112e:	0f b6       	in	r0, 0x3f	; 63
    1130:	f8 94       	cli
    1132:	de bf       	out	0x3e, r29	; 62
    1134:	0f be       	out	0x3f, r0	; 63
    1136:	cd bf       	out	0x3d, r28	; 61
    1138:	cf 91       	pop	r28
    113a:	df 91       	pop	r29
    113c:	08 95       	ret

0000113e <GPIO_ChannelGroupRead>:
/*
 *  Description :
 *  read in a group of of pin
 */
void GPIO_ChannelGroupRead(ChannelGroupType* ChannelID,uint8 dataPtr[]){
    113e:	0f 93       	push	r16
    1140:	1f 93       	push	r17
    1142:	df 93       	push	r29
    1144:	cf 93       	push	r28
    1146:	cd b7       	in	r28, 0x3d	; 61
    1148:	de b7       	in	r29, 0x3e	; 62
    114a:	a4 97       	sbiw	r28, 0x24	; 36
    114c:	0f b6       	in	r0, 0x3f	; 63
    114e:	f8 94       	cli
    1150:	de bf       	out	0x3e, r29	; 62
    1152:	0f be       	out	0x3f, r0	; 63
    1154:	cd bf       	out	0x3d, r28	; 61
    1156:	9a a3       	std	Y+34, r25	; 0x22
    1158:	89 a3       	std	Y+33, r24	; 0x21
    115a:	7c a3       	std	Y+36, r23	; 0x24
    115c:	6b a3       	std	Y+35, r22	; 0x23
    uint8 i = 0;
    115e:	18 a2       	std	Y+32, r1	; 0x20
    uint8 id=0;
    1160:	1f 8e       	std	Y+31, r1	; 0x1f
    uint8 port_num=0;
    1162:	1e 8e       	std	Y+30, r1	; 0x1e
    uint8 pin_num=0;
    1164:	1d 8e       	std	Y+29, r1	; 0x1d
    1166:	50 c1       	rjmp	.+672    	; 0x1408 <GPIO_ChannelGroupRead+0x2ca>
	for(; i < ChannelID->no_of_channels; ++i)
	{
		id= ChannelID->group_ids[i];
    1168:	88 a1       	ldd	r24, Y+32	; 0x20
    116a:	28 2f       	mov	r18, r24
    116c:	30 e0       	ldi	r19, 0x00	; 0
    116e:	89 a1       	ldd	r24, Y+33	; 0x21
    1170:	9a a1       	ldd	r25, Y+34	; 0x22
    1172:	82 0f       	add	r24, r18
    1174:	93 1f       	adc	r25, r19
    1176:	fc 01       	movw	r30, r24
    1178:	31 96       	adiw	r30, 0x01	; 1
    117a:	80 81       	ld	r24, Z
    117c:	8f 8f       	std	Y+31, r24	; 0x1f
		port_num = GPIO_ConfigPin[id].port_num;
    117e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1180:	28 2f       	mov	r18, r24
    1182:	30 e0       	ldi	r19, 0x00	; 0
    1184:	c9 01       	movw	r24, r18
    1186:	88 0f       	add	r24, r24
    1188:	99 1f       	adc	r25, r25
    118a:	88 0f       	add	r24, r24
    118c:	99 1f       	adc	r25, r25
    118e:	82 0f       	add	r24, r18
    1190:	93 1f       	adc	r25, r19
    1192:	fc 01       	movw	r30, r24
    1194:	e5 57       	subi	r30, 0x75	; 117
    1196:	ff 4f       	sbci	r31, 0xFF	; 255
    1198:	80 81       	ld	r24, Z
    119a:	8e 8f       	std	Y+30, r24	; 0x1e
		pin_num=GPIO_ConfigPin[id].pin_num;
    119c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    119e:	28 2f       	mov	r18, r24
    11a0:	30 e0       	ldi	r19, 0x00	; 0
    11a2:	c9 01       	movw	r24, r18
    11a4:	88 0f       	add	r24, r24
    11a6:	99 1f       	adc	r25, r25
    11a8:	88 0f       	add	r24, r24
    11aa:	99 1f       	adc	r25, r25
    11ac:	82 0f       	add	r24, r18
    11ae:	93 1f       	adc	r25, r19
    11b0:	fc 01       	movw	r30, r24
    11b2:	e4 57       	subi	r30, 0x74	; 116
    11b4:	ff 4f       	sbci	r31, 0xFF	; 255
    11b6:	80 81       	ld	r24, Z
    11b8:	8d 8f       	std	Y+29, r24	; 0x1d

		if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS) )
    11ba:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11bc:	88 30       	cpi	r24, 0x08	; 8
    11be:	08 f0       	brcs	.+2      	; 0x11c2 <GPIO_ChannelGroupRead+0x84>
    11c0:	20 c1       	rjmp	.+576    	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
    11c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    11c4:	84 30       	cpi	r24, 0x04	; 4
    11c6:	08 f0       	brcs	.+2      	; 0x11ca <GPIO_ChannelGroupRead+0x8c>
    11c8:	1c c1       	rjmp	.+568    	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
			/* Do Nothing */
		}
		else
		{

			if(GPIO_readPin(port_num, pin_num) == LOGIC_HIGH)
    11ca:	8e 8d       	ldd	r24, Y+30	; 0x1e
    11cc:	6d 8d       	ldd	r22, Y+29	; 0x1d
    11ce:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    11d2:	81 30       	cpi	r24, 0x01	; 1
    11d4:	09 f0       	breq	.+2      	; 0x11d8 <GPIO_ChannelGroupRead+0x9a>
    11d6:	88 c0       	rjmp	.+272    	; 0x12e8 <GPIO_ChannelGroupRead+0x1aa>
    11d8:	80 e0       	ldi	r24, 0x00	; 0
    11da:	90 e0       	ldi	r25, 0x00	; 0
    11dc:	a0 ef       	ldi	r26, 0xF0	; 240
    11de:	b1 e4       	ldi	r27, 0x41	; 65
    11e0:	89 8f       	std	Y+25, r24	; 0x19
    11e2:	9a 8f       	std	Y+26, r25	; 0x1a
    11e4:	ab 8f       	std	Y+27, r26	; 0x1b
    11e6:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    11e8:	69 8d       	ldd	r22, Y+25	; 0x19
    11ea:	7a 8d       	ldd	r23, Y+26	; 0x1a
    11ec:	8b 8d       	ldd	r24, Y+27	; 0x1b
    11ee:	9c 8d       	ldd	r25, Y+28	; 0x1c
    11f0:	20 e0       	ldi	r18, 0x00	; 0
    11f2:	30 e0       	ldi	r19, 0x00	; 0
    11f4:	4a ef       	ldi	r20, 0xFA	; 250
    11f6:	54 e4       	ldi	r21, 0x44	; 68
    11f8:	0e 94 1d 02 	call	0x43a	; 0x43a <__mulsf3>
    11fc:	dc 01       	movw	r26, r24
    11fe:	cb 01       	movw	r24, r22
    1200:	8d 8b       	std	Y+21, r24	; 0x15
    1202:	9e 8b       	std	Y+22, r25	; 0x16
    1204:	af 8b       	std	Y+23, r26	; 0x17
    1206:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1208:	6d 89       	ldd	r22, Y+21	; 0x15
    120a:	7e 89       	ldd	r23, Y+22	; 0x16
    120c:	8f 89       	ldd	r24, Y+23	; 0x17
    120e:	98 8d       	ldd	r25, Y+24	; 0x18
    1210:	20 e0       	ldi	r18, 0x00	; 0
    1212:	30 e0       	ldi	r19, 0x00	; 0
    1214:	40 e8       	ldi	r20, 0x80	; 128
    1216:	5f e3       	ldi	r21, 0x3F	; 63
    1218:	0e 94 77 03 	call	0x6ee	; 0x6ee <__ltsf2>
    121c:	88 23       	and	r24, r24
    121e:	2c f4       	brge	.+10     	; 0x122a <GPIO_ChannelGroupRead+0xec>
		__ticks = 1;
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	9c 8b       	std	Y+20, r25	; 0x14
    1226:	8b 8b       	std	Y+19, r24	; 0x13
    1228:	3f c0       	rjmp	.+126    	; 0x12a8 <GPIO_ChannelGroupRead+0x16a>
	else if (__tmp > 65535)
    122a:	6d 89       	ldd	r22, Y+21	; 0x15
    122c:	7e 89       	ldd	r23, Y+22	; 0x16
    122e:	8f 89       	ldd	r24, Y+23	; 0x17
    1230:	98 8d       	ldd	r25, Y+24	; 0x18
    1232:	20 e0       	ldi	r18, 0x00	; 0
    1234:	3f ef       	ldi	r19, 0xFF	; 255
    1236:	4f e7       	ldi	r20, 0x7F	; 127
    1238:	57 e4       	ldi	r21, 0x47	; 71
    123a:	0e 94 17 03 	call	0x62e	; 0x62e <__gtsf2>
    123e:	18 16       	cp	r1, r24
    1240:	4c f5       	brge	.+82     	; 0x1294 <GPIO_ChannelGroupRead+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1242:	69 8d       	ldd	r22, Y+25	; 0x19
    1244:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1246:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1248:	9c 8d       	ldd	r25, Y+28	; 0x1c
    124a:	20 e0       	ldi	r18, 0x00	; 0
    124c:	30 e0       	ldi	r19, 0x00	; 0
    124e:	40 e2       	ldi	r20, 0x20	; 32
    1250:	51 e4       	ldi	r21, 0x41	; 65
    1252:	0e 94 1d 02 	call	0x43a	; 0x43a <__mulsf3>
    1256:	dc 01       	movw	r26, r24
    1258:	cb 01       	movw	r24, r22
    125a:	bc 01       	movw	r22, r24
    125c:	cd 01       	movw	r24, r26
    125e:	0e 94 47 00 	call	0x8e	; 0x8e <__fixunssfsi>
    1262:	dc 01       	movw	r26, r24
    1264:	cb 01       	movw	r24, r22
    1266:	9c 8b       	std	Y+20, r25	; 0x14
    1268:	8b 8b       	std	Y+19, r24	; 0x13
    126a:	0f c0       	rjmp	.+30     	; 0x128a <GPIO_ChannelGroupRead+0x14c>
    126c:	88 ec       	ldi	r24, 0xC8	; 200
    126e:	90 e0       	ldi	r25, 0x00	; 0
    1270:	9a 8b       	std	Y+18, r25	; 0x12
    1272:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1274:	89 89       	ldd	r24, Y+17	; 0x11
    1276:	9a 89       	ldd	r25, Y+18	; 0x12
    1278:	01 97       	sbiw	r24, 0x01	; 1
    127a:	f1 f7       	brne	.-4      	; 0x1278 <GPIO_ChannelGroupRead+0x13a>
    127c:	9a 8b       	std	Y+18, r25	; 0x12
    127e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1280:	8b 89       	ldd	r24, Y+19	; 0x13
    1282:	9c 89       	ldd	r25, Y+20	; 0x14
    1284:	01 97       	sbiw	r24, 0x01	; 1
    1286:	9c 8b       	std	Y+20, r25	; 0x14
    1288:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    128a:	8b 89       	ldd	r24, Y+19	; 0x13
    128c:	9c 89       	ldd	r25, Y+20	; 0x14
    128e:	00 97       	sbiw	r24, 0x00	; 0
    1290:	69 f7       	brne	.-38     	; 0x126c <GPIO_ChannelGroupRead+0x12e>
    1292:	14 c0       	rjmp	.+40     	; 0x12bc <GPIO_ChannelGroupRead+0x17e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1294:	6d 89       	ldd	r22, Y+21	; 0x15
    1296:	7e 89       	ldd	r23, Y+22	; 0x16
    1298:	8f 89       	ldd	r24, Y+23	; 0x17
    129a:	98 8d       	ldd	r25, Y+24	; 0x18
    129c:	0e 94 47 00 	call	0x8e	; 0x8e <__fixunssfsi>
    12a0:	dc 01       	movw	r26, r24
    12a2:	cb 01       	movw	r24, r22
    12a4:	9c 8b       	std	Y+20, r25	; 0x14
    12a6:	8b 8b       	std	Y+19, r24	; 0x13
    12a8:	8b 89       	ldd	r24, Y+19	; 0x13
    12aa:	9c 89       	ldd	r25, Y+20	; 0x14
    12ac:	98 8b       	std	Y+16, r25	; 0x10
    12ae:	8f 87       	std	Y+15, r24	; 0x0f
    12b0:	8f 85       	ldd	r24, Y+15	; 0x0f
    12b2:	98 89       	ldd	r25, Y+16	; 0x10
    12b4:	01 97       	sbiw	r24, 0x01	; 1
    12b6:	f1 f7       	brne	.-4      	; 0x12b4 <GPIO_ChannelGroupRead+0x176>
    12b8:	98 8b       	std	Y+16, r25	; 0x10
    12ba:	8f 87       	std	Y+15, r24	; 0x0f
			{
				_delay_ms((double)30);
				if(GPIO_readPin(port_num, pin_num) == LOGIC_HIGH)
    12bc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12be:	6d 8d       	ldd	r22, Y+29	; 0x1d
    12c0:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    12c4:	81 30       	cpi	r24, 0x01	; 1
    12c6:	09 f0       	breq	.+2      	; 0x12ca <GPIO_ChannelGroupRead+0x18c>
    12c8:	9c c0       	rjmp	.+312    	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
				{
				dataPtr[i] = GPIO_readPin(port_num, pin_num);
    12ca:	88 a1       	ldd	r24, Y+32	; 0x20
    12cc:	28 2f       	mov	r18, r24
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    12d0:	8b a1       	ldd	r24, Y+35	; 0x23
    12d2:	9c a1       	ldd	r25, Y+36	; 0x24
    12d4:	8c 01       	movw	r16, r24
    12d6:	02 0f       	add	r16, r18
    12d8:	13 1f       	adc	r17, r19
    12da:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12dc:	6d 8d       	ldd	r22, Y+29	; 0x1d
    12de:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    12e2:	f8 01       	movw	r30, r16
    12e4:	80 83       	st	Z, r24
    12e6:	8d c0       	rjmp	.+282    	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
				}
			}
			else if(GPIO_readPin(port_num, pin_num) == LOGIC_LOW)
    12e8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12ea:	6d 8d       	ldd	r22, Y+29	; 0x1d
    12ec:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    12f0:	88 23       	and	r24, r24
    12f2:	09 f0       	breq	.+2      	; 0x12f6 <GPIO_ChannelGroupRead+0x1b8>
    12f4:	86 c0       	rjmp	.+268    	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
    12f6:	80 e0       	ldi	r24, 0x00	; 0
    12f8:	90 e0       	ldi	r25, 0x00	; 0
    12fa:	a0 ef       	ldi	r26, 0xF0	; 240
    12fc:	b1 e4       	ldi	r27, 0x41	; 65
    12fe:	8b 87       	std	Y+11, r24	; 0x0b
    1300:	9c 87       	std	Y+12, r25	; 0x0c
    1302:	ad 87       	std	Y+13, r26	; 0x0d
    1304:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1306:	6b 85       	ldd	r22, Y+11	; 0x0b
    1308:	7c 85       	ldd	r23, Y+12	; 0x0c
    130a:	8d 85       	ldd	r24, Y+13	; 0x0d
    130c:	9e 85       	ldd	r25, Y+14	; 0x0e
    130e:	20 e0       	ldi	r18, 0x00	; 0
    1310:	30 e0       	ldi	r19, 0x00	; 0
    1312:	4a ef       	ldi	r20, 0xFA	; 250
    1314:	54 e4       	ldi	r21, 0x44	; 68
    1316:	0e 94 1d 02 	call	0x43a	; 0x43a <__mulsf3>
    131a:	dc 01       	movw	r26, r24
    131c:	cb 01       	movw	r24, r22
    131e:	8f 83       	std	Y+7, r24	; 0x07
    1320:	98 87       	std	Y+8, r25	; 0x08
    1322:	a9 87       	std	Y+9, r26	; 0x09
    1324:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1326:	6f 81       	ldd	r22, Y+7	; 0x07
    1328:	78 85       	ldd	r23, Y+8	; 0x08
    132a:	89 85       	ldd	r24, Y+9	; 0x09
    132c:	9a 85       	ldd	r25, Y+10	; 0x0a
    132e:	20 e0       	ldi	r18, 0x00	; 0
    1330:	30 e0       	ldi	r19, 0x00	; 0
    1332:	40 e8       	ldi	r20, 0x80	; 128
    1334:	5f e3       	ldi	r21, 0x3F	; 63
    1336:	0e 94 77 03 	call	0x6ee	; 0x6ee <__ltsf2>
    133a:	88 23       	and	r24, r24
    133c:	2c f4       	brge	.+10     	; 0x1348 <GPIO_ChannelGroupRead+0x20a>
		__ticks = 1;
    133e:	81 e0       	ldi	r24, 0x01	; 1
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	9e 83       	std	Y+6, r25	; 0x06
    1344:	8d 83       	std	Y+5, r24	; 0x05
    1346:	3f c0       	rjmp	.+126    	; 0x13c6 <GPIO_ChannelGroupRead+0x288>
	else if (__tmp > 65535)
    1348:	6f 81       	ldd	r22, Y+7	; 0x07
    134a:	78 85       	ldd	r23, Y+8	; 0x08
    134c:	89 85       	ldd	r24, Y+9	; 0x09
    134e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1350:	20 e0       	ldi	r18, 0x00	; 0
    1352:	3f ef       	ldi	r19, 0xFF	; 255
    1354:	4f e7       	ldi	r20, 0x7F	; 127
    1356:	57 e4       	ldi	r21, 0x47	; 71
    1358:	0e 94 17 03 	call	0x62e	; 0x62e <__gtsf2>
    135c:	18 16       	cp	r1, r24
    135e:	4c f5       	brge	.+82     	; 0x13b2 <GPIO_ChannelGroupRead+0x274>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1360:	6b 85       	ldd	r22, Y+11	; 0x0b
    1362:	7c 85       	ldd	r23, Y+12	; 0x0c
    1364:	8d 85       	ldd	r24, Y+13	; 0x0d
    1366:	9e 85       	ldd	r25, Y+14	; 0x0e
    1368:	20 e0       	ldi	r18, 0x00	; 0
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	40 e2       	ldi	r20, 0x20	; 32
    136e:	51 e4       	ldi	r21, 0x41	; 65
    1370:	0e 94 1d 02 	call	0x43a	; 0x43a <__mulsf3>
    1374:	dc 01       	movw	r26, r24
    1376:	cb 01       	movw	r24, r22
    1378:	bc 01       	movw	r22, r24
    137a:	cd 01       	movw	r24, r26
    137c:	0e 94 47 00 	call	0x8e	; 0x8e <__fixunssfsi>
    1380:	dc 01       	movw	r26, r24
    1382:	cb 01       	movw	r24, r22
    1384:	9e 83       	std	Y+6, r25	; 0x06
    1386:	8d 83       	std	Y+5, r24	; 0x05
    1388:	0f c0       	rjmp	.+30     	; 0x13a8 <GPIO_ChannelGroupRead+0x26a>
    138a:	88 ec       	ldi	r24, 0xC8	; 200
    138c:	90 e0       	ldi	r25, 0x00	; 0
    138e:	9c 83       	std	Y+4, r25	; 0x04
    1390:	8b 83       	std	Y+3, r24	; 0x03
    1392:	8b 81       	ldd	r24, Y+3	; 0x03
    1394:	9c 81       	ldd	r25, Y+4	; 0x04
    1396:	01 97       	sbiw	r24, 0x01	; 1
    1398:	f1 f7       	brne	.-4      	; 0x1396 <GPIO_ChannelGroupRead+0x258>
    139a:	9c 83       	std	Y+4, r25	; 0x04
    139c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    139e:	8d 81       	ldd	r24, Y+5	; 0x05
    13a0:	9e 81       	ldd	r25, Y+6	; 0x06
    13a2:	01 97       	sbiw	r24, 0x01	; 1
    13a4:	9e 83       	std	Y+6, r25	; 0x06
    13a6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    13a8:	8d 81       	ldd	r24, Y+5	; 0x05
    13aa:	9e 81       	ldd	r25, Y+6	; 0x06
    13ac:	00 97       	sbiw	r24, 0x00	; 0
    13ae:	69 f7       	brne	.-38     	; 0x138a <GPIO_ChannelGroupRead+0x24c>
    13b0:	14 c0       	rjmp	.+40     	; 0x13da <GPIO_ChannelGroupRead+0x29c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    13b2:	6f 81       	ldd	r22, Y+7	; 0x07
    13b4:	78 85       	ldd	r23, Y+8	; 0x08
    13b6:	89 85       	ldd	r24, Y+9	; 0x09
    13b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    13ba:	0e 94 47 00 	call	0x8e	; 0x8e <__fixunssfsi>
    13be:	dc 01       	movw	r26, r24
    13c0:	cb 01       	movw	r24, r22
    13c2:	9e 83       	std	Y+6, r25	; 0x06
    13c4:	8d 83       	std	Y+5, r24	; 0x05
    13c6:	8d 81       	ldd	r24, Y+5	; 0x05
    13c8:	9e 81       	ldd	r25, Y+6	; 0x06
    13ca:	9a 83       	std	Y+2, r25	; 0x02
    13cc:	89 83       	std	Y+1, r24	; 0x01
    13ce:	89 81       	ldd	r24, Y+1	; 0x01
    13d0:	9a 81       	ldd	r25, Y+2	; 0x02
    13d2:	01 97       	sbiw	r24, 0x01	; 1
    13d4:	f1 f7       	brne	.-4      	; 0x13d2 <GPIO_ChannelGroupRead+0x294>
    13d6:	9a 83       	std	Y+2, r25	; 0x02
    13d8:	89 83       	std	Y+1, r24	; 0x01
			{
				_delay_ms((double)30);
				if(GPIO_readPin(port_num, pin_num) == LOGIC_LOW)
    13da:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13dc:	6d 8d       	ldd	r22, Y+29	; 0x1d
    13de:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    13e2:	88 23       	and	r24, r24
    13e4:	71 f4       	brne	.+28     	; 0x1402 <GPIO_ChannelGroupRead+0x2c4>
				{
				dataPtr[i] = GPIO_readPin(port_num, pin_num);
    13e6:	88 a1       	ldd	r24, Y+32	; 0x20
    13e8:	28 2f       	mov	r18, r24
    13ea:	30 e0       	ldi	r19, 0x00	; 0
    13ec:	8b a1       	ldd	r24, Y+35	; 0x23
    13ee:	9c a1       	ldd	r25, Y+36	; 0x24
    13f0:	8c 01       	movw	r16, r24
    13f2:	02 0f       	add	r16, r18
    13f4:	13 1f       	adc	r17, r19
    13f6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13f8:	6d 8d       	ldd	r22, Y+29	; 0x1d
    13fa:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <GPIO_readPin>
    13fe:	f8 01       	movw	r30, r16
    1400:	80 83       	st	Z, r24
void GPIO_ChannelGroupRead(ChannelGroupType* ChannelID,uint8 dataPtr[]){
    uint8 i = 0;
    uint8 id=0;
    uint8 port_num=0;
    uint8 pin_num=0;
	for(; i < ChannelID->no_of_channels; ++i)
    1402:	88 a1       	ldd	r24, Y+32	; 0x20
    1404:	8f 5f       	subi	r24, 0xFF	; 255
    1406:	88 a3       	std	Y+32, r24	; 0x20
    1408:	e9 a1       	ldd	r30, Y+33	; 0x21
    140a:	fa a1       	ldd	r31, Y+34	; 0x22
    140c:	90 81       	ld	r25, Z
    140e:	88 a1       	ldd	r24, Y+32	; 0x20
    1410:	89 17       	cp	r24, r25
    1412:	08 f4       	brcc	.+2      	; 0x1416 <GPIO_ChannelGroupRead+0x2d8>
    1414:	a9 ce       	rjmp	.-686    	; 0x1168 <GPIO_ChannelGroupRead+0x2a>

			}

		}
	}
}
    1416:	a4 96       	adiw	r28, 0x24	; 36
    1418:	0f b6       	in	r0, 0x3f	; 63
    141a:	f8 94       	cli
    141c:	de bf       	out	0x3e, r29	; 62
    141e:	0f be       	out	0x3f, r0	; 63
    1420:	cd bf       	out	0x3d, r28	; 61
    1422:	cf 91       	pop	r28
    1424:	df 91       	pop	r29
    1426:	1f 91       	pop	r17
    1428:	0f 91       	pop	r16
    142a:	08 95       	ret

0000142c <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    142c:	df 93       	push	r29
    142e:	cf 93       	push	r28
    1430:	00 d0       	rcall	.+0      	; 0x1432 <GPIO_setupPinDirection+0x6>
    1432:	00 d0       	rcall	.+0      	; 0x1434 <GPIO_setupPinDirection+0x8>
    1434:	0f 92       	push	r0
    1436:	cd b7       	in	r28, 0x3d	; 61
    1438:	de b7       	in	r29, 0x3e	; 62
    143a:	89 83       	std	Y+1, r24	; 0x01
    143c:	6a 83       	std	Y+2, r22	; 0x02
    143e:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    1440:	8a 81       	ldd	r24, Y+2	; 0x02
    1442:	88 30       	cpi	r24, 0x08	; 8
    1444:	08 f0       	brcs	.+2      	; 0x1448 <GPIO_setupPinDirection+0x1c>
    1446:	d5 c0       	rjmp	.+426    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
    1448:	89 81       	ldd	r24, Y+1	; 0x01
    144a:	84 30       	cpi	r24, 0x04	; 4
    144c:	08 f0       	brcs	.+2      	; 0x1450 <GPIO_setupPinDirection+0x24>
    144e:	d1 c0       	rjmp	.+418    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
    1450:	89 81       	ldd	r24, Y+1	; 0x01
    1452:	28 2f       	mov	r18, r24
    1454:	30 e0       	ldi	r19, 0x00	; 0
    1456:	3d 83       	std	Y+5, r19	; 0x05
    1458:	2c 83       	std	Y+4, r18	; 0x04
    145a:	8c 81       	ldd	r24, Y+4	; 0x04
    145c:	9d 81       	ldd	r25, Y+5	; 0x05
    145e:	81 30       	cpi	r24, 0x01	; 1
    1460:	91 05       	cpc	r25, r1
    1462:	09 f4       	brne	.+2      	; 0x1466 <GPIO_setupPinDirection+0x3a>
    1464:	43 c0       	rjmp	.+134    	; 0x14ec <GPIO_setupPinDirection+0xc0>
    1466:	2c 81       	ldd	r18, Y+4	; 0x04
    1468:	3d 81       	ldd	r19, Y+5	; 0x05
    146a:	22 30       	cpi	r18, 0x02	; 2
    146c:	31 05       	cpc	r19, r1
    146e:	2c f4       	brge	.+10     	; 0x147a <GPIO_setupPinDirection+0x4e>
    1470:	8c 81       	ldd	r24, Y+4	; 0x04
    1472:	9d 81       	ldd	r25, Y+5	; 0x05
    1474:	00 97       	sbiw	r24, 0x00	; 0
    1476:	71 f0       	breq	.+28     	; 0x1494 <GPIO_setupPinDirection+0x68>
    1478:	bc c0       	rjmp	.+376    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
    147a:	2c 81       	ldd	r18, Y+4	; 0x04
    147c:	3d 81       	ldd	r19, Y+5	; 0x05
    147e:	22 30       	cpi	r18, 0x02	; 2
    1480:	31 05       	cpc	r19, r1
    1482:	09 f4       	brne	.+2      	; 0x1486 <GPIO_setupPinDirection+0x5a>
    1484:	5f c0       	rjmp	.+190    	; 0x1544 <GPIO_setupPinDirection+0x118>
    1486:	8c 81       	ldd	r24, Y+4	; 0x04
    1488:	9d 81       	ldd	r25, Y+5	; 0x05
    148a:	83 30       	cpi	r24, 0x03	; 3
    148c:	91 05       	cpc	r25, r1
    148e:	09 f4       	brne	.+2      	; 0x1492 <GPIO_setupPinDirection+0x66>
    1490:	85 c0       	rjmp	.+266    	; 0x159c <GPIO_setupPinDirection+0x170>
    1492:	af c0       	rjmp	.+350    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
    1494:	8b 81       	ldd	r24, Y+3	; 0x03
    1496:	81 30       	cpi	r24, 0x01	; 1
    1498:	a1 f4       	brne	.+40     	; 0x14c2 <GPIO_setupPinDirection+0x96>
			{
				SET_BIT(DDRA,pin_num);
    149a:	aa e3       	ldi	r26, 0x3A	; 58
    149c:	b0 e0       	ldi	r27, 0x00	; 0
    149e:	ea e3       	ldi	r30, 0x3A	; 58
    14a0:	f0 e0       	ldi	r31, 0x00	; 0
    14a2:	80 81       	ld	r24, Z
    14a4:	48 2f       	mov	r20, r24
    14a6:	8a 81       	ldd	r24, Y+2	; 0x02
    14a8:	28 2f       	mov	r18, r24
    14aa:	30 e0       	ldi	r19, 0x00	; 0
    14ac:	81 e0       	ldi	r24, 0x01	; 1
    14ae:	90 e0       	ldi	r25, 0x00	; 0
    14b0:	02 2e       	mov	r0, r18
    14b2:	02 c0       	rjmp	.+4      	; 0x14b8 <GPIO_setupPinDirection+0x8c>
    14b4:	88 0f       	add	r24, r24
    14b6:	99 1f       	adc	r25, r25
    14b8:	0a 94       	dec	r0
    14ba:	e2 f7       	brpl	.-8      	; 0x14b4 <GPIO_setupPinDirection+0x88>
    14bc:	84 2b       	or	r24, r20
    14be:	8c 93       	st	X, r24
    14c0:	98 c0       	rjmp	.+304    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
    14c2:	aa e3       	ldi	r26, 0x3A	; 58
    14c4:	b0 e0       	ldi	r27, 0x00	; 0
    14c6:	ea e3       	ldi	r30, 0x3A	; 58
    14c8:	f0 e0       	ldi	r31, 0x00	; 0
    14ca:	80 81       	ld	r24, Z
    14cc:	48 2f       	mov	r20, r24
    14ce:	8a 81       	ldd	r24, Y+2	; 0x02
    14d0:	28 2f       	mov	r18, r24
    14d2:	30 e0       	ldi	r19, 0x00	; 0
    14d4:	81 e0       	ldi	r24, 0x01	; 1
    14d6:	90 e0       	ldi	r25, 0x00	; 0
    14d8:	02 2e       	mov	r0, r18
    14da:	02 c0       	rjmp	.+4      	; 0x14e0 <GPIO_setupPinDirection+0xb4>
    14dc:	88 0f       	add	r24, r24
    14de:	99 1f       	adc	r25, r25
    14e0:	0a 94       	dec	r0
    14e2:	e2 f7       	brpl	.-8      	; 0x14dc <GPIO_setupPinDirection+0xb0>
    14e4:	80 95       	com	r24
    14e6:	84 23       	and	r24, r20
    14e8:	8c 93       	st	X, r24
    14ea:	83 c0       	rjmp	.+262    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    14ec:	8b 81       	ldd	r24, Y+3	; 0x03
    14ee:	81 30       	cpi	r24, 0x01	; 1
    14f0:	a1 f4       	brne	.+40     	; 0x151a <GPIO_setupPinDirection+0xee>
			{
				SET_BIT(DDRB,pin_num);
    14f2:	a7 e3       	ldi	r26, 0x37	; 55
    14f4:	b0 e0       	ldi	r27, 0x00	; 0
    14f6:	e7 e3       	ldi	r30, 0x37	; 55
    14f8:	f0 e0       	ldi	r31, 0x00	; 0
    14fa:	80 81       	ld	r24, Z
    14fc:	48 2f       	mov	r20, r24
    14fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1500:	28 2f       	mov	r18, r24
    1502:	30 e0       	ldi	r19, 0x00	; 0
    1504:	81 e0       	ldi	r24, 0x01	; 1
    1506:	90 e0       	ldi	r25, 0x00	; 0
    1508:	02 2e       	mov	r0, r18
    150a:	02 c0       	rjmp	.+4      	; 0x1510 <GPIO_setupPinDirection+0xe4>
    150c:	88 0f       	add	r24, r24
    150e:	99 1f       	adc	r25, r25
    1510:	0a 94       	dec	r0
    1512:	e2 f7       	brpl	.-8      	; 0x150c <GPIO_setupPinDirection+0xe0>
    1514:	84 2b       	or	r24, r20
    1516:	8c 93       	st	X, r24
    1518:	6c c0       	rjmp	.+216    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
    151a:	a7 e3       	ldi	r26, 0x37	; 55
    151c:	b0 e0       	ldi	r27, 0x00	; 0
    151e:	e7 e3       	ldi	r30, 0x37	; 55
    1520:	f0 e0       	ldi	r31, 0x00	; 0
    1522:	80 81       	ld	r24, Z
    1524:	48 2f       	mov	r20, r24
    1526:	8a 81       	ldd	r24, Y+2	; 0x02
    1528:	28 2f       	mov	r18, r24
    152a:	30 e0       	ldi	r19, 0x00	; 0
    152c:	81 e0       	ldi	r24, 0x01	; 1
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	02 2e       	mov	r0, r18
    1532:	02 c0       	rjmp	.+4      	; 0x1538 <GPIO_setupPinDirection+0x10c>
    1534:	88 0f       	add	r24, r24
    1536:	99 1f       	adc	r25, r25
    1538:	0a 94       	dec	r0
    153a:	e2 f7       	brpl	.-8      	; 0x1534 <GPIO_setupPinDirection+0x108>
    153c:	80 95       	com	r24
    153e:	84 23       	and	r24, r20
    1540:	8c 93       	st	X, r24
    1542:	57 c0       	rjmp	.+174    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    1544:	8b 81       	ldd	r24, Y+3	; 0x03
    1546:	81 30       	cpi	r24, 0x01	; 1
    1548:	a1 f4       	brne	.+40     	; 0x1572 <GPIO_setupPinDirection+0x146>
			{
				SET_BIT(DDRC,pin_num);
    154a:	a4 e3       	ldi	r26, 0x34	; 52
    154c:	b0 e0       	ldi	r27, 0x00	; 0
    154e:	e4 e3       	ldi	r30, 0x34	; 52
    1550:	f0 e0       	ldi	r31, 0x00	; 0
    1552:	80 81       	ld	r24, Z
    1554:	48 2f       	mov	r20, r24
    1556:	8a 81       	ldd	r24, Y+2	; 0x02
    1558:	28 2f       	mov	r18, r24
    155a:	30 e0       	ldi	r19, 0x00	; 0
    155c:	81 e0       	ldi	r24, 0x01	; 1
    155e:	90 e0       	ldi	r25, 0x00	; 0
    1560:	02 2e       	mov	r0, r18
    1562:	02 c0       	rjmp	.+4      	; 0x1568 <GPIO_setupPinDirection+0x13c>
    1564:	88 0f       	add	r24, r24
    1566:	99 1f       	adc	r25, r25
    1568:	0a 94       	dec	r0
    156a:	e2 f7       	brpl	.-8      	; 0x1564 <GPIO_setupPinDirection+0x138>
    156c:	84 2b       	or	r24, r20
    156e:	8c 93       	st	X, r24
    1570:	40 c0       	rjmp	.+128    	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
    1572:	a4 e3       	ldi	r26, 0x34	; 52
    1574:	b0 e0       	ldi	r27, 0x00	; 0
    1576:	e4 e3       	ldi	r30, 0x34	; 52
    1578:	f0 e0       	ldi	r31, 0x00	; 0
    157a:	80 81       	ld	r24, Z
    157c:	48 2f       	mov	r20, r24
    157e:	8a 81       	ldd	r24, Y+2	; 0x02
    1580:	28 2f       	mov	r18, r24
    1582:	30 e0       	ldi	r19, 0x00	; 0
    1584:	81 e0       	ldi	r24, 0x01	; 1
    1586:	90 e0       	ldi	r25, 0x00	; 0
    1588:	02 2e       	mov	r0, r18
    158a:	02 c0       	rjmp	.+4      	; 0x1590 <GPIO_setupPinDirection+0x164>
    158c:	88 0f       	add	r24, r24
    158e:	99 1f       	adc	r25, r25
    1590:	0a 94       	dec	r0
    1592:	e2 f7       	brpl	.-8      	; 0x158c <GPIO_setupPinDirection+0x160>
    1594:	80 95       	com	r24
    1596:	84 23       	and	r24, r20
    1598:	8c 93       	st	X, r24
    159a:	2b c0       	rjmp	.+86     	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    159c:	8b 81       	ldd	r24, Y+3	; 0x03
    159e:	81 30       	cpi	r24, 0x01	; 1
    15a0:	a1 f4       	brne	.+40     	; 0x15ca <GPIO_setupPinDirection+0x19e>
			{
				SET_BIT(DDRD,pin_num);
    15a2:	a1 e3       	ldi	r26, 0x31	; 49
    15a4:	b0 e0       	ldi	r27, 0x00	; 0
    15a6:	e1 e3       	ldi	r30, 0x31	; 49
    15a8:	f0 e0       	ldi	r31, 0x00	; 0
    15aa:	80 81       	ld	r24, Z
    15ac:	48 2f       	mov	r20, r24
    15ae:	8a 81       	ldd	r24, Y+2	; 0x02
    15b0:	28 2f       	mov	r18, r24
    15b2:	30 e0       	ldi	r19, 0x00	; 0
    15b4:	81 e0       	ldi	r24, 0x01	; 1
    15b6:	90 e0       	ldi	r25, 0x00	; 0
    15b8:	02 2e       	mov	r0, r18
    15ba:	02 c0       	rjmp	.+4      	; 0x15c0 <GPIO_setupPinDirection+0x194>
    15bc:	88 0f       	add	r24, r24
    15be:	99 1f       	adc	r25, r25
    15c0:	0a 94       	dec	r0
    15c2:	e2 f7       	brpl	.-8      	; 0x15bc <GPIO_setupPinDirection+0x190>
    15c4:	84 2b       	or	r24, r20
    15c6:	8c 93       	st	X, r24
    15c8:	14 c0       	rjmp	.+40     	; 0x15f2 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
    15ca:	a1 e3       	ldi	r26, 0x31	; 49
    15cc:	b0 e0       	ldi	r27, 0x00	; 0
    15ce:	e1 e3       	ldi	r30, 0x31	; 49
    15d0:	f0 e0       	ldi	r31, 0x00	; 0
    15d2:	80 81       	ld	r24, Z
    15d4:	48 2f       	mov	r20, r24
    15d6:	8a 81       	ldd	r24, Y+2	; 0x02
    15d8:	28 2f       	mov	r18, r24
    15da:	30 e0       	ldi	r19, 0x00	; 0
    15dc:	81 e0       	ldi	r24, 0x01	; 1
    15de:	90 e0       	ldi	r25, 0x00	; 0
    15e0:	02 2e       	mov	r0, r18
    15e2:	02 c0       	rjmp	.+4      	; 0x15e8 <GPIO_setupPinDirection+0x1bc>
    15e4:	88 0f       	add	r24, r24
    15e6:	99 1f       	adc	r25, r25
    15e8:	0a 94       	dec	r0
    15ea:	e2 f7       	brpl	.-8      	; 0x15e4 <GPIO_setupPinDirection+0x1b8>
    15ec:	80 95       	com	r24
    15ee:	84 23       	and	r24, r20
    15f0:	8c 93       	st	X, r24
			break;
		default:
		    break;
		}
	}
}
    15f2:	0f 90       	pop	r0
    15f4:	0f 90       	pop	r0
    15f6:	0f 90       	pop	r0
    15f8:	0f 90       	pop	r0
    15fa:	0f 90       	pop	r0
    15fc:	cf 91       	pop	r28
    15fe:	df 91       	pop	r29
    1600:	08 95       	ret

00001602 <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    1602:	df 93       	push	r29
    1604:	cf 93       	push	r28
    1606:	00 d0       	rcall	.+0      	; 0x1608 <GPIO_writePin+0x6>
    1608:	00 d0       	rcall	.+0      	; 0x160a <GPIO_writePin+0x8>
    160a:	0f 92       	push	r0
    160c:	cd b7       	in	r28, 0x3d	; 61
    160e:	de b7       	in	r29, 0x3e	; 62
    1610:	89 83       	std	Y+1, r24	; 0x01
    1612:	6a 83       	std	Y+2, r22	; 0x02
    1614:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    1616:	8a 81       	ldd	r24, Y+2	; 0x02
    1618:	88 30       	cpi	r24, 0x08	; 8
    161a:	08 f0       	brcs	.+2      	; 0x161e <GPIO_writePin+0x1c>
    161c:	d5 c0       	rjmp	.+426    	; 0x17c8 <GPIO_writePin+0x1c6>
    161e:	89 81       	ldd	r24, Y+1	; 0x01
    1620:	84 30       	cpi	r24, 0x04	; 4
    1622:	08 f0       	brcs	.+2      	; 0x1626 <GPIO_writePin+0x24>
    1624:	d1 c0       	rjmp	.+418    	; 0x17c8 <GPIO_writePin+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    1626:	89 81       	ldd	r24, Y+1	; 0x01
    1628:	28 2f       	mov	r18, r24
    162a:	30 e0       	ldi	r19, 0x00	; 0
    162c:	3d 83       	std	Y+5, r19	; 0x05
    162e:	2c 83       	std	Y+4, r18	; 0x04
    1630:	8c 81       	ldd	r24, Y+4	; 0x04
    1632:	9d 81       	ldd	r25, Y+5	; 0x05
    1634:	81 30       	cpi	r24, 0x01	; 1
    1636:	91 05       	cpc	r25, r1
    1638:	09 f4       	brne	.+2      	; 0x163c <GPIO_writePin+0x3a>
    163a:	43 c0       	rjmp	.+134    	; 0x16c2 <GPIO_writePin+0xc0>
    163c:	2c 81       	ldd	r18, Y+4	; 0x04
    163e:	3d 81       	ldd	r19, Y+5	; 0x05
    1640:	22 30       	cpi	r18, 0x02	; 2
    1642:	31 05       	cpc	r19, r1
    1644:	2c f4       	brge	.+10     	; 0x1650 <GPIO_writePin+0x4e>
    1646:	8c 81       	ldd	r24, Y+4	; 0x04
    1648:	9d 81       	ldd	r25, Y+5	; 0x05
    164a:	00 97       	sbiw	r24, 0x00	; 0
    164c:	71 f0       	breq	.+28     	; 0x166a <GPIO_writePin+0x68>
    164e:	bc c0       	rjmp	.+376    	; 0x17c8 <GPIO_writePin+0x1c6>
    1650:	2c 81       	ldd	r18, Y+4	; 0x04
    1652:	3d 81       	ldd	r19, Y+5	; 0x05
    1654:	22 30       	cpi	r18, 0x02	; 2
    1656:	31 05       	cpc	r19, r1
    1658:	09 f4       	brne	.+2      	; 0x165c <GPIO_writePin+0x5a>
    165a:	5f c0       	rjmp	.+190    	; 0x171a <GPIO_writePin+0x118>
    165c:	8c 81       	ldd	r24, Y+4	; 0x04
    165e:	9d 81       	ldd	r25, Y+5	; 0x05
    1660:	83 30       	cpi	r24, 0x03	; 3
    1662:	91 05       	cpc	r25, r1
    1664:	09 f4       	brne	.+2      	; 0x1668 <GPIO_writePin+0x66>
    1666:	85 c0       	rjmp	.+266    	; 0x1772 <GPIO_writePin+0x170>
    1668:	af c0       	rjmp	.+350    	; 0x17c8 <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    166a:	8b 81       	ldd	r24, Y+3	; 0x03
    166c:	81 30       	cpi	r24, 0x01	; 1
    166e:	a1 f4       	brne	.+40     	; 0x1698 <GPIO_writePin+0x96>
			{
				SET_BIT(PORTA,pin_num);
    1670:	ab e3       	ldi	r26, 0x3B	; 59
    1672:	b0 e0       	ldi	r27, 0x00	; 0
    1674:	eb e3       	ldi	r30, 0x3B	; 59
    1676:	f0 e0       	ldi	r31, 0x00	; 0
    1678:	80 81       	ld	r24, Z
    167a:	48 2f       	mov	r20, r24
    167c:	8a 81       	ldd	r24, Y+2	; 0x02
    167e:	28 2f       	mov	r18, r24
    1680:	30 e0       	ldi	r19, 0x00	; 0
    1682:	81 e0       	ldi	r24, 0x01	; 1
    1684:	90 e0       	ldi	r25, 0x00	; 0
    1686:	02 2e       	mov	r0, r18
    1688:	02 c0       	rjmp	.+4      	; 0x168e <GPIO_writePin+0x8c>
    168a:	88 0f       	add	r24, r24
    168c:	99 1f       	adc	r25, r25
    168e:	0a 94       	dec	r0
    1690:	e2 f7       	brpl	.-8      	; 0x168a <GPIO_writePin+0x88>
    1692:	84 2b       	or	r24, r20
    1694:	8c 93       	st	X, r24
    1696:	98 c0       	rjmp	.+304    	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    1698:	ab e3       	ldi	r26, 0x3B	; 59
    169a:	b0 e0       	ldi	r27, 0x00	; 0
    169c:	eb e3       	ldi	r30, 0x3B	; 59
    169e:	f0 e0       	ldi	r31, 0x00	; 0
    16a0:	80 81       	ld	r24, Z
    16a2:	48 2f       	mov	r20, r24
    16a4:	8a 81       	ldd	r24, Y+2	; 0x02
    16a6:	28 2f       	mov	r18, r24
    16a8:	30 e0       	ldi	r19, 0x00	; 0
    16aa:	81 e0       	ldi	r24, 0x01	; 1
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	02 2e       	mov	r0, r18
    16b0:	02 c0       	rjmp	.+4      	; 0x16b6 <GPIO_writePin+0xb4>
    16b2:	88 0f       	add	r24, r24
    16b4:	99 1f       	adc	r25, r25
    16b6:	0a 94       	dec	r0
    16b8:	e2 f7       	brpl	.-8      	; 0x16b2 <GPIO_writePin+0xb0>
    16ba:	80 95       	com	r24
    16bc:	84 23       	and	r24, r20
    16be:	8c 93       	st	X, r24
    16c0:	83 c0       	rjmp	.+262    	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    16c2:	8b 81       	ldd	r24, Y+3	; 0x03
    16c4:	81 30       	cpi	r24, 0x01	; 1
    16c6:	a1 f4       	brne	.+40     	; 0x16f0 <GPIO_writePin+0xee>
			{
				SET_BIT(PORTB,pin_num);
    16c8:	a8 e3       	ldi	r26, 0x38	; 56
    16ca:	b0 e0       	ldi	r27, 0x00	; 0
    16cc:	e8 e3       	ldi	r30, 0x38	; 56
    16ce:	f0 e0       	ldi	r31, 0x00	; 0
    16d0:	80 81       	ld	r24, Z
    16d2:	48 2f       	mov	r20, r24
    16d4:	8a 81       	ldd	r24, Y+2	; 0x02
    16d6:	28 2f       	mov	r18, r24
    16d8:	30 e0       	ldi	r19, 0x00	; 0
    16da:	81 e0       	ldi	r24, 0x01	; 1
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	02 2e       	mov	r0, r18
    16e0:	02 c0       	rjmp	.+4      	; 0x16e6 <GPIO_writePin+0xe4>
    16e2:	88 0f       	add	r24, r24
    16e4:	99 1f       	adc	r25, r25
    16e6:	0a 94       	dec	r0
    16e8:	e2 f7       	brpl	.-8      	; 0x16e2 <GPIO_writePin+0xe0>
    16ea:	84 2b       	or	r24, r20
    16ec:	8c 93       	st	X, r24
    16ee:	6c c0       	rjmp	.+216    	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    16f0:	a8 e3       	ldi	r26, 0x38	; 56
    16f2:	b0 e0       	ldi	r27, 0x00	; 0
    16f4:	e8 e3       	ldi	r30, 0x38	; 56
    16f6:	f0 e0       	ldi	r31, 0x00	; 0
    16f8:	80 81       	ld	r24, Z
    16fa:	48 2f       	mov	r20, r24
    16fc:	8a 81       	ldd	r24, Y+2	; 0x02
    16fe:	28 2f       	mov	r18, r24
    1700:	30 e0       	ldi	r19, 0x00	; 0
    1702:	81 e0       	ldi	r24, 0x01	; 1
    1704:	90 e0       	ldi	r25, 0x00	; 0
    1706:	02 2e       	mov	r0, r18
    1708:	02 c0       	rjmp	.+4      	; 0x170e <GPIO_writePin+0x10c>
    170a:	88 0f       	add	r24, r24
    170c:	99 1f       	adc	r25, r25
    170e:	0a 94       	dec	r0
    1710:	e2 f7       	brpl	.-8      	; 0x170a <GPIO_writePin+0x108>
    1712:	80 95       	com	r24
    1714:	84 23       	and	r24, r20
    1716:	8c 93       	st	X, r24
    1718:	57 c0       	rjmp	.+174    	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    171a:	8b 81       	ldd	r24, Y+3	; 0x03
    171c:	81 30       	cpi	r24, 0x01	; 1
    171e:	a1 f4       	brne	.+40     	; 0x1748 <GPIO_writePin+0x146>
			{
				SET_BIT(PORTC,pin_num);
    1720:	a5 e3       	ldi	r26, 0x35	; 53
    1722:	b0 e0       	ldi	r27, 0x00	; 0
    1724:	e5 e3       	ldi	r30, 0x35	; 53
    1726:	f0 e0       	ldi	r31, 0x00	; 0
    1728:	80 81       	ld	r24, Z
    172a:	48 2f       	mov	r20, r24
    172c:	8a 81       	ldd	r24, Y+2	; 0x02
    172e:	28 2f       	mov	r18, r24
    1730:	30 e0       	ldi	r19, 0x00	; 0
    1732:	81 e0       	ldi	r24, 0x01	; 1
    1734:	90 e0       	ldi	r25, 0x00	; 0
    1736:	02 2e       	mov	r0, r18
    1738:	02 c0       	rjmp	.+4      	; 0x173e <GPIO_writePin+0x13c>
    173a:	88 0f       	add	r24, r24
    173c:	99 1f       	adc	r25, r25
    173e:	0a 94       	dec	r0
    1740:	e2 f7       	brpl	.-8      	; 0x173a <GPIO_writePin+0x138>
    1742:	84 2b       	or	r24, r20
    1744:	8c 93       	st	X, r24
    1746:	40 c0       	rjmp	.+128    	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    1748:	a5 e3       	ldi	r26, 0x35	; 53
    174a:	b0 e0       	ldi	r27, 0x00	; 0
    174c:	e5 e3       	ldi	r30, 0x35	; 53
    174e:	f0 e0       	ldi	r31, 0x00	; 0
    1750:	80 81       	ld	r24, Z
    1752:	48 2f       	mov	r20, r24
    1754:	8a 81       	ldd	r24, Y+2	; 0x02
    1756:	28 2f       	mov	r18, r24
    1758:	30 e0       	ldi	r19, 0x00	; 0
    175a:	81 e0       	ldi	r24, 0x01	; 1
    175c:	90 e0       	ldi	r25, 0x00	; 0
    175e:	02 2e       	mov	r0, r18
    1760:	02 c0       	rjmp	.+4      	; 0x1766 <GPIO_writePin+0x164>
    1762:	88 0f       	add	r24, r24
    1764:	99 1f       	adc	r25, r25
    1766:	0a 94       	dec	r0
    1768:	e2 f7       	brpl	.-8      	; 0x1762 <GPIO_writePin+0x160>
    176a:	80 95       	com	r24
    176c:	84 23       	and	r24, r20
    176e:	8c 93       	st	X, r24
    1770:	2b c0       	rjmp	.+86     	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    1772:	8b 81       	ldd	r24, Y+3	; 0x03
    1774:	81 30       	cpi	r24, 0x01	; 1
    1776:	a1 f4       	brne	.+40     	; 0x17a0 <GPIO_writePin+0x19e>
			{
				SET_BIT(PORTD,pin_num);
    1778:	a2 e3       	ldi	r26, 0x32	; 50
    177a:	b0 e0       	ldi	r27, 0x00	; 0
    177c:	e2 e3       	ldi	r30, 0x32	; 50
    177e:	f0 e0       	ldi	r31, 0x00	; 0
    1780:	80 81       	ld	r24, Z
    1782:	48 2f       	mov	r20, r24
    1784:	8a 81       	ldd	r24, Y+2	; 0x02
    1786:	28 2f       	mov	r18, r24
    1788:	30 e0       	ldi	r19, 0x00	; 0
    178a:	81 e0       	ldi	r24, 0x01	; 1
    178c:	90 e0       	ldi	r25, 0x00	; 0
    178e:	02 2e       	mov	r0, r18
    1790:	02 c0       	rjmp	.+4      	; 0x1796 <GPIO_writePin+0x194>
    1792:	88 0f       	add	r24, r24
    1794:	99 1f       	adc	r25, r25
    1796:	0a 94       	dec	r0
    1798:	e2 f7       	brpl	.-8      	; 0x1792 <GPIO_writePin+0x190>
    179a:	84 2b       	or	r24, r20
    179c:	8c 93       	st	X, r24
    179e:	14 c0       	rjmp	.+40     	; 0x17c8 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    17a0:	a2 e3       	ldi	r26, 0x32	; 50
    17a2:	b0 e0       	ldi	r27, 0x00	; 0
    17a4:	e2 e3       	ldi	r30, 0x32	; 50
    17a6:	f0 e0       	ldi	r31, 0x00	; 0
    17a8:	80 81       	ld	r24, Z
    17aa:	48 2f       	mov	r20, r24
    17ac:	8a 81       	ldd	r24, Y+2	; 0x02
    17ae:	28 2f       	mov	r18, r24
    17b0:	30 e0       	ldi	r19, 0x00	; 0
    17b2:	81 e0       	ldi	r24, 0x01	; 1
    17b4:	90 e0       	ldi	r25, 0x00	; 0
    17b6:	02 2e       	mov	r0, r18
    17b8:	02 c0       	rjmp	.+4      	; 0x17be <GPIO_writePin+0x1bc>
    17ba:	88 0f       	add	r24, r24
    17bc:	99 1f       	adc	r25, r25
    17be:	0a 94       	dec	r0
    17c0:	e2 f7       	brpl	.-8      	; 0x17ba <GPIO_writePin+0x1b8>
    17c2:	80 95       	com	r24
    17c4:	84 23       	and	r24, r20
    17c6:	8c 93       	st	X, r24
			break;
		default:
		            break;
		}
	}
}
    17c8:	0f 90       	pop	r0
    17ca:	0f 90       	pop	r0
    17cc:	0f 90       	pop	r0
    17ce:	0f 90       	pop	r0
    17d0:	0f 90       	pop	r0
    17d2:	cf 91       	pop	r28
    17d4:	df 91       	pop	r29
    17d6:	08 95       	ret

000017d8 <GPIO_TogglePin>:
void GPIO_TogglePin(uint8 port_num, uint8 pin_num){
    17d8:	df 93       	push	r29
    17da:	cf 93       	push	r28
    17dc:	00 d0       	rcall	.+0      	; 0x17de <GPIO_TogglePin+0x6>
    17de:	00 d0       	rcall	.+0      	; 0x17e0 <GPIO_TogglePin+0x8>
    17e0:	cd b7       	in	r28, 0x3d	; 61
    17e2:	de b7       	in	r29, 0x3e	; 62
    17e4:	89 83       	std	Y+1, r24	; 0x01
    17e6:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    17e8:	8a 81       	ldd	r24, Y+2	; 0x02
    17ea:	88 30       	cpi	r24, 0x08	; 8
    17ec:	08 f0       	brcs	.+2      	; 0x17f0 <GPIO_TogglePin+0x18>
    17ee:	72 c0       	rjmp	.+228    	; 0x18d4 <GPIO_TogglePin+0xfc>
    17f0:	89 81       	ldd	r24, Y+1	; 0x01
    17f2:	84 30       	cpi	r24, 0x04	; 4
    17f4:	08 f0       	brcs	.+2      	; 0x17f8 <GPIO_TogglePin+0x20>
    17f6:	6e c0       	rjmp	.+220    	; 0x18d4 <GPIO_TogglePin+0xfc>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    17f8:	89 81       	ldd	r24, Y+1	; 0x01
    17fa:	28 2f       	mov	r18, r24
    17fc:	30 e0       	ldi	r19, 0x00	; 0
    17fe:	3c 83       	std	Y+4, r19	; 0x04
    1800:	2b 83       	std	Y+3, r18	; 0x03
    1802:	8b 81       	ldd	r24, Y+3	; 0x03
    1804:	9c 81       	ldd	r25, Y+4	; 0x04
    1806:	81 30       	cpi	r24, 0x01	; 1
    1808:	91 05       	cpc	r25, r1
    180a:	49 f1       	breq	.+82     	; 0x185e <GPIO_TogglePin+0x86>
    180c:	2b 81       	ldd	r18, Y+3	; 0x03
    180e:	3c 81       	ldd	r19, Y+4	; 0x04
    1810:	22 30       	cpi	r18, 0x02	; 2
    1812:	31 05       	cpc	r19, r1
    1814:	2c f4       	brge	.+10     	; 0x1820 <GPIO_TogglePin+0x48>
    1816:	8b 81       	ldd	r24, Y+3	; 0x03
    1818:	9c 81       	ldd	r25, Y+4	; 0x04
    181a:	00 97       	sbiw	r24, 0x00	; 0
    181c:	61 f0       	breq	.+24     	; 0x1836 <GPIO_TogglePin+0x5e>
    181e:	5a c0       	rjmp	.+180    	; 0x18d4 <GPIO_TogglePin+0xfc>
    1820:	2b 81       	ldd	r18, Y+3	; 0x03
    1822:	3c 81       	ldd	r19, Y+4	; 0x04
    1824:	22 30       	cpi	r18, 0x02	; 2
    1826:	31 05       	cpc	r19, r1
    1828:	71 f1       	breq	.+92     	; 0x1886 <GPIO_TogglePin+0xae>
    182a:	8b 81       	ldd	r24, Y+3	; 0x03
    182c:	9c 81       	ldd	r25, Y+4	; 0x04
    182e:	83 30       	cpi	r24, 0x03	; 3
    1830:	91 05       	cpc	r25, r1
    1832:	e9 f1       	breq	.+122    	; 0x18ae <GPIO_TogglePin+0xd6>
    1834:	4f c0       	rjmp	.+158    	; 0x18d4 <GPIO_TogglePin+0xfc>
		{
		case PORTA_ID:
			TOGGLE_BIT(PORTA,pin_num);
    1836:	ab e3       	ldi	r26, 0x3B	; 59
    1838:	b0 e0       	ldi	r27, 0x00	; 0
    183a:	eb e3       	ldi	r30, 0x3B	; 59
    183c:	f0 e0       	ldi	r31, 0x00	; 0
    183e:	80 81       	ld	r24, Z
    1840:	48 2f       	mov	r20, r24
    1842:	8a 81       	ldd	r24, Y+2	; 0x02
    1844:	28 2f       	mov	r18, r24
    1846:	30 e0       	ldi	r19, 0x00	; 0
    1848:	81 e0       	ldi	r24, 0x01	; 1
    184a:	90 e0       	ldi	r25, 0x00	; 0
    184c:	02 2e       	mov	r0, r18
    184e:	02 c0       	rjmp	.+4      	; 0x1854 <GPIO_TogglePin+0x7c>
    1850:	88 0f       	add	r24, r24
    1852:	99 1f       	adc	r25, r25
    1854:	0a 94       	dec	r0
    1856:	e2 f7       	brpl	.-8      	; 0x1850 <GPIO_TogglePin+0x78>
    1858:	84 27       	eor	r24, r20
    185a:	8c 93       	st	X, r24
    185c:	3b c0       	rjmp	.+118    	; 0x18d4 <GPIO_TogglePin+0xfc>
			break;
		case PORTB_ID:
			TOGGLE_BIT(PORTB,pin_num);
    185e:	a8 e3       	ldi	r26, 0x38	; 56
    1860:	b0 e0       	ldi	r27, 0x00	; 0
    1862:	e8 e3       	ldi	r30, 0x38	; 56
    1864:	f0 e0       	ldi	r31, 0x00	; 0
    1866:	80 81       	ld	r24, Z
    1868:	48 2f       	mov	r20, r24
    186a:	8a 81       	ldd	r24, Y+2	; 0x02
    186c:	28 2f       	mov	r18, r24
    186e:	30 e0       	ldi	r19, 0x00	; 0
    1870:	81 e0       	ldi	r24, 0x01	; 1
    1872:	90 e0       	ldi	r25, 0x00	; 0
    1874:	02 2e       	mov	r0, r18
    1876:	02 c0       	rjmp	.+4      	; 0x187c <GPIO_TogglePin+0xa4>
    1878:	88 0f       	add	r24, r24
    187a:	99 1f       	adc	r25, r25
    187c:	0a 94       	dec	r0
    187e:	e2 f7       	brpl	.-8      	; 0x1878 <GPIO_TogglePin+0xa0>
    1880:	84 27       	eor	r24, r20
    1882:	8c 93       	st	X, r24
    1884:	27 c0       	rjmp	.+78     	; 0x18d4 <GPIO_TogglePin+0xfc>
			break;
		case PORTC_ID:
			TOGGLE_BIT(PORTC,pin_num);
    1886:	a5 e3       	ldi	r26, 0x35	; 53
    1888:	b0 e0       	ldi	r27, 0x00	; 0
    188a:	e5 e3       	ldi	r30, 0x35	; 53
    188c:	f0 e0       	ldi	r31, 0x00	; 0
    188e:	80 81       	ld	r24, Z
    1890:	48 2f       	mov	r20, r24
    1892:	8a 81       	ldd	r24, Y+2	; 0x02
    1894:	28 2f       	mov	r18, r24
    1896:	30 e0       	ldi	r19, 0x00	; 0
    1898:	81 e0       	ldi	r24, 0x01	; 1
    189a:	90 e0       	ldi	r25, 0x00	; 0
    189c:	02 2e       	mov	r0, r18
    189e:	02 c0       	rjmp	.+4      	; 0x18a4 <GPIO_TogglePin+0xcc>
    18a0:	88 0f       	add	r24, r24
    18a2:	99 1f       	adc	r25, r25
    18a4:	0a 94       	dec	r0
    18a6:	e2 f7       	brpl	.-8      	; 0x18a0 <GPIO_TogglePin+0xc8>
    18a8:	84 27       	eor	r24, r20
    18aa:	8c 93       	st	X, r24
    18ac:	13 c0       	rjmp	.+38     	; 0x18d4 <GPIO_TogglePin+0xfc>
			break;
		case PORTD_ID:

			TOGGLE_BIT(PORTD,pin_num);
    18ae:	a2 e3       	ldi	r26, 0x32	; 50
    18b0:	b0 e0       	ldi	r27, 0x00	; 0
    18b2:	e2 e3       	ldi	r30, 0x32	; 50
    18b4:	f0 e0       	ldi	r31, 0x00	; 0
    18b6:	80 81       	ld	r24, Z
    18b8:	48 2f       	mov	r20, r24
    18ba:	8a 81       	ldd	r24, Y+2	; 0x02
    18bc:	28 2f       	mov	r18, r24
    18be:	30 e0       	ldi	r19, 0x00	; 0
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	02 2e       	mov	r0, r18
    18c6:	02 c0       	rjmp	.+4      	; 0x18cc <GPIO_TogglePin+0xf4>
    18c8:	88 0f       	add	r24, r24
    18ca:	99 1f       	adc	r25, r25
    18cc:	0a 94       	dec	r0
    18ce:	e2 f7       	brpl	.-8      	; 0x18c8 <GPIO_TogglePin+0xf0>
    18d0:	84 27       	eor	r24, r20
    18d2:	8c 93       	st	X, r24
			break;
		default:
		    break;
		}
	}
}
    18d4:	0f 90       	pop	r0
    18d6:	0f 90       	pop	r0
    18d8:	0f 90       	pop	r0
    18da:	0f 90       	pop	r0
    18dc:	cf 91       	pop	r28
    18de:	df 91       	pop	r29
    18e0:	08 95       	ret

000018e2 <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    18e2:	df 93       	push	r29
    18e4:	cf 93       	push	r28
    18e6:	00 d0       	rcall	.+0      	; 0x18e8 <GPIO_readPin+0x6>
    18e8:	00 d0       	rcall	.+0      	; 0x18ea <GPIO_readPin+0x8>
    18ea:	0f 92       	push	r0
    18ec:	cd b7       	in	r28, 0x3d	; 61
    18ee:	de b7       	in	r29, 0x3e	; 62
    18f0:	8a 83       	std	Y+2, r24	; 0x02
    18f2:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    18f4:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    18f6:	8b 81       	ldd	r24, Y+3	; 0x03
    18f8:	88 30       	cpi	r24, 0x08	; 8
    18fa:	08 f0       	brcs	.+2      	; 0x18fe <GPIO_readPin+0x1c>
    18fc:	84 c0       	rjmp	.+264    	; 0x1a06 <GPIO_readPin+0x124>
    18fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1900:	84 30       	cpi	r24, 0x04	; 4
    1902:	08 f0       	brcs	.+2      	; 0x1906 <GPIO_readPin+0x24>
    1904:	80 c0       	rjmp	.+256    	; 0x1a06 <GPIO_readPin+0x124>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
    1906:	8a 81       	ldd	r24, Y+2	; 0x02
    1908:	28 2f       	mov	r18, r24
    190a:	30 e0       	ldi	r19, 0x00	; 0
    190c:	3d 83       	std	Y+5, r19	; 0x05
    190e:	2c 83       	std	Y+4, r18	; 0x04
    1910:	4c 81       	ldd	r20, Y+4	; 0x04
    1912:	5d 81       	ldd	r21, Y+5	; 0x05
    1914:	41 30       	cpi	r20, 0x01	; 1
    1916:	51 05       	cpc	r21, r1
    1918:	79 f1       	breq	.+94     	; 0x1978 <GPIO_readPin+0x96>
    191a:	8c 81       	ldd	r24, Y+4	; 0x04
    191c:	9d 81       	ldd	r25, Y+5	; 0x05
    191e:	82 30       	cpi	r24, 0x02	; 2
    1920:	91 05       	cpc	r25, r1
    1922:	34 f4       	brge	.+12     	; 0x1930 <GPIO_readPin+0x4e>
    1924:	2c 81       	ldd	r18, Y+4	; 0x04
    1926:	3d 81       	ldd	r19, Y+5	; 0x05
    1928:	21 15       	cp	r18, r1
    192a:	31 05       	cpc	r19, r1
    192c:	69 f0       	breq	.+26     	; 0x1948 <GPIO_readPin+0x66>
    192e:	6b c0       	rjmp	.+214    	; 0x1a06 <GPIO_readPin+0x124>
    1930:	4c 81       	ldd	r20, Y+4	; 0x04
    1932:	5d 81       	ldd	r21, Y+5	; 0x05
    1934:	42 30       	cpi	r20, 0x02	; 2
    1936:	51 05       	cpc	r21, r1
    1938:	b9 f1       	breq	.+110    	; 0x19a8 <GPIO_readPin+0xc6>
    193a:	8c 81       	ldd	r24, Y+4	; 0x04
    193c:	9d 81       	ldd	r25, Y+5	; 0x05
    193e:	83 30       	cpi	r24, 0x03	; 3
    1940:	91 05       	cpc	r25, r1
    1942:	09 f4       	brne	.+2      	; 0x1946 <GPIO_readPin+0x64>
    1944:	49 c0       	rjmp	.+146    	; 0x19d8 <GPIO_readPin+0xf6>
    1946:	5f c0       	rjmp	.+190    	; 0x1a06 <GPIO_readPin+0x124>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    1948:	e9 e3       	ldi	r30, 0x39	; 57
    194a:	f0 e0       	ldi	r31, 0x00	; 0
    194c:	80 81       	ld	r24, Z
    194e:	28 2f       	mov	r18, r24
    1950:	30 e0       	ldi	r19, 0x00	; 0
    1952:	8b 81       	ldd	r24, Y+3	; 0x03
    1954:	88 2f       	mov	r24, r24
    1956:	90 e0       	ldi	r25, 0x00	; 0
    1958:	a9 01       	movw	r20, r18
    195a:	02 c0       	rjmp	.+4      	; 0x1960 <GPIO_readPin+0x7e>
    195c:	55 95       	asr	r21
    195e:	47 95       	ror	r20
    1960:	8a 95       	dec	r24
    1962:	e2 f7       	brpl	.-8      	; 0x195c <GPIO_readPin+0x7a>
    1964:	ca 01       	movw	r24, r20
    1966:	81 70       	andi	r24, 0x01	; 1
    1968:	90 70       	andi	r25, 0x00	; 0
    196a:	88 23       	and	r24, r24
    196c:	19 f0       	breq	.+6      	; 0x1974 <GPIO_readPin+0x92>
			{
				pin_value = LOGIC_HIGH;
    196e:	81 e0       	ldi	r24, 0x01	; 1
    1970:	89 83       	std	Y+1, r24	; 0x01
    1972:	49 c0       	rjmp	.+146    	; 0x1a06 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    1974:	19 82       	std	Y+1, r1	; 0x01
    1976:	47 c0       	rjmp	.+142    	; 0x1a06 <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    1978:	e6 e3       	ldi	r30, 0x36	; 54
    197a:	f0 e0       	ldi	r31, 0x00	; 0
    197c:	80 81       	ld	r24, Z
    197e:	28 2f       	mov	r18, r24
    1980:	30 e0       	ldi	r19, 0x00	; 0
    1982:	8b 81       	ldd	r24, Y+3	; 0x03
    1984:	88 2f       	mov	r24, r24
    1986:	90 e0       	ldi	r25, 0x00	; 0
    1988:	a9 01       	movw	r20, r18
    198a:	02 c0       	rjmp	.+4      	; 0x1990 <GPIO_readPin+0xae>
    198c:	55 95       	asr	r21
    198e:	47 95       	ror	r20
    1990:	8a 95       	dec	r24
    1992:	e2 f7       	brpl	.-8      	; 0x198c <GPIO_readPin+0xaa>
    1994:	ca 01       	movw	r24, r20
    1996:	81 70       	andi	r24, 0x01	; 1
    1998:	90 70       	andi	r25, 0x00	; 0
    199a:	88 23       	and	r24, r24
    199c:	19 f0       	breq	.+6      	; 0x19a4 <GPIO_readPin+0xc2>
			{
				pin_value = LOGIC_HIGH;
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	89 83       	std	Y+1, r24	; 0x01
    19a2:	31 c0       	rjmp	.+98     	; 0x1a06 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    19a4:	19 82       	std	Y+1, r1	; 0x01
    19a6:	2f c0       	rjmp	.+94     	; 0x1a06 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    19a8:	e3 e3       	ldi	r30, 0x33	; 51
    19aa:	f0 e0       	ldi	r31, 0x00	; 0
    19ac:	80 81       	ld	r24, Z
    19ae:	28 2f       	mov	r18, r24
    19b0:	30 e0       	ldi	r19, 0x00	; 0
    19b2:	8b 81       	ldd	r24, Y+3	; 0x03
    19b4:	88 2f       	mov	r24, r24
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	a9 01       	movw	r20, r18
    19ba:	02 c0       	rjmp	.+4      	; 0x19c0 <GPIO_readPin+0xde>
    19bc:	55 95       	asr	r21
    19be:	47 95       	ror	r20
    19c0:	8a 95       	dec	r24
    19c2:	e2 f7       	brpl	.-8      	; 0x19bc <GPIO_readPin+0xda>
    19c4:	ca 01       	movw	r24, r20
    19c6:	81 70       	andi	r24, 0x01	; 1
    19c8:	90 70       	andi	r25, 0x00	; 0
    19ca:	88 23       	and	r24, r24
    19cc:	19 f0       	breq	.+6      	; 0x19d4 <GPIO_readPin+0xf2>
			{
				pin_value = LOGIC_HIGH;
    19ce:	81 e0       	ldi	r24, 0x01	; 1
    19d0:	89 83       	std	Y+1, r24	; 0x01
    19d2:	19 c0       	rjmp	.+50     	; 0x1a06 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    19d4:	19 82       	std	Y+1, r1	; 0x01
    19d6:	17 c0       	rjmp	.+46     	; 0x1a06 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    19d8:	e0 e3       	ldi	r30, 0x30	; 48
    19da:	f0 e0       	ldi	r31, 0x00	; 0
    19dc:	80 81       	ld	r24, Z
    19de:	28 2f       	mov	r18, r24
    19e0:	30 e0       	ldi	r19, 0x00	; 0
    19e2:	8b 81       	ldd	r24, Y+3	; 0x03
    19e4:	88 2f       	mov	r24, r24
    19e6:	90 e0       	ldi	r25, 0x00	; 0
    19e8:	a9 01       	movw	r20, r18
    19ea:	02 c0       	rjmp	.+4      	; 0x19f0 <GPIO_readPin+0x10e>
    19ec:	55 95       	asr	r21
    19ee:	47 95       	ror	r20
    19f0:	8a 95       	dec	r24
    19f2:	e2 f7       	brpl	.-8      	; 0x19ec <GPIO_readPin+0x10a>
    19f4:	ca 01       	movw	r24, r20
    19f6:	81 70       	andi	r24, 0x01	; 1
    19f8:	90 70       	andi	r25, 0x00	; 0
    19fa:	88 23       	and	r24, r24
    19fc:	19 f0       	breq	.+6      	; 0x1a04 <GPIO_readPin+0x122>
			{
				pin_value = LOGIC_HIGH;
    19fe:	81 e0       	ldi	r24, 0x01	; 1
    1a00:	89 83       	std	Y+1, r24	; 0x01
    1a02:	01 c0       	rjmp	.+2      	; 0x1a06 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    1a04:	19 82       	std	Y+1, r1	; 0x01
		default:
		            break;
		}
	}

	return pin_value;
    1a06:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a08:	0f 90       	pop	r0
    1a0a:	0f 90       	pop	r0
    1a0c:	0f 90       	pop	r0
    1a0e:	0f 90       	pop	r0
    1a10:	0f 90       	pop	r0
    1a12:	cf 91       	pop	r28
    1a14:	df 91       	pop	r29
    1a16:	08 95       	ret

00001a18 <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    1a18:	df 93       	push	r29
    1a1a:	cf 93       	push	r28
    1a1c:	00 d0       	rcall	.+0      	; 0x1a1e <GPIO_setupPortDirection+0x6>
    1a1e:	00 d0       	rcall	.+0      	; 0x1a20 <GPIO_setupPortDirection+0x8>
    1a20:	cd b7       	in	r28, 0x3d	; 61
    1a22:	de b7       	in	r29, 0x3e	; 62
    1a24:	89 83       	std	Y+1, r24	; 0x01
    1a26:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1a28:	89 81       	ldd	r24, Y+1	; 0x01
    1a2a:	84 30       	cpi	r24, 0x04	; 4
    1a2c:	90 f5       	brcc	.+100    	; 0x1a92 <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    1a2e:	89 81       	ldd	r24, Y+1	; 0x01
    1a30:	28 2f       	mov	r18, r24
    1a32:	30 e0       	ldi	r19, 0x00	; 0
    1a34:	3c 83       	std	Y+4, r19	; 0x04
    1a36:	2b 83       	std	Y+3, r18	; 0x03
    1a38:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a3c:	81 30       	cpi	r24, 0x01	; 1
    1a3e:	91 05       	cpc	r25, r1
    1a40:	d1 f0       	breq	.+52     	; 0x1a76 <GPIO_setupPortDirection+0x5e>
    1a42:	2b 81       	ldd	r18, Y+3	; 0x03
    1a44:	3c 81       	ldd	r19, Y+4	; 0x04
    1a46:	22 30       	cpi	r18, 0x02	; 2
    1a48:	31 05       	cpc	r19, r1
    1a4a:	2c f4       	brge	.+10     	; 0x1a56 <GPIO_setupPortDirection+0x3e>
    1a4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a50:	00 97       	sbiw	r24, 0x00	; 0
    1a52:	61 f0       	breq	.+24     	; 0x1a6c <GPIO_setupPortDirection+0x54>
    1a54:	1e c0       	rjmp	.+60     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
    1a56:	2b 81       	ldd	r18, Y+3	; 0x03
    1a58:	3c 81       	ldd	r19, Y+4	; 0x04
    1a5a:	22 30       	cpi	r18, 0x02	; 2
    1a5c:	31 05       	cpc	r19, r1
    1a5e:	81 f0       	breq	.+32     	; 0x1a80 <GPIO_setupPortDirection+0x68>
    1a60:	8b 81       	ldd	r24, Y+3	; 0x03
    1a62:	9c 81       	ldd	r25, Y+4	; 0x04
    1a64:	83 30       	cpi	r24, 0x03	; 3
    1a66:	91 05       	cpc	r25, r1
    1a68:	81 f0       	breq	.+32     	; 0x1a8a <GPIO_setupPortDirection+0x72>
    1a6a:	13 c0       	rjmp	.+38     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA = direction;
    1a6c:	ea e3       	ldi	r30, 0x3A	; 58
    1a6e:	f0 e0       	ldi	r31, 0x00	; 0
    1a70:	8a 81       	ldd	r24, Y+2	; 0x02
    1a72:	80 83       	st	Z, r24
    1a74:	0e c0       	rjmp	.+28     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    1a76:	e7 e3       	ldi	r30, 0x37	; 55
    1a78:	f0 e0       	ldi	r31, 0x00	; 0
    1a7a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a7c:	80 83       	st	Z, r24
    1a7e:	09 c0       	rjmp	.+18     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    1a80:	e4 e3       	ldi	r30, 0x34	; 52
    1a82:	f0 e0       	ldi	r31, 0x00	; 0
    1a84:	8a 81       	ldd	r24, Y+2	; 0x02
    1a86:	80 83       	st	Z, r24
    1a88:	04 c0       	rjmp	.+8      	; 0x1a92 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    1a8a:	e1 e3       	ldi	r30, 0x31	; 49
    1a8c:	f0 e0       	ldi	r31, 0x00	; 0
    1a8e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a90:	80 83       	st	Z, r24
			break;
		default:
		            break;
		}
	}
}
    1a92:	0f 90       	pop	r0
    1a94:	0f 90       	pop	r0
    1a96:	0f 90       	pop	r0
    1a98:	0f 90       	pop	r0
    1a9a:	cf 91       	pop	r28
    1a9c:	df 91       	pop	r29
    1a9e:	08 95       	ret

00001aa0 <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    1aa0:	df 93       	push	r29
    1aa2:	cf 93       	push	r28
    1aa4:	00 d0       	rcall	.+0      	; 0x1aa6 <GPIO_writePort+0x6>
    1aa6:	00 d0       	rcall	.+0      	; 0x1aa8 <GPIO_writePort+0x8>
    1aa8:	cd b7       	in	r28, 0x3d	; 61
    1aaa:	de b7       	in	r29, 0x3e	; 62
    1aac:	89 83       	std	Y+1, r24	; 0x01
    1aae:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1ab0:	89 81       	ldd	r24, Y+1	; 0x01
    1ab2:	84 30       	cpi	r24, 0x04	; 4
    1ab4:	90 f5       	brcc	.+100    	; 0x1b1a <GPIO_writePort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
    1ab6:	89 81       	ldd	r24, Y+1	; 0x01
    1ab8:	28 2f       	mov	r18, r24
    1aba:	30 e0       	ldi	r19, 0x00	; 0
    1abc:	3c 83       	std	Y+4, r19	; 0x04
    1abe:	2b 83       	std	Y+3, r18	; 0x03
    1ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac4:	81 30       	cpi	r24, 0x01	; 1
    1ac6:	91 05       	cpc	r25, r1
    1ac8:	d1 f0       	breq	.+52     	; 0x1afe <GPIO_writePort+0x5e>
    1aca:	2b 81       	ldd	r18, Y+3	; 0x03
    1acc:	3c 81       	ldd	r19, Y+4	; 0x04
    1ace:	22 30       	cpi	r18, 0x02	; 2
    1ad0:	31 05       	cpc	r19, r1
    1ad2:	2c f4       	brge	.+10     	; 0x1ade <GPIO_writePort+0x3e>
    1ad4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad8:	00 97       	sbiw	r24, 0x00	; 0
    1ada:	61 f0       	breq	.+24     	; 0x1af4 <GPIO_writePort+0x54>
    1adc:	1e c0       	rjmp	.+60     	; 0x1b1a <GPIO_writePort+0x7a>
    1ade:	2b 81       	ldd	r18, Y+3	; 0x03
    1ae0:	3c 81       	ldd	r19, Y+4	; 0x04
    1ae2:	22 30       	cpi	r18, 0x02	; 2
    1ae4:	31 05       	cpc	r19, r1
    1ae6:	81 f0       	breq	.+32     	; 0x1b08 <GPIO_writePort+0x68>
    1ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aea:	9c 81       	ldd	r25, Y+4	; 0x04
    1aec:	83 30       	cpi	r24, 0x03	; 3
    1aee:	91 05       	cpc	r25, r1
    1af0:	81 f0       	breq	.+32     	; 0x1b12 <GPIO_writePort+0x72>
    1af2:	13 c0       	rjmp	.+38     	; 0x1b1a <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
    1af4:	eb e3       	ldi	r30, 0x3B	; 59
    1af6:	f0 e0       	ldi	r31, 0x00	; 0
    1af8:	8a 81       	ldd	r24, Y+2	; 0x02
    1afa:	80 83       	st	Z, r24
    1afc:	0e c0       	rjmp	.+28     	; 0x1b1a <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    1afe:	e8 e3       	ldi	r30, 0x38	; 56
    1b00:	f0 e0       	ldi	r31, 0x00	; 0
    1b02:	8a 81       	ldd	r24, Y+2	; 0x02
    1b04:	80 83       	st	Z, r24
    1b06:	09 c0       	rjmp	.+18     	; 0x1b1a <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    1b08:	e5 e3       	ldi	r30, 0x35	; 53
    1b0a:	f0 e0       	ldi	r31, 0x00	; 0
    1b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b0e:	80 83       	st	Z, r24
    1b10:	04 c0       	rjmp	.+8      	; 0x1b1a <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    1b12:	e2 e3       	ldi	r30, 0x32	; 50
    1b14:	f0 e0       	ldi	r31, 0x00	; 0
    1b16:	8a 81       	ldd	r24, Y+2	; 0x02
    1b18:	80 83       	st	Z, r24
			break;
		default:
		            break;
		}
	}
}
    1b1a:	0f 90       	pop	r0
    1b1c:	0f 90       	pop	r0
    1b1e:	0f 90       	pop	r0
    1b20:	0f 90       	pop	r0
    1b22:	cf 91       	pop	r28
    1b24:	df 91       	pop	r29
    1b26:	08 95       	ret

00001b28 <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    1b28:	df 93       	push	r29
    1b2a:	cf 93       	push	r28
    1b2c:	00 d0       	rcall	.+0      	; 0x1b2e <GPIO_readPort+0x6>
    1b2e:	00 d0       	rcall	.+0      	; 0x1b30 <GPIO_readPort+0x8>
    1b30:	cd b7       	in	r28, 0x3d	; 61
    1b32:	de b7       	in	r29, 0x3e	; 62
    1b34:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    1b36:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1b38:	8a 81       	ldd	r24, Y+2	; 0x02
    1b3a:	84 30       	cpi	r24, 0x04	; 4
    1b3c:	90 f5       	brcc	.+100    	; 0x1ba2 <GPIO_readPort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
    1b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b40:	28 2f       	mov	r18, r24
    1b42:	30 e0       	ldi	r19, 0x00	; 0
    1b44:	3c 83       	std	Y+4, r19	; 0x04
    1b46:	2b 83       	std	Y+3, r18	; 0x03
    1b48:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b4c:	81 30       	cpi	r24, 0x01	; 1
    1b4e:	91 05       	cpc	r25, r1
    1b50:	d1 f0       	breq	.+52     	; 0x1b86 <GPIO_readPort+0x5e>
    1b52:	2b 81       	ldd	r18, Y+3	; 0x03
    1b54:	3c 81       	ldd	r19, Y+4	; 0x04
    1b56:	22 30       	cpi	r18, 0x02	; 2
    1b58:	31 05       	cpc	r19, r1
    1b5a:	2c f4       	brge	.+10     	; 0x1b66 <GPIO_readPort+0x3e>
    1b5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b60:	00 97       	sbiw	r24, 0x00	; 0
    1b62:	61 f0       	breq	.+24     	; 0x1b7c <GPIO_readPort+0x54>
    1b64:	1e c0       	rjmp	.+60     	; 0x1ba2 <GPIO_readPort+0x7a>
    1b66:	2b 81       	ldd	r18, Y+3	; 0x03
    1b68:	3c 81       	ldd	r19, Y+4	; 0x04
    1b6a:	22 30       	cpi	r18, 0x02	; 2
    1b6c:	31 05       	cpc	r19, r1
    1b6e:	81 f0       	breq	.+32     	; 0x1b90 <GPIO_readPort+0x68>
    1b70:	8b 81       	ldd	r24, Y+3	; 0x03
    1b72:	9c 81       	ldd	r25, Y+4	; 0x04
    1b74:	83 30       	cpi	r24, 0x03	; 3
    1b76:	91 05       	cpc	r25, r1
    1b78:	81 f0       	breq	.+32     	; 0x1b9a <GPIO_readPort+0x72>
    1b7a:	13 c0       	rjmp	.+38     	; 0x1ba2 <GPIO_readPort+0x7a>
		{
		case PORTA_ID:
			value = PINA;
    1b7c:	e9 e3       	ldi	r30, 0x39	; 57
    1b7e:	f0 e0       	ldi	r31, 0x00	; 0
    1b80:	80 81       	ld	r24, Z
    1b82:	89 83       	std	Y+1, r24	; 0x01
    1b84:	0e c0       	rjmp	.+28     	; 0x1ba2 <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    1b86:	e6 e3       	ldi	r30, 0x36	; 54
    1b88:	f0 e0       	ldi	r31, 0x00	; 0
    1b8a:	80 81       	ld	r24, Z
    1b8c:	89 83       	std	Y+1, r24	; 0x01
    1b8e:	09 c0       	rjmp	.+18     	; 0x1ba2 <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    1b90:	e3 e3       	ldi	r30, 0x33	; 51
    1b92:	f0 e0       	ldi	r31, 0x00	; 0
    1b94:	80 81       	ld	r24, Z
    1b96:	89 83       	std	Y+1, r24	; 0x01
    1b98:	04 c0       	rjmp	.+8      	; 0x1ba2 <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    1b9a:	e0 e3       	ldi	r30, 0x30	; 48
    1b9c:	f0 e0       	ldi	r31, 0x00	; 0
    1b9e:	80 81       	ld	r24, Z
    1ba0:	89 83       	std	Y+1, r24	; 0x01
		default:
		            break;
		}
	}

	return value;
    1ba2:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ba4:	0f 90       	pop	r0
    1ba6:	0f 90       	pop	r0
    1ba8:	0f 90       	pop	r0
    1baa:	0f 90       	pop	r0
    1bac:	cf 91       	pop	r28
    1bae:	df 91       	pop	r29
    1bb0:	08 95       	ret

00001bb2 <Timer_RTOS_LED_Blink_AVR323>:





void Timer_RTOS_LED_Blink_AVR323(void){
    1bb2:	0f 93       	push	r16
    1bb4:	1f 93       	push	r17
    1bb6:	df 93       	push	r29
    1bb8:	cf 93       	push	r28
    1bba:	00 d0       	rcall	.+0      	; 0x1bbc <Timer_RTOS_LED_Blink_AVR323+0xa>
    1bbc:	00 d0       	rcall	.+0      	; 0x1bbe <Timer_RTOS_LED_Blink_AVR323+0xc>
    1bbe:	00 d0       	rcall	.+0      	; 0x1bc0 <Timer_RTOS_LED_Blink_AVR323+0xe>
    1bc0:	cd b7       	in	r28, 0x3d	; 61
    1bc2:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPortDirection(PORTC_ID, PORT_OUTPUT);
    1bc4:	82 e0       	ldi	r24, 0x02	; 2
    1bc6:	6f ef       	ldi	r22, 0xFF	; 255
    1bc8:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <GPIO_setupPortDirection>
	TimerHandle_t xTimer1 = xTimerCreate("timer1",100,pdTRUE,NULL,Task1_Func_timer);
    1bcc:	80 e6       	ldi	r24, 0x60	; 96
    1bce:	90 e0       	ldi	r25, 0x00	; 0
    1bd0:	e4 e4       	ldi	r30, 0x44	; 68
    1bd2:	fe e0       	ldi	r31, 0x0E	; 14
    1bd4:	64 e6       	ldi	r22, 0x64	; 100
    1bd6:	70 e0       	ldi	r23, 0x00	; 0
    1bd8:	41 e0       	ldi	r20, 0x01	; 1
    1bda:	20 e0       	ldi	r18, 0x00	; 0
    1bdc:	30 e0       	ldi	r19, 0x00	; 0
    1bde:	8f 01       	movw	r16, r30
    1be0:	0e 94 98 36 	call	0x6d30	; 0x6d30 <xTimerCreate>
    1be4:	9e 83       	std	Y+6, r25	; 0x06
    1be6:	8d 83       	std	Y+5, r24	; 0x05
	TimerHandle_t xTimer2 = xTimerCreate("timer2",200,pdTRUE,NULL,Task2_Func_timer);
    1be8:	87 e6       	ldi	r24, 0x67	; 103
    1bea:	90 e0       	ldi	r25, 0x00	; 0
    1bec:	e4 e5       	ldi	r30, 0x54	; 84
    1bee:	fe e0       	ldi	r31, 0x0E	; 14
    1bf0:	68 ec       	ldi	r22, 0xC8	; 200
    1bf2:	70 e0       	ldi	r23, 0x00	; 0
    1bf4:	41 e0       	ldi	r20, 0x01	; 1
    1bf6:	20 e0       	ldi	r18, 0x00	; 0
    1bf8:	30 e0       	ldi	r19, 0x00	; 0
    1bfa:	8f 01       	movw	r16, r30
    1bfc:	0e 94 98 36 	call	0x6d30	; 0x6d30 <xTimerCreate>
    1c00:	9c 83       	std	Y+4, r25	; 0x04
    1c02:	8b 83       	std	Y+3, r24	; 0x03
	TimerHandle_t xTimer3 = xTimerCreate("timer3",100,pdTRUE,NULL,Task3_Func_timer);
    1c04:	8e e6       	ldi	r24, 0x6E	; 110
    1c06:	90 e0       	ldi	r25, 0x00	; 0
    1c08:	e4 e6       	ldi	r30, 0x64	; 100
    1c0a:	fe e0       	ldi	r31, 0x0E	; 14
    1c0c:	64 e6       	ldi	r22, 0x64	; 100
    1c0e:	70 e0       	ldi	r23, 0x00	; 0
    1c10:	41 e0       	ldi	r20, 0x01	; 1
    1c12:	20 e0       	ldi	r18, 0x00	; 0
    1c14:	30 e0       	ldi	r19, 0x00	; 0
    1c16:	8f 01       	movw	r16, r30
    1c18:	0e 94 98 36 	call	0x6d30	; 0x6d30 <xTimerCreate>
    1c1c:	9a 83       	std	Y+2, r25	; 0x02
    1c1e:	89 83       	std	Y+1, r24	; 0x01


	xTimerStart(xTimer1, 10);
    1c20:	0e 94 2c 27 	call	0x4e58	; 0x4e58 <xTaskGetTickCount>
    1c24:	9c 01       	movw	r18, r24
    1c26:	8d 81       	ldd	r24, Y+5	; 0x05
    1c28:	9e 81       	ldd	r25, Y+6	; 0x06
    1c2a:	61 e0       	ldi	r22, 0x01	; 1
    1c2c:	a9 01       	movw	r20, r18
    1c2e:	20 e0       	ldi	r18, 0x00	; 0
    1c30:	30 e0       	ldi	r19, 0x00	; 0
    1c32:	0a e0       	ldi	r16, 0x0A	; 10
    1c34:	10 e0       	ldi	r17, 0x00	; 0
    1c36:	0e 94 2a 37 	call	0x6e54	; 0x6e54 <xTimerGenericCommand>
	xTimerStart(xTimer2, 30);
    1c3a:	0e 94 2c 27 	call	0x4e58	; 0x4e58 <xTaskGetTickCount>
    1c3e:	9c 01       	movw	r18, r24
    1c40:	8b 81       	ldd	r24, Y+3	; 0x03
    1c42:	9c 81       	ldd	r25, Y+4	; 0x04
    1c44:	61 e0       	ldi	r22, 0x01	; 1
    1c46:	a9 01       	movw	r20, r18
    1c48:	20 e0       	ldi	r18, 0x00	; 0
    1c4a:	30 e0       	ldi	r19, 0x00	; 0
    1c4c:	0e e1       	ldi	r16, 0x1E	; 30
    1c4e:	10 e0       	ldi	r17, 0x00	; 0
    1c50:	0e 94 2a 37 	call	0x6e54	; 0x6e54 <xTimerGenericCommand>
	xTimerStart(xTimer3, 100);
    1c54:	0e 94 2c 27 	call	0x4e58	; 0x4e58 <xTaskGetTickCount>
    1c58:	9c 01       	movw	r18, r24
    1c5a:	89 81       	ldd	r24, Y+1	; 0x01
    1c5c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c5e:	61 e0       	ldi	r22, 0x01	; 1
    1c60:	a9 01       	movw	r20, r18
    1c62:	20 e0       	ldi	r18, 0x00	; 0
    1c64:	30 e0       	ldi	r19, 0x00	; 0
    1c66:	04 e6       	ldi	r16, 0x64	; 100
    1c68:	10 e0       	ldi	r17, 0x00	; 0
    1c6a:	0e 94 2a 37 	call	0x6e54	; 0x6e54 <xTimerGenericCommand>
	vTaskStartScheduler();
    1c6e:	0e 94 89 25 	call	0x4b12	; 0x4b12 <vTaskStartScheduler>
}
    1c72:	26 96       	adiw	r28, 0x06	; 6
    1c74:	0f b6       	in	r0, 0x3f	; 63
    1c76:	f8 94       	cli
    1c78:	de bf       	out	0x3e, r29	; 62
    1c7a:	0f be       	out	0x3f, r0	; 63
    1c7c:	cd bf       	out	0x3d, r28	; 61
    1c7e:	cf 91       	pop	r28
    1c80:	df 91       	pop	r29
    1c82:	1f 91       	pop	r17
    1c84:	0f 91       	pop	r16
    1c86:	08 95       	ret

00001c88 <Task1_Func_timer>:


void Task1_Func_timer(TimerHandle_t xtimer )
{
    1c88:	df 93       	push	r29
    1c8a:	cf 93       	push	r28
    1c8c:	00 d0       	rcall	.+0      	; 0x1c8e <Task1_Func_timer+0x6>
    1c8e:	cd b7       	in	r28, 0x3d	; 61
    1c90:	de b7       	in	r29, 0x3e	; 62
    1c92:	9a 83       	std	Y+2, r25	; 0x02
    1c94:	89 83       	std	Y+1, r24	; 0x01

		GPIO_TogglePin(PORTC_ID,PIN1_ID);
    1c96:	82 e0       	ldi	r24, 0x02	; 2
    1c98:	61 e0       	ldi	r22, 0x01	; 1
    1c9a:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <GPIO_TogglePin>
}
    1c9e:	0f 90       	pop	r0
    1ca0:	0f 90       	pop	r0
    1ca2:	cf 91       	pop	r28
    1ca4:	df 91       	pop	r29
    1ca6:	08 95       	ret

00001ca8 <Task2_Func_timer>:

void Task2_Func_timer(TimerHandle_t xtimer)
{
    1ca8:	df 93       	push	r29
    1caa:	cf 93       	push	r28
    1cac:	00 d0       	rcall	.+0      	; 0x1cae <Task2_Func_timer+0x6>
    1cae:	cd b7       	in	r28, 0x3d	; 61
    1cb0:	de b7       	in	r29, 0x3e	; 62
    1cb2:	9a 83       	std	Y+2, r25	; 0x02
    1cb4:	89 83       	std	Y+1, r24	; 0x01

		GPIO_TogglePin(PORTC_ID,PIN4_ID);
    1cb6:	82 e0       	ldi	r24, 0x02	; 2
    1cb8:	64 e0       	ldi	r22, 0x04	; 4
    1cba:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <GPIO_TogglePin>
}
    1cbe:	0f 90       	pop	r0
    1cc0:	0f 90       	pop	r0
    1cc2:	cf 91       	pop	r28
    1cc4:	df 91       	pop	r29
    1cc6:	08 95       	ret

00001cc8 <Task3_Func_timer>:


void Task3_Func_timer(TimerHandle_t xtimer )
{
    1cc8:	df 93       	push	r29
    1cca:	cf 93       	push	r28
    1ccc:	00 d0       	rcall	.+0      	; 0x1cce <Task3_Func_timer+0x6>
    1cce:	cd b7       	in	r28, 0x3d	; 61
    1cd0:	de b7       	in	r29, 0x3e	; 62
    1cd2:	9a 83       	std	Y+2, r25	; 0x02
    1cd4:	89 83       	std	Y+1, r24	; 0x01

		GPIO_TogglePin(PORTC_ID,PIN7_ID);
    1cd6:	82 e0       	ldi	r24, 0x02	; 2
    1cd8:	67 e0       	ldi	r22, 0x07	; 7
    1cda:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <GPIO_TogglePin>

}
    1cde:	0f 90       	pop	r0
    1ce0:	0f 90       	pop	r0
    1ce2:	cf 91       	pop	r28
    1ce4:	df 91       	pop	r29
    1ce6:	08 95       	ret

00001ce8 <main>:


int main(void)
{
    1ce8:	df 93       	push	r29
    1cea:	cf 93       	push	r28
    1cec:	cd b7       	in	r28, 0x3d	; 61
    1cee:	de b7       	in	r29, 0x3e	; 62

	Timer_RTOS_LED_Blink_AVR323();
    1cf0:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <Timer_RTOS_LED_Blink_AVR323>
    1cf4:	ff cf       	rjmp	.-2      	; 0x1cf4 <main+0xc>

00001cf6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    1cf6:	df 93       	push	r29
    1cf8:	cf 93       	push	r28
    1cfa:	00 d0       	rcall	.+0      	; 0x1cfc <pvPortMalloc+0x6>
    1cfc:	00 d0       	rcall	.+0      	; 0x1cfe <pvPortMalloc+0x8>
    1cfe:	cd b7       	in	r28, 0x3d	; 61
    1d00:	de b7       	in	r29, 0x3e	; 62
    1d02:	9c 83       	std	Y+4, r25	; 0x04
    1d04:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
    1d06:	1a 82       	std	Y+2, r1	; 0x02
    1d08:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
    1d0a:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    1d0e:	80 91 30 01 	lds	r24, 0x0130
    1d12:	90 91 31 01 	lds	r25, 0x0131
    1d16:	00 97       	sbiw	r24, 0x00	; 0
    1d18:	31 f4       	brne	.+12     	; 0x1d26 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1d1a:	82 e3       	ldi	r24, 0x32	; 50
    1d1c:	91 e0       	ldi	r25, 0x01	; 1
    1d1e:	90 93 31 01 	sts	0x0131, r25
    1d22:	80 93 30 01 	sts	0x0130, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
    1d26:	8b 81       	ldd	r24, Y+3	; 0x03
    1d28:	9c 81       	ldd	r25, Y+4	; 0x04
    1d2a:	00 97       	sbiw	r24, 0x00	; 0
    1d2c:	99 f1       	breq	.+102    	; 0x1d94 <pvPortMalloc+0x9e>
    1d2e:	80 91 2e 01 	lds	r24, 0x012E
    1d32:	90 91 2f 01 	lds	r25, 0x012F
    1d36:	2b 81       	ldd	r18, Y+3	; 0x03
    1d38:	3c 81       	ldd	r19, Y+4	; 0x04
    1d3a:	82 0f       	add	r24, r18
    1d3c:	93 1f       	adc	r25, r19
    1d3e:	25 e0       	ldi	r18, 0x05	; 5
    1d40:	8b 3d       	cpi	r24, 0xDB	; 219
    1d42:	92 07       	cpc	r25, r18
    1d44:	38 f5       	brcc	.+78     	; 0x1d94 <pvPortMalloc+0x9e>
    1d46:	20 91 2e 01 	lds	r18, 0x012E
    1d4a:	30 91 2f 01 	lds	r19, 0x012F
    1d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d50:	9c 81       	ldd	r25, Y+4	; 0x04
    1d52:	28 0f       	add	r18, r24
    1d54:	39 1f       	adc	r19, r25
    1d56:	80 91 2e 01 	lds	r24, 0x012E
    1d5a:	90 91 2f 01 	lds	r25, 0x012F
    1d5e:	82 17       	cp	r24, r18
    1d60:	93 07       	cpc	r25, r19
    1d62:	c0 f4       	brcc	.+48     	; 0x1d94 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    1d64:	20 91 30 01 	lds	r18, 0x0130
    1d68:	30 91 31 01 	lds	r19, 0x0131
    1d6c:	80 91 2e 01 	lds	r24, 0x012E
    1d70:	90 91 2f 01 	lds	r25, 0x012F
    1d74:	82 0f       	add	r24, r18
    1d76:	93 1f       	adc	r25, r19
    1d78:	9a 83       	std	Y+2, r25	; 0x02
    1d7a:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
    1d7c:	20 91 2e 01 	lds	r18, 0x012E
    1d80:	30 91 2f 01 	lds	r19, 0x012F
    1d84:	8b 81       	ldd	r24, Y+3	; 0x03
    1d86:	9c 81       	ldd	r25, Y+4	; 0x04
    1d88:	82 0f       	add	r24, r18
    1d8a:	93 1f       	adc	r25, r19
    1d8c:	90 93 2f 01 	sts	0x012F, r25
    1d90:	80 93 2e 01 	sts	0x012E, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    1d94:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
    1d98:	89 81       	ldd	r24, Y+1	; 0x01
    1d9a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1d9c:	0f 90       	pop	r0
    1d9e:	0f 90       	pop	r0
    1da0:	0f 90       	pop	r0
    1da2:	0f 90       	pop	r0
    1da4:	cf 91       	pop	r28
    1da6:	df 91       	pop	r29
    1da8:	08 95       	ret

00001daa <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    1daa:	df 93       	push	r29
    1dac:	cf 93       	push	r28
    1dae:	00 d0       	rcall	.+0      	; 0x1db0 <vPortFree+0x6>
    1db0:	cd b7       	in	r28, 0x3d	; 61
    1db2:	de b7       	in	r29, 0x3e	; 62
    1db4:	9a 83       	std	Y+2, r25	; 0x02
    1db6:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
    1db8:	0f 90       	pop	r0
    1dba:	0f 90       	pop	r0
    1dbc:	cf 91       	pop	r28
    1dbe:	df 91       	pop	r29
    1dc0:	08 95       	ret

00001dc2 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1dc2:	df 93       	push	r29
    1dc4:	cf 93       	push	r28
    1dc6:	cd b7       	in	r28, 0x3d	; 61
    1dc8:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
    1dca:	10 92 2f 01 	sts	0x012F, r1
    1dce:	10 92 2e 01 	sts	0x012E, r1
}
    1dd2:	cf 91       	pop	r28
    1dd4:	df 91       	pop	r29
    1dd6:	08 95       	ret

00001dd8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1dd8:	df 93       	push	r29
    1dda:	cf 93       	push	r28
    1ddc:	cd b7       	in	r28, 0x3d	; 61
    1dde:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1de0:	20 91 2e 01 	lds	r18, 0x012E
    1de4:	30 91 2f 01 	lds	r19, 0x012F
    1de8:	8b ed       	ldi	r24, 0xDB	; 219
    1dea:	95 e0       	ldi	r25, 0x05	; 5
    1dec:	82 1b       	sub	r24, r18
    1dee:	93 0b       	sbc	r25, r19
}
    1df0:	cf 91       	pop	r28
    1df2:	df 91       	pop	r29
    1df4:	08 95       	ret

00001df6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1df6:	df 93       	push	r29
    1df8:	cf 93       	push	r28
    1dfa:	cd b7       	in	r28, 0x3d	; 61
    1dfc:	de b7       	in	r29, 0x3e	; 62
    1dfe:	28 97       	sbiw	r28, 0x08	; 8
    1e00:	0f b6       	in	r0, 0x3f	; 63
    1e02:	f8 94       	cli
    1e04:	de bf       	out	0x3e, r29	; 62
    1e06:	0f be       	out	0x3f, r0	; 63
    1e08:	cd bf       	out	0x3d, r28	; 61
    1e0a:	9c 83       	std	Y+4, r25	; 0x04
    1e0c:	8b 83       	std	Y+3, r24	; 0x03
    1e0e:	7e 83       	std	Y+6, r23	; 0x06
    1e10:	6d 83       	std	Y+5, r22	; 0x05
    1e12:	58 87       	std	Y+8, r21	; 0x08
    1e14:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1e16:	eb 81       	ldd	r30, Y+3	; 0x03
    1e18:	fc 81       	ldd	r31, Y+4	; 0x04
    1e1a:	81 e1       	ldi	r24, 0x11	; 17
    1e1c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e20:	9c 81       	ldd	r25, Y+4	; 0x04
    1e22:	01 97       	sbiw	r24, 0x01	; 1
    1e24:	9c 83       	std	Y+4, r25	; 0x04
    1e26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1e28:	eb 81       	ldd	r30, Y+3	; 0x03
    1e2a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e2c:	82 e2       	ldi	r24, 0x22	; 34
    1e2e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e30:	8b 81       	ldd	r24, Y+3	; 0x03
    1e32:	9c 81       	ldd	r25, Y+4	; 0x04
    1e34:	01 97       	sbiw	r24, 0x01	; 1
    1e36:	9c 83       	std	Y+4, r25	; 0x04
    1e38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1e3a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e3c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e3e:	83 e3       	ldi	r24, 0x33	; 51
    1e40:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e42:	8b 81       	ldd	r24, Y+3	; 0x03
    1e44:	9c 81       	ldd	r25, Y+4	; 0x04
    1e46:	01 97       	sbiw	r24, 0x01	; 1
    1e48:	9c 83       	std	Y+4, r25	; 0x04
    1e4a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1e4c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e4e:	9e 81       	ldd	r25, Y+6	; 0x06
    1e50:	9a 83       	std	Y+2, r25	; 0x02
    1e52:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1e54:	89 81       	ldd	r24, Y+1	; 0x01
    1e56:	eb 81       	ldd	r30, Y+3	; 0x03
    1e58:	fc 81       	ldd	r31, Y+4	; 0x04
    1e5a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e60:	01 97       	sbiw	r24, 0x01	; 1
    1e62:	9c 83       	std	Y+4, r25	; 0x04
    1e64:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1e66:	89 81       	ldd	r24, Y+1	; 0x01
    1e68:	9a 81       	ldd	r25, Y+2	; 0x02
    1e6a:	89 2f       	mov	r24, r25
    1e6c:	99 27       	eor	r25, r25
    1e6e:	9a 83       	std	Y+2, r25	; 0x02
    1e70:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1e72:	89 81       	ldd	r24, Y+1	; 0x01
    1e74:	eb 81       	ldd	r30, Y+3	; 0x03
    1e76:	fc 81       	ldd	r31, Y+4	; 0x04
    1e78:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e7e:	01 97       	sbiw	r24, 0x01	; 1
    1e80:	9c 83       	std	Y+4, r25	; 0x04
    1e82:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1e84:	eb 81       	ldd	r30, Y+3	; 0x03
    1e86:	fc 81       	ldd	r31, Y+4	; 0x04
    1e88:	10 82       	st	Z, r1
	pxTopOfStack--;
    1e8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e8c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e8e:	01 97       	sbiw	r24, 0x01	; 1
    1e90:	9c 83       	std	Y+4, r25	; 0x04
    1e92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1e94:	eb 81       	ldd	r30, Y+3	; 0x03
    1e96:	fc 81       	ldd	r31, Y+4	; 0x04
    1e98:	80 e8       	ldi	r24, 0x80	; 128
    1e9a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1ea0:	01 97       	sbiw	r24, 0x01	; 1
    1ea2:	9c 83       	std	Y+4, r25	; 0x04
    1ea4:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1ea6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ea8:	fc 81       	ldd	r31, Y+4	; 0x04
    1eaa:	10 82       	st	Z, r1
	pxTopOfStack--;
    1eac:	8b 81       	ldd	r24, Y+3	; 0x03
    1eae:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb0:	01 97       	sbiw	r24, 0x01	; 1
    1eb2:	9c 83       	std	Y+4, r25	; 0x04
    1eb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1eb6:	eb 81       	ldd	r30, Y+3	; 0x03
    1eb8:	fc 81       	ldd	r31, Y+4	; 0x04
    1eba:	82 e0       	ldi	r24, 0x02	; 2
    1ebc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec2:	01 97       	sbiw	r24, 0x01	; 1
    1ec4:	9c 83       	std	Y+4, r25	; 0x04
    1ec6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1ec8:	eb 81       	ldd	r30, Y+3	; 0x03
    1eca:	fc 81       	ldd	r31, Y+4	; 0x04
    1ecc:	83 e0       	ldi	r24, 0x03	; 3
    1ece:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ed0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ed2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ed4:	01 97       	sbiw	r24, 0x01	; 1
    1ed6:	9c 83       	std	Y+4, r25	; 0x04
    1ed8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1eda:	eb 81       	ldd	r30, Y+3	; 0x03
    1edc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ede:	84 e0       	ldi	r24, 0x04	; 4
    1ee0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ee6:	01 97       	sbiw	r24, 0x01	; 1
    1ee8:	9c 83       	std	Y+4, r25	; 0x04
    1eea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1eec:	eb 81       	ldd	r30, Y+3	; 0x03
    1eee:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef0:	85 e0       	ldi	r24, 0x05	; 5
    1ef2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ef4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef8:	01 97       	sbiw	r24, 0x01	; 1
    1efa:	9c 83       	std	Y+4, r25	; 0x04
    1efc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1efe:	eb 81       	ldd	r30, Y+3	; 0x03
    1f00:	fc 81       	ldd	r31, Y+4	; 0x04
    1f02:	86 e0       	ldi	r24, 0x06	; 6
    1f04:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f06:	8b 81       	ldd	r24, Y+3	; 0x03
    1f08:	9c 81       	ldd	r25, Y+4	; 0x04
    1f0a:	01 97       	sbiw	r24, 0x01	; 1
    1f0c:	9c 83       	std	Y+4, r25	; 0x04
    1f0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1f10:	eb 81       	ldd	r30, Y+3	; 0x03
    1f12:	fc 81       	ldd	r31, Y+4	; 0x04
    1f14:	87 e0       	ldi	r24, 0x07	; 7
    1f16:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f18:	8b 81       	ldd	r24, Y+3	; 0x03
    1f1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f1c:	01 97       	sbiw	r24, 0x01	; 1
    1f1e:	9c 83       	std	Y+4, r25	; 0x04
    1f20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1f22:	eb 81       	ldd	r30, Y+3	; 0x03
    1f24:	fc 81       	ldd	r31, Y+4	; 0x04
    1f26:	88 e0       	ldi	r24, 0x08	; 8
    1f28:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f2e:	01 97       	sbiw	r24, 0x01	; 1
    1f30:	9c 83       	std	Y+4, r25	; 0x04
    1f32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1f34:	eb 81       	ldd	r30, Y+3	; 0x03
    1f36:	fc 81       	ldd	r31, Y+4	; 0x04
    1f38:	89 e0       	ldi	r24, 0x09	; 9
    1f3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f40:	01 97       	sbiw	r24, 0x01	; 1
    1f42:	9c 83       	std	Y+4, r25	; 0x04
    1f44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1f46:	eb 81       	ldd	r30, Y+3	; 0x03
    1f48:	fc 81       	ldd	r31, Y+4	; 0x04
    1f4a:	80 e1       	ldi	r24, 0x10	; 16
    1f4c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f50:	9c 81       	ldd	r25, Y+4	; 0x04
    1f52:	01 97       	sbiw	r24, 0x01	; 1
    1f54:	9c 83       	std	Y+4, r25	; 0x04
    1f56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1f58:	eb 81       	ldd	r30, Y+3	; 0x03
    1f5a:	fc 81       	ldd	r31, Y+4	; 0x04
    1f5c:	81 e1       	ldi	r24, 0x11	; 17
    1f5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f60:	8b 81       	ldd	r24, Y+3	; 0x03
    1f62:	9c 81       	ldd	r25, Y+4	; 0x04
    1f64:	01 97       	sbiw	r24, 0x01	; 1
    1f66:	9c 83       	std	Y+4, r25	; 0x04
    1f68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1f6a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f6c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f6e:	82 e1       	ldi	r24, 0x12	; 18
    1f70:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f72:	8b 81       	ldd	r24, Y+3	; 0x03
    1f74:	9c 81       	ldd	r25, Y+4	; 0x04
    1f76:	01 97       	sbiw	r24, 0x01	; 1
    1f78:	9c 83       	std	Y+4, r25	; 0x04
    1f7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1f7c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f7e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f80:	83 e1       	ldi	r24, 0x13	; 19
    1f82:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f84:	8b 81       	ldd	r24, Y+3	; 0x03
    1f86:	9c 81       	ldd	r25, Y+4	; 0x04
    1f88:	01 97       	sbiw	r24, 0x01	; 1
    1f8a:	9c 83       	std	Y+4, r25	; 0x04
    1f8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1f8e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f90:	fc 81       	ldd	r31, Y+4	; 0x04
    1f92:	84 e1       	ldi	r24, 0x14	; 20
    1f94:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f96:	8b 81       	ldd	r24, Y+3	; 0x03
    1f98:	9c 81       	ldd	r25, Y+4	; 0x04
    1f9a:	01 97       	sbiw	r24, 0x01	; 1
    1f9c:	9c 83       	std	Y+4, r25	; 0x04
    1f9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1fa0:	eb 81       	ldd	r30, Y+3	; 0x03
    1fa2:	fc 81       	ldd	r31, Y+4	; 0x04
    1fa4:	85 e1       	ldi	r24, 0x15	; 21
    1fa6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fa8:	8b 81       	ldd	r24, Y+3	; 0x03
    1faa:	9c 81       	ldd	r25, Y+4	; 0x04
    1fac:	01 97       	sbiw	r24, 0x01	; 1
    1fae:	9c 83       	std	Y+4, r25	; 0x04
    1fb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1fb2:	eb 81       	ldd	r30, Y+3	; 0x03
    1fb4:	fc 81       	ldd	r31, Y+4	; 0x04
    1fb6:	86 e1       	ldi	r24, 0x16	; 22
    1fb8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fba:	8b 81       	ldd	r24, Y+3	; 0x03
    1fbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1fbe:	01 97       	sbiw	r24, 0x01	; 1
    1fc0:	9c 83       	std	Y+4, r25	; 0x04
    1fc2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1fc4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fc6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fc8:	87 e1       	ldi	r24, 0x17	; 23
    1fca:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fcc:	8b 81       	ldd	r24, Y+3	; 0x03
    1fce:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd0:	01 97       	sbiw	r24, 0x01	; 1
    1fd2:	9c 83       	std	Y+4, r25	; 0x04
    1fd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1fd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fda:	88 e1       	ldi	r24, 0x18	; 24
    1fdc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fde:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe0:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe2:	01 97       	sbiw	r24, 0x01	; 1
    1fe4:	9c 83       	std	Y+4, r25	; 0x04
    1fe6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1fe8:	eb 81       	ldd	r30, Y+3	; 0x03
    1fea:	fc 81       	ldd	r31, Y+4	; 0x04
    1fec:	89 e1       	ldi	r24, 0x19	; 25
    1fee:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ff0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff4:	01 97       	sbiw	r24, 0x01	; 1
    1ff6:	9c 83       	std	Y+4, r25	; 0x04
    1ff8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1ffa:	eb 81       	ldd	r30, Y+3	; 0x03
    1ffc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ffe:	80 e2       	ldi	r24, 0x20	; 32
    2000:	80 83       	st	Z, r24
	pxTopOfStack--;
    2002:	8b 81       	ldd	r24, Y+3	; 0x03
    2004:	9c 81       	ldd	r25, Y+4	; 0x04
    2006:	01 97       	sbiw	r24, 0x01	; 1
    2008:	9c 83       	std	Y+4, r25	; 0x04
    200a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    200c:	eb 81       	ldd	r30, Y+3	; 0x03
    200e:	fc 81       	ldd	r31, Y+4	; 0x04
    2010:	81 e2       	ldi	r24, 0x21	; 33
    2012:	80 83       	st	Z, r24
	pxTopOfStack--;
    2014:	8b 81       	ldd	r24, Y+3	; 0x03
    2016:	9c 81       	ldd	r25, Y+4	; 0x04
    2018:	01 97       	sbiw	r24, 0x01	; 1
    201a:	9c 83       	std	Y+4, r25	; 0x04
    201c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    201e:	eb 81       	ldd	r30, Y+3	; 0x03
    2020:	fc 81       	ldd	r31, Y+4	; 0x04
    2022:	82 e2       	ldi	r24, 0x22	; 34
    2024:	80 83       	st	Z, r24
	pxTopOfStack--;
    2026:	8b 81       	ldd	r24, Y+3	; 0x03
    2028:	9c 81       	ldd	r25, Y+4	; 0x04
    202a:	01 97       	sbiw	r24, 0x01	; 1
    202c:	9c 83       	std	Y+4, r25	; 0x04
    202e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2030:	eb 81       	ldd	r30, Y+3	; 0x03
    2032:	fc 81       	ldd	r31, Y+4	; 0x04
    2034:	83 e2       	ldi	r24, 0x23	; 35
    2036:	80 83       	st	Z, r24
	pxTopOfStack--;
    2038:	8b 81       	ldd	r24, Y+3	; 0x03
    203a:	9c 81       	ldd	r25, Y+4	; 0x04
    203c:	01 97       	sbiw	r24, 0x01	; 1
    203e:	9c 83       	std	Y+4, r25	; 0x04
    2040:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2042:	8f 81       	ldd	r24, Y+7	; 0x07
    2044:	98 85       	ldd	r25, Y+8	; 0x08
    2046:	9a 83       	std	Y+2, r25	; 0x02
    2048:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    204a:	89 81       	ldd	r24, Y+1	; 0x01
    204c:	eb 81       	ldd	r30, Y+3	; 0x03
    204e:	fc 81       	ldd	r31, Y+4	; 0x04
    2050:	80 83       	st	Z, r24
	pxTopOfStack--;
    2052:	8b 81       	ldd	r24, Y+3	; 0x03
    2054:	9c 81       	ldd	r25, Y+4	; 0x04
    2056:	01 97       	sbiw	r24, 0x01	; 1
    2058:	9c 83       	std	Y+4, r25	; 0x04
    205a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    205c:	89 81       	ldd	r24, Y+1	; 0x01
    205e:	9a 81       	ldd	r25, Y+2	; 0x02
    2060:	89 2f       	mov	r24, r25
    2062:	99 27       	eor	r25, r25
    2064:	9a 83       	std	Y+2, r25	; 0x02
    2066:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2068:	89 81       	ldd	r24, Y+1	; 0x01
    206a:	eb 81       	ldd	r30, Y+3	; 0x03
    206c:	fc 81       	ldd	r31, Y+4	; 0x04
    206e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2070:	8b 81       	ldd	r24, Y+3	; 0x03
    2072:	9c 81       	ldd	r25, Y+4	; 0x04
    2074:	01 97       	sbiw	r24, 0x01	; 1
    2076:	9c 83       	std	Y+4, r25	; 0x04
    2078:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    207a:	eb 81       	ldd	r30, Y+3	; 0x03
    207c:	fc 81       	ldd	r31, Y+4	; 0x04
    207e:	86 e2       	ldi	r24, 0x26	; 38
    2080:	80 83       	st	Z, r24
	pxTopOfStack--;
    2082:	8b 81       	ldd	r24, Y+3	; 0x03
    2084:	9c 81       	ldd	r25, Y+4	; 0x04
    2086:	01 97       	sbiw	r24, 0x01	; 1
    2088:	9c 83       	std	Y+4, r25	; 0x04
    208a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    208c:	eb 81       	ldd	r30, Y+3	; 0x03
    208e:	fc 81       	ldd	r31, Y+4	; 0x04
    2090:	87 e2       	ldi	r24, 0x27	; 39
    2092:	80 83       	st	Z, r24
	pxTopOfStack--;
    2094:	8b 81       	ldd	r24, Y+3	; 0x03
    2096:	9c 81       	ldd	r25, Y+4	; 0x04
    2098:	01 97       	sbiw	r24, 0x01	; 1
    209a:	9c 83       	std	Y+4, r25	; 0x04
    209c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    209e:	eb 81       	ldd	r30, Y+3	; 0x03
    20a0:	fc 81       	ldd	r31, Y+4	; 0x04
    20a2:	88 e2       	ldi	r24, 0x28	; 40
    20a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    20a6:	8b 81       	ldd	r24, Y+3	; 0x03
    20a8:	9c 81       	ldd	r25, Y+4	; 0x04
    20aa:	01 97       	sbiw	r24, 0x01	; 1
    20ac:	9c 83       	std	Y+4, r25	; 0x04
    20ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    20b0:	eb 81       	ldd	r30, Y+3	; 0x03
    20b2:	fc 81       	ldd	r31, Y+4	; 0x04
    20b4:	89 e2       	ldi	r24, 0x29	; 41
    20b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    20b8:	8b 81       	ldd	r24, Y+3	; 0x03
    20ba:	9c 81       	ldd	r25, Y+4	; 0x04
    20bc:	01 97       	sbiw	r24, 0x01	; 1
    20be:	9c 83       	std	Y+4, r25	; 0x04
    20c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    20c2:	eb 81       	ldd	r30, Y+3	; 0x03
    20c4:	fc 81       	ldd	r31, Y+4	; 0x04
    20c6:	80 e3       	ldi	r24, 0x30	; 48
    20c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    20ca:	8b 81       	ldd	r24, Y+3	; 0x03
    20cc:	9c 81       	ldd	r25, Y+4	; 0x04
    20ce:	01 97       	sbiw	r24, 0x01	; 1
    20d0:	9c 83       	std	Y+4, r25	; 0x04
    20d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    20d4:	eb 81       	ldd	r30, Y+3	; 0x03
    20d6:	fc 81       	ldd	r31, Y+4	; 0x04
    20d8:	81 e3       	ldi	r24, 0x31	; 49
    20da:	80 83       	st	Z, r24
	pxTopOfStack--;
    20dc:	8b 81       	ldd	r24, Y+3	; 0x03
    20de:	9c 81       	ldd	r25, Y+4	; 0x04
    20e0:	01 97       	sbiw	r24, 0x01	; 1
    20e2:	9c 83       	std	Y+4, r25	; 0x04
    20e4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    20e6:	8b 81       	ldd	r24, Y+3	; 0x03
    20e8:	9c 81       	ldd	r25, Y+4	; 0x04
}
    20ea:	28 96       	adiw	r28, 0x08	; 8
    20ec:	0f b6       	in	r0, 0x3f	; 63
    20ee:	f8 94       	cli
    20f0:	de bf       	out	0x3e, r29	; 62
    20f2:	0f be       	out	0x3f, r0	; 63
    20f4:	cd bf       	out	0x3d, r28	; 61
    20f6:	cf 91       	pop	r28
    20f8:	df 91       	pop	r29
    20fa:	08 95       	ret

000020fc <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    20fc:	df 93       	push	r29
    20fe:	cf 93       	push	r28
    2100:	cd b7       	in	r28, 0x3d	; 61
    2102:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2104:	0e 94 70 11 	call	0x22e0	; 0x22e0 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2108:	a0 91 48 07 	lds	r26, 0x0748
    210c:	b0 91 49 07 	lds	r27, 0x0749
    2110:	cd 91       	ld	r28, X+
    2112:	cd bf       	out	0x3d, r28	; 61
    2114:	dd 91       	ld	r29, X+
    2116:	de bf       	out	0x3e, r29	; 62
    2118:	ff 91       	pop	r31
    211a:	ef 91       	pop	r30
    211c:	df 91       	pop	r29
    211e:	cf 91       	pop	r28
    2120:	bf 91       	pop	r27
    2122:	af 91       	pop	r26
    2124:	9f 91       	pop	r25
    2126:	8f 91       	pop	r24
    2128:	7f 91       	pop	r23
    212a:	6f 91       	pop	r22
    212c:	5f 91       	pop	r21
    212e:	4f 91       	pop	r20
    2130:	3f 91       	pop	r19
    2132:	2f 91       	pop	r18
    2134:	1f 91       	pop	r17
    2136:	0f 91       	pop	r16
    2138:	ff 90       	pop	r15
    213a:	ef 90       	pop	r14
    213c:	df 90       	pop	r13
    213e:	cf 90       	pop	r12
    2140:	bf 90       	pop	r11
    2142:	af 90       	pop	r10
    2144:	9f 90       	pop	r9
    2146:	8f 90       	pop	r8
    2148:	7f 90       	pop	r7
    214a:	6f 90       	pop	r6
    214c:	5f 90       	pop	r5
    214e:	4f 90       	pop	r4
    2150:	3f 90       	pop	r3
    2152:	2f 90       	pop	r2
    2154:	1f 90       	pop	r1
    2156:	0f 90       	pop	r0
    2158:	0f be       	out	0x3f, r0	; 63
    215a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    215c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    215e:	81 e0       	ldi	r24, 0x01	; 1
}
    2160:	cf 91       	pop	r28
    2162:	df 91       	pop	r29
    2164:	08 95       	ret

00002166 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2166:	df 93       	push	r29
    2168:	cf 93       	push	r28
    216a:	cd b7       	in	r28, 0x3d	; 61
    216c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    216e:	cf 91       	pop	r28
    2170:	df 91       	pop	r29
    2172:	08 95       	ret

00002174 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2174:	0f 92       	push	r0
    2176:	0f b6       	in	r0, 0x3f	; 63
    2178:	f8 94       	cli
    217a:	0f 92       	push	r0
    217c:	1f 92       	push	r1
    217e:	11 24       	eor	r1, r1
    2180:	2f 92       	push	r2
    2182:	3f 92       	push	r3
    2184:	4f 92       	push	r4
    2186:	5f 92       	push	r5
    2188:	6f 92       	push	r6
    218a:	7f 92       	push	r7
    218c:	8f 92       	push	r8
    218e:	9f 92       	push	r9
    2190:	af 92       	push	r10
    2192:	bf 92       	push	r11
    2194:	cf 92       	push	r12
    2196:	df 92       	push	r13
    2198:	ef 92       	push	r14
    219a:	ff 92       	push	r15
    219c:	0f 93       	push	r16
    219e:	1f 93       	push	r17
    21a0:	2f 93       	push	r18
    21a2:	3f 93       	push	r19
    21a4:	4f 93       	push	r20
    21a6:	5f 93       	push	r21
    21a8:	6f 93       	push	r22
    21aa:	7f 93       	push	r23
    21ac:	8f 93       	push	r24
    21ae:	9f 93       	push	r25
    21b0:	af 93       	push	r26
    21b2:	bf 93       	push	r27
    21b4:	cf 93       	push	r28
    21b6:	df 93       	push	r29
    21b8:	ef 93       	push	r30
    21ba:	ff 93       	push	r31
    21bc:	a0 91 48 07 	lds	r26, 0x0748
    21c0:	b0 91 49 07 	lds	r27, 0x0749
    21c4:	0d b6       	in	r0, 0x3d	; 61
    21c6:	0d 92       	st	X+, r0
    21c8:	0e b6       	in	r0, 0x3e	; 62
    21ca:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    21cc:	0e 94 40 29 	call	0x5280	; 0x5280 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    21d0:	a0 91 48 07 	lds	r26, 0x0748
    21d4:	b0 91 49 07 	lds	r27, 0x0749
    21d8:	cd 91       	ld	r28, X+
    21da:	cd bf       	out	0x3d, r28	; 61
    21dc:	dd 91       	ld	r29, X+
    21de:	de bf       	out	0x3e, r29	; 62
    21e0:	ff 91       	pop	r31
    21e2:	ef 91       	pop	r30
    21e4:	df 91       	pop	r29
    21e6:	cf 91       	pop	r28
    21e8:	bf 91       	pop	r27
    21ea:	af 91       	pop	r26
    21ec:	9f 91       	pop	r25
    21ee:	8f 91       	pop	r24
    21f0:	7f 91       	pop	r23
    21f2:	6f 91       	pop	r22
    21f4:	5f 91       	pop	r21
    21f6:	4f 91       	pop	r20
    21f8:	3f 91       	pop	r19
    21fa:	2f 91       	pop	r18
    21fc:	1f 91       	pop	r17
    21fe:	0f 91       	pop	r16
    2200:	ff 90       	pop	r15
    2202:	ef 90       	pop	r14
    2204:	df 90       	pop	r13
    2206:	cf 90       	pop	r12
    2208:	bf 90       	pop	r11
    220a:	af 90       	pop	r10
    220c:	9f 90       	pop	r9
    220e:	8f 90       	pop	r8
    2210:	7f 90       	pop	r7
    2212:	6f 90       	pop	r6
    2214:	5f 90       	pop	r5
    2216:	4f 90       	pop	r4
    2218:	3f 90       	pop	r3
    221a:	2f 90       	pop	r2
    221c:	1f 90       	pop	r1
    221e:	0f 90       	pop	r0
    2220:	0f be       	out	0x3f, r0	; 63
    2222:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2224:	08 95       	ret

00002226 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2226:	0f 92       	push	r0
    2228:	0f b6       	in	r0, 0x3f	; 63
    222a:	f8 94       	cli
    222c:	0f 92       	push	r0
    222e:	1f 92       	push	r1
    2230:	11 24       	eor	r1, r1
    2232:	2f 92       	push	r2
    2234:	3f 92       	push	r3
    2236:	4f 92       	push	r4
    2238:	5f 92       	push	r5
    223a:	6f 92       	push	r6
    223c:	7f 92       	push	r7
    223e:	8f 92       	push	r8
    2240:	9f 92       	push	r9
    2242:	af 92       	push	r10
    2244:	bf 92       	push	r11
    2246:	cf 92       	push	r12
    2248:	df 92       	push	r13
    224a:	ef 92       	push	r14
    224c:	ff 92       	push	r15
    224e:	0f 93       	push	r16
    2250:	1f 93       	push	r17
    2252:	2f 93       	push	r18
    2254:	3f 93       	push	r19
    2256:	4f 93       	push	r20
    2258:	5f 93       	push	r21
    225a:	6f 93       	push	r22
    225c:	7f 93       	push	r23
    225e:	8f 93       	push	r24
    2260:	9f 93       	push	r25
    2262:	af 93       	push	r26
    2264:	bf 93       	push	r27
    2266:	cf 93       	push	r28
    2268:	df 93       	push	r29
    226a:	ef 93       	push	r30
    226c:	ff 93       	push	r31
    226e:	a0 91 48 07 	lds	r26, 0x0748
    2272:	b0 91 49 07 	lds	r27, 0x0749
    2276:	0d b6       	in	r0, 0x3d	; 61
    2278:	0d 92       	st	X+, r0
    227a:	0e b6       	in	r0, 0x3e	; 62
    227c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    227e:	0e 94 a9 27 	call	0x4f52	; 0x4f52 <xTaskIncrementTick>
    2282:	88 23       	and	r24, r24
    2284:	11 f0       	breq	.+4      	; 0x228a <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2286:	0e 94 40 29 	call	0x5280	; 0x5280 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    228a:	a0 91 48 07 	lds	r26, 0x0748
    228e:	b0 91 49 07 	lds	r27, 0x0749
    2292:	cd 91       	ld	r28, X+
    2294:	cd bf       	out	0x3d, r28	; 61
    2296:	dd 91       	ld	r29, X+
    2298:	de bf       	out	0x3e, r29	; 62
    229a:	ff 91       	pop	r31
    229c:	ef 91       	pop	r30
    229e:	df 91       	pop	r29
    22a0:	cf 91       	pop	r28
    22a2:	bf 91       	pop	r27
    22a4:	af 91       	pop	r26
    22a6:	9f 91       	pop	r25
    22a8:	8f 91       	pop	r24
    22aa:	7f 91       	pop	r23
    22ac:	6f 91       	pop	r22
    22ae:	5f 91       	pop	r21
    22b0:	4f 91       	pop	r20
    22b2:	3f 91       	pop	r19
    22b4:	2f 91       	pop	r18
    22b6:	1f 91       	pop	r17
    22b8:	0f 91       	pop	r16
    22ba:	ff 90       	pop	r15
    22bc:	ef 90       	pop	r14
    22be:	df 90       	pop	r13
    22c0:	cf 90       	pop	r12
    22c2:	bf 90       	pop	r11
    22c4:	af 90       	pop	r10
    22c6:	9f 90       	pop	r9
    22c8:	8f 90       	pop	r8
    22ca:	7f 90       	pop	r7
    22cc:	6f 90       	pop	r6
    22ce:	5f 90       	pop	r5
    22d0:	4f 90       	pop	r4
    22d2:	3f 90       	pop	r3
    22d4:	2f 90       	pop	r2
    22d6:	1f 90       	pop	r1
    22d8:	0f 90       	pop	r0
    22da:	0f be       	out	0x3f, r0	; 63
    22dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    22de:	08 95       	ret

000022e0 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    22e0:	df 93       	push	r29
    22e2:	cf 93       	push	r28
    22e4:	00 d0       	rcall	.+0      	; 0x22e6 <prvSetupTimerInterrupt+0x6>
    22e6:	00 d0       	rcall	.+0      	; 0x22e8 <prvSetupTimerInterrupt+0x8>
    22e8:	00 d0       	rcall	.+0      	; 0x22ea <prvSetupTimerInterrupt+0xa>
    22ea:	cd b7       	in	r28, 0x3d	; 61
    22ec:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    22ee:	80 e4       	ldi	r24, 0x40	; 64
    22f0:	9f e1       	ldi	r25, 0x1F	; 31
    22f2:	a0 e0       	ldi	r26, 0x00	; 0
    22f4:	b0 e0       	ldi	r27, 0x00	; 0
    22f6:	8b 83       	std	Y+3, r24	; 0x03
    22f8:	9c 83       	std	Y+4, r25	; 0x04
    22fa:	ad 83       	std	Y+5, r26	; 0x05
    22fc:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    22fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2300:	9c 81       	ldd	r25, Y+4	; 0x04
    2302:	ad 81       	ldd	r26, Y+5	; 0x05
    2304:	be 81       	ldd	r27, Y+6	; 0x06
    2306:	68 94       	set
    2308:	15 f8       	bld	r1, 5
    230a:	b6 95       	lsr	r27
    230c:	a7 95       	ror	r26
    230e:	97 95       	ror	r25
    2310:	87 95       	ror	r24
    2312:	16 94       	lsr	r1
    2314:	d1 f7       	brne	.-12     	; 0x230a <prvSetupTimerInterrupt+0x2a>
    2316:	8b 83       	std	Y+3, r24	; 0x03
    2318:	9c 83       	std	Y+4, r25	; 0x04
    231a:	ad 83       	std	Y+5, r26	; 0x05
    231c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    231e:	8b 81       	ldd	r24, Y+3	; 0x03
    2320:	9c 81       	ldd	r25, Y+4	; 0x04
    2322:	ad 81       	ldd	r26, Y+5	; 0x05
    2324:	be 81       	ldd	r27, Y+6	; 0x06
    2326:	01 97       	sbiw	r24, 0x01	; 1
    2328:	a1 09       	sbc	r26, r1
    232a:	b1 09       	sbc	r27, r1
    232c:	8b 83       	std	Y+3, r24	; 0x03
    232e:	9c 83       	std	Y+4, r25	; 0x04
    2330:	ad 83       	std	Y+5, r26	; 0x05
    2332:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2334:	8b 81       	ldd	r24, Y+3	; 0x03
    2336:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2338:	8b 81       	ldd	r24, Y+3	; 0x03
    233a:	9c 81       	ldd	r25, Y+4	; 0x04
    233c:	ad 81       	ldd	r26, Y+5	; 0x05
    233e:	be 81       	ldd	r27, Y+6	; 0x06
    2340:	89 2f       	mov	r24, r25
    2342:	9a 2f       	mov	r25, r26
    2344:	ab 2f       	mov	r26, r27
    2346:	bb 27       	eor	r27, r27
    2348:	8b 83       	std	Y+3, r24	; 0x03
    234a:	9c 83       	std	Y+4, r25	; 0x04
    234c:	ad 83       	std	Y+5, r26	; 0x05
    234e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2350:	8b 81       	ldd	r24, Y+3	; 0x03
    2352:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2354:	eb e4       	ldi	r30, 0x4B	; 75
    2356:	f0 e0       	ldi	r31, 0x00	; 0
    2358:	8a 81       	ldd	r24, Y+2	; 0x02
    235a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    235c:	ea e4       	ldi	r30, 0x4A	; 74
    235e:	f0 e0       	ldi	r31, 0x00	; 0
    2360:	89 81       	ldd	r24, Y+1	; 0x01
    2362:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2364:	8b e0       	ldi	r24, 0x0B	; 11
    2366:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2368:	ee e4       	ldi	r30, 0x4E	; 78
    236a:	f0 e0       	ldi	r31, 0x00	; 0
    236c:	89 81       	ldd	r24, Y+1	; 0x01
    236e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2370:	e9 e5       	ldi	r30, 0x59	; 89
    2372:	f0 e0       	ldi	r31, 0x00	; 0
    2374:	80 81       	ld	r24, Z
    2376:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2378:	89 81       	ldd	r24, Y+1	; 0x01
    237a:	80 61       	ori	r24, 0x10	; 16
    237c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    237e:	e9 e5       	ldi	r30, 0x59	; 89
    2380:	f0 e0       	ldi	r31, 0x00	; 0
    2382:	89 81       	ldd	r24, Y+1	; 0x01
    2384:	80 83       	st	Z, r24
}
    2386:	26 96       	adiw	r28, 0x06	; 6
    2388:	0f b6       	in	r0, 0x3f	; 63
    238a:	f8 94       	cli
    238c:	de bf       	out	0x3e, r29	; 62
    238e:	0f be       	out	0x3f, r0	; 63
    2390:	cd bf       	out	0x3d, r28	; 61
    2392:	cf 91       	pop	r28
    2394:	df 91       	pop	r29
    2396:	08 95       	ret

00002398 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2398:	0e 94 13 11 	call	0x2226	; 0x2226 <vPortYieldFromTick>
		asm volatile ( "reti" );
    239c:	18 95       	reti

0000239e <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
    239e:	df 93       	push	r29
    23a0:	cf 93       	push	r28
    23a2:	cd b7       	in	r28, 0x3d	; 61
    23a4:	de b7       	in	r29, 0x3e	; 62
    23a6:	27 97       	sbiw	r28, 0x07	; 7
    23a8:	0f b6       	in	r0, 0x3f	; 63
    23aa:	f8 94       	cli
    23ac:	de bf       	out	0x3e, r29	; 62
    23ae:	0f be       	out	0x3f, r0	; 63
    23b0:	cd bf       	out	0x3d, r28	; 61
    23b2:	9d 83       	std	Y+5, r25	; 0x05
    23b4:	8c 83       	std	Y+4, r24	; 0x04
    23b6:	6e 83       	std	Y+6, r22	; 0x06
    23b8:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    23ba:	8a e1       	ldi	r24, 0x1A	; 26
    23bc:	90 e0       	ldi	r25, 0x00	; 0
    23be:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <pvPortMalloc>
    23c2:	9a 83       	std	Y+2, r25	; 0x02
    23c4:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
    23c6:	89 81       	ldd	r24, Y+1	; 0x01
    23c8:	9a 81       	ldd	r25, Y+2	; 0x02
    23ca:	00 97       	sbiw	r24, 0x00	; 0
    23cc:	09 f4       	brne	.+2      	; 0x23d0 <xCoRoutineCreate+0x32>
    23ce:	6f c0       	rjmp	.+222    	; 0x24ae <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
    23d0:	80 91 12 07 	lds	r24, 0x0712
    23d4:	90 91 13 07 	lds	r25, 0x0713
    23d8:	00 97       	sbiw	r24, 0x00	; 0
    23da:	41 f4       	brne	.+16     	; 0x23ec <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
    23dc:	89 81       	ldd	r24, Y+1	; 0x01
    23de:	9a 81       	ldd	r25, Y+2	; 0x02
    23e0:	90 93 13 07 	sts	0x0713, r25
    23e4:	80 93 12 07 	sts	0x0712, r24
                prvInitialiseCoRoutineLists();
    23e8:	0e 94 3d 14 	call	0x287a	; 0x287a <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    23ec:	8e 81       	ldd	r24, Y+6	; 0x06
    23ee:	82 30       	cpi	r24, 0x02	; 2
    23f0:	10 f0       	brcs	.+4      	; 0x23f6 <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    23f2:	81 e0       	ldi	r24, 0x01	; 1
    23f4:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
    23f6:	e9 81       	ldd	r30, Y+1	; 0x01
    23f8:	fa 81       	ldd	r31, Y+2	; 0x02
    23fa:	11 8e       	std	Z+25, r1	; 0x19
    23fc:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
    23fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2400:	fa 81       	ldd	r31, Y+2	; 0x02
    2402:	8e 81       	ldd	r24, Y+6	; 0x06
    2404:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
    2406:	e9 81       	ldd	r30, Y+1	; 0x01
    2408:	fa 81       	ldd	r31, Y+2	; 0x02
    240a:	8f 81       	ldd	r24, Y+7	; 0x07
    240c:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    240e:	e9 81       	ldd	r30, Y+1	; 0x01
    2410:	fa 81       	ldd	r31, Y+2	; 0x02
    2412:	8c 81       	ldd	r24, Y+4	; 0x04
    2414:	9d 81       	ldd	r25, Y+5	; 0x05
    2416:	91 83       	std	Z+1, r25	; 0x01
    2418:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    241a:	89 81       	ldd	r24, Y+1	; 0x01
    241c:	9a 81       	ldd	r25, Y+2	; 0x02
    241e:	02 96       	adiw	r24, 0x02	; 2
    2420:	0e 94 1d 18 	call	0x303a	; 0x303a <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2424:	89 81       	ldd	r24, Y+1	; 0x01
    2426:	9a 81       	ldd	r25, Y+2	; 0x02
    2428:	0c 96       	adiw	r24, 0x0c	; 12
    242a:	0e 94 1d 18 	call	0x303a	; 0x303a <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    242e:	e9 81       	ldd	r30, Y+1	; 0x01
    2430:	fa 81       	ldd	r31, Y+2	; 0x02
    2432:	89 81       	ldd	r24, Y+1	; 0x01
    2434:	9a 81       	ldd	r25, Y+2	; 0x02
    2436:	91 87       	std	Z+9, r25	; 0x09
    2438:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    243a:	e9 81       	ldd	r30, Y+1	; 0x01
    243c:	fa 81       	ldd	r31, Y+2	; 0x02
    243e:	89 81       	ldd	r24, Y+1	; 0x01
    2440:	9a 81       	ldd	r25, Y+2	; 0x02
    2442:	93 8b       	std	Z+19, r25	; 0x13
    2444:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2446:	8e 81       	ldd	r24, Y+6	; 0x06
    2448:	28 2f       	mov	r18, r24
    244a:	30 e0       	ldi	r19, 0x00	; 0
    244c:	82 e0       	ldi	r24, 0x02	; 2
    244e:	90 e0       	ldi	r25, 0x00	; 0
    2450:	82 1b       	sub	r24, r18
    2452:	93 0b       	sbc	r25, r19
    2454:	e9 81       	ldd	r30, Y+1	; 0x01
    2456:	fa 81       	ldd	r31, Y+2	; 0x02
    2458:	95 87       	std	Z+13, r25	; 0x0d
    245a:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
    245c:	e9 81       	ldd	r30, Y+1	; 0x01
    245e:	fa 81       	ldd	r31, Y+2	; 0x02
    2460:	96 89       	ldd	r25, Z+22	; 0x16
    2462:	80 91 14 07 	lds	r24, 0x0714
    2466:	89 17       	cp	r24, r25
    2468:	28 f4       	brcc	.+10     	; 0x2474 <xCoRoutineCreate+0xd6>
    246a:	e9 81       	ldd	r30, Y+1	; 0x01
    246c:	fa 81       	ldd	r31, Y+2	; 0x02
    246e:	86 89       	ldd	r24, Z+22	; 0x16
    2470:	80 93 14 07 	sts	0x0714, r24
    2474:	e9 81       	ldd	r30, Y+1	; 0x01
    2476:	fa 81       	ldd	r31, Y+2	; 0x02
    2478:	86 89       	ldd	r24, Z+22	; 0x16
    247a:	28 2f       	mov	r18, r24
    247c:	30 e0       	ldi	r19, 0x00	; 0
    247e:	c9 01       	movw	r24, r18
    2480:	88 0f       	add	r24, r24
    2482:	99 1f       	adc	r25, r25
    2484:	88 0f       	add	r24, r24
    2486:	99 1f       	adc	r25, r25
    2488:	88 0f       	add	r24, r24
    248a:	99 1f       	adc	r25, r25
    248c:	82 0f       	add	r24, r18
    248e:	93 1f       	adc	r25, r19
    2490:	ac 01       	movw	r20, r24
    2492:	45 5e       	subi	r20, 0xE5	; 229
    2494:	58 4f       	sbci	r21, 0xF8	; 248
    2496:	89 81       	ldd	r24, Y+1	; 0x01
    2498:	9a 81       	ldd	r25, Y+2	; 0x02
    249a:	9c 01       	movw	r18, r24
    249c:	2e 5f       	subi	r18, 0xFE	; 254
    249e:	3f 4f       	sbci	r19, 0xFF	; 255
    24a0:	ca 01       	movw	r24, r20
    24a2:	b9 01       	movw	r22, r18
    24a4:	0e 94 2d 18 	call	0x305a	; 0x305a <vListInsertEnd>

            xReturn = pdPASS;
    24a8:	81 e0       	ldi	r24, 0x01	; 1
    24aa:	8b 83       	std	Y+3, r24	; 0x03
    24ac:	02 c0       	rjmp	.+4      	; 0x24b2 <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    24ae:	8f ef       	ldi	r24, 0xFF	; 255
    24b0:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    24b2:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    24b4:	27 96       	adiw	r28, 0x07	; 7
    24b6:	0f b6       	in	r0, 0x3f	; 63
    24b8:	f8 94       	cli
    24ba:	de bf       	out	0x3e, r29	; 62
    24bc:	0f be       	out	0x3f, r0	; 63
    24be:	cd bf       	out	0x3d, r28	; 61
    24c0:	cf 91       	pop	r28
    24c2:	df 91       	pop	r29
    24c4:	08 95       	ret

000024c6 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
    24c6:	df 93       	push	r29
    24c8:	cf 93       	push	r28
    24ca:	00 d0       	rcall	.+0      	; 0x24cc <vCoRoutineAddToDelayedList+0x6>
    24cc:	00 d0       	rcall	.+0      	; 0x24ce <vCoRoutineAddToDelayedList+0x8>
    24ce:	00 d0       	rcall	.+0      	; 0x24d0 <vCoRoutineAddToDelayedList+0xa>
    24d0:	cd b7       	in	r28, 0x3d	; 61
    24d2:	de b7       	in	r29, 0x3e	; 62
    24d4:	9c 83       	std	Y+4, r25	; 0x04
    24d6:	8b 83       	std	Y+3, r24	; 0x03
    24d8:	7e 83       	std	Y+6, r23	; 0x06
    24da:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    24dc:	20 91 15 07 	lds	r18, 0x0715
    24e0:	30 91 16 07 	lds	r19, 0x0716
    24e4:	8b 81       	ldd	r24, Y+3	; 0x03
    24e6:	9c 81       	ldd	r25, Y+4	; 0x04
    24e8:	82 0f       	add	r24, r18
    24ea:	93 1f       	adc	r25, r19
    24ec:	9a 83       	std	Y+2, r25	; 0x02
    24ee:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    24f0:	80 91 12 07 	lds	r24, 0x0712
    24f4:	90 91 13 07 	lds	r25, 0x0713
    24f8:	02 96       	adiw	r24, 0x02	; 2
    24fa:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    24fe:	e0 91 12 07 	lds	r30, 0x0712
    2502:	f0 91 13 07 	lds	r31, 0x0713
    2506:	89 81       	ldd	r24, Y+1	; 0x01
    2508:	9a 81       	ldd	r25, Y+2	; 0x02
    250a:	93 83       	std	Z+3, r25	; 0x03
    250c:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    250e:	20 91 15 07 	lds	r18, 0x0715
    2512:	30 91 16 07 	lds	r19, 0x0716
    2516:	89 81       	ldd	r24, Y+1	; 0x01
    2518:	9a 81       	ldd	r25, Y+2	; 0x02
    251a:	82 17       	cp	r24, r18
    251c:	93 07       	cpc	r25, r19
    251e:	70 f4       	brcc	.+28     	; 0x253c <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2520:	80 91 10 07 	lds	r24, 0x0710
    2524:	90 91 11 07 	lds	r25, 0x0711
    2528:	20 91 12 07 	lds	r18, 0x0712
    252c:	30 91 13 07 	lds	r19, 0x0713
    2530:	2e 5f       	subi	r18, 0xFE	; 254
    2532:	3f 4f       	sbci	r19, 0xFF	; 255
    2534:	b9 01       	movw	r22, r18
    2536:	0e 94 71 18 	call	0x30e2	; 0x30e2 <vListInsert>
    253a:	0d c0       	rjmp	.+26     	; 0x2556 <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    253c:	80 91 0e 07 	lds	r24, 0x070E
    2540:	90 91 0f 07 	lds	r25, 0x070F
    2544:	20 91 12 07 	lds	r18, 0x0712
    2548:	30 91 13 07 	lds	r19, 0x0713
    254c:	2e 5f       	subi	r18, 0xFE	; 254
    254e:	3f 4f       	sbci	r19, 0xFF	; 255
    2550:	b9 01       	movw	r22, r18
    2552:	0e 94 71 18 	call	0x30e2	; 0x30e2 <vListInsert>
        }

        if( pxEventList )
    2556:	8d 81       	ldd	r24, Y+5	; 0x05
    2558:	9e 81       	ldd	r25, Y+6	; 0x06
    255a:	00 97       	sbiw	r24, 0x00	; 0
    255c:	61 f0       	breq	.+24     	; 0x2576 <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    255e:	80 91 12 07 	lds	r24, 0x0712
    2562:	90 91 13 07 	lds	r25, 0x0713
    2566:	9c 01       	movw	r18, r24
    2568:	24 5f       	subi	r18, 0xF4	; 244
    256a:	3f 4f       	sbci	r19, 0xFF	; 255
    256c:	8d 81       	ldd	r24, Y+5	; 0x05
    256e:	9e 81       	ldd	r25, Y+6	; 0x06
    2570:	b9 01       	movw	r22, r18
    2572:	0e 94 71 18 	call	0x30e2	; 0x30e2 <vListInsert>
        }
    }
    2576:	26 96       	adiw	r28, 0x06	; 6
    2578:	0f b6       	in	r0, 0x3f	; 63
    257a:	f8 94       	cli
    257c:	de bf       	out	0x3e, r29	; 62
    257e:	0f be       	out	0x3f, r0	; 63
    2580:	cd bf       	out	0x3d, r28	; 61
    2582:	cf 91       	pop	r28
    2584:	df 91       	pop	r29
    2586:	08 95       	ret

00002588 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    2588:	df 93       	push	r29
    258a:	cf 93       	push	r28
    258c:	00 d0       	rcall	.+0      	; 0x258e <prvCheckPendingReadyList+0x6>
    258e:	cd b7       	in	r28, 0x3d	; 61
    2590:	de b7       	in	r29, 0x3e	; 62
    2592:	3a c0       	rjmp	.+116    	; 0x2608 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    2594:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    2596:	e0 91 44 07 	lds	r30, 0x0744
    259a:	f0 91 45 07 	lds	r31, 0x0745
    259e:	86 81       	ldd	r24, Z+6	; 0x06
    25a0:	97 81       	ldd	r25, Z+7	; 0x07
    25a2:	9a 83       	std	Y+2, r25	; 0x02
    25a4:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    25a6:	89 81       	ldd	r24, Y+1	; 0x01
    25a8:	9a 81       	ldd	r25, Y+2	; 0x02
    25aa:	0c 96       	adiw	r24, 0x0c	; 12
    25ac:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    25b0:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    25b2:	89 81       	ldd	r24, Y+1	; 0x01
    25b4:	9a 81       	ldd	r25, Y+2	; 0x02
    25b6:	02 96       	adiw	r24, 0x02	; 2
    25b8:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    25bc:	e9 81       	ldd	r30, Y+1	; 0x01
    25be:	fa 81       	ldd	r31, Y+2	; 0x02
    25c0:	96 89       	ldd	r25, Z+22	; 0x16
    25c2:	80 91 14 07 	lds	r24, 0x0714
    25c6:	89 17       	cp	r24, r25
    25c8:	28 f4       	brcc	.+10     	; 0x25d4 <prvCheckPendingReadyList+0x4c>
    25ca:	e9 81       	ldd	r30, Y+1	; 0x01
    25cc:	fa 81       	ldd	r31, Y+2	; 0x02
    25ce:	86 89       	ldd	r24, Z+22	; 0x16
    25d0:	80 93 14 07 	sts	0x0714, r24
    25d4:	e9 81       	ldd	r30, Y+1	; 0x01
    25d6:	fa 81       	ldd	r31, Y+2	; 0x02
    25d8:	86 89       	ldd	r24, Z+22	; 0x16
    25da:	28 2f       	mov	r18, r24
    25dc:	30 e0       	ldi	r19, 0x00	; 0
    25de:	c9 01       	movw	r24, r18
    25e0:	88 0f       	add	r24, r24
    25e2:	99 1f       	adc	r25, r25
    25e4:	88 0f       	add	r24, r24
    25e6:	99 1f       	adc	r25, r25
    25e8:	88 0f       	add	r24, r24
    25ea:	99 1f       	adc	r25, r25
    25ec:	82 0f       	add	r24, r18
    25ee:	93 1f       	adc	r25, r19
    25f0:	ac 01       	movw	r20, r24
    25f2:	45 5e       	subi	r20, 0xE5	; 229
    25f4:	58 4f       	sbci	r21, 0xF8	; 248
    25f6:	89 81       	ldd	r24, Y+1	; 0x01
    25f8:	9a 81       	ldd	r25, Y+2	; 0x02
    25fa:	9c 01       	movw	r18, r24
    25fc:	2e 5f       	subi	r18, 0xFE	; 254
    25fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2600:	ca 01       	movw	r24, r20
    2602:	b9 01       	movw	r22, r18
    2604:	0e 94 2d 18 	call	0x305a	; 0x305a <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2608:	80 91 3f 07 	lds	r24, 0x073F
    260c:	88 23       	and	r24, r24
    260e:	09 f0       	breq	.+2      	; 0x2612 <prvCheckPendingReadyList+0x8a>
    2610:	c1 cf       	rjmp	.-126    	; 0x2594 <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    2612:	0f 90       	pop	r0
    2614:	0f 90       	pop	r0
    2616:	cf 91       	pop	r28
    2618:	df 91       	pop	r29
    261a:	08 95       	ret

0000261c <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    261c:	df 93       	push	r29
    261e:	cf 93       	push	r28
    2620:	00 d0       	rcall	.+0      	; 0x2622 <prvCheckDelayedList+0x6>
    2622:	00 d0       	rcall	.+0      	; 0x2624 <prvCheckDelayedList+0x8>
    2624:	cd b7       	in	r28, 0x3d	; 61
    2626:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2628:	0e 94 2c 27 	call	0x4e58	; 0x4e58 <xTaskGetTickCount>
    262c:	20 91 17 07 	lds	r18, 0x0717
    2630:	30 91 18 07 	lds	r19, 0x0718
    2634:	82 1b       	sub	r24, r18
    2636:	93 0b       	sbc	r25, r19
    2638:	90 93 1a 07 	sts	0x071A, r25
    263c:	80 93 19 07 	sts	0x0719, r24
    2640:	85 c0       	rjmp	.+266    	; 0x274c <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    2642:	80 91 15 07 	lds	r24, 0x0715
    2646:	90 91 16 07 	lds	r25, 0x0716
    264a:	01 96       	adiw	r24, 0x01	; 1
    264c:	90 93 16 07 	sts	0x0716, r25
    2650:	80 93 15 07 	sts	0x0715, r24
            xPassedTicks--;
    2654:	80 91 19 07 	lds	r24, 0x0719
    2658:	90 91 1a 07 	lds	r25, 0x071A
    265c:	01 97       	sbiw	r24, 0x01	; 1
    265e:	90 93 1a 07 	sts	0x071A, r25
    2662:	80 93 19 07 	sts	0x0719, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    2666:	80 91 15 07 	lds	r24, 0x0715
    266a:	90 91 16 07 	lds	r25, 0x0716
    266e:	00 97       	sbiw	r24, 0x00	; 0
    2670:	09 f0       	breq	.+2      	; 0x2674 <prvCheckDelayedList+0x58>
    2672:	64 c0       	rjmp	.+200    	; 0x273c <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    2674:	80 91 0e 07 	lds	r24, 0x070E
    2678:	90 91 0f 07 	lds	r25, 0x070F
    267c:	9a 83       	std	Y+2, r25	; 0x02
    267e:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2680:	80 91 10 07 	lds	r24, 0x0710
    2684:	90 91 11 07 	lds	r25, 0x0711
    2688:	90 93 0f 07 	sts	0x070F, r25
    268c:	80 93 0e 07 	sts	0x070E, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    2690:	89 81       	ldd	r24, Y+1	; 0x01
    2692:	9a 81       	ldd	r25, Y+2	; 0x02
    2694:	90 93 11 07 	sts	0x0711, r25
    2698:	80 93 10 07 	sts	0x0710, r24
    269c:	4f c0       	rjmp	.+158    	; 0x273c <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    269e:	e0 91 0e 07 	lds	r30, 0x070E
    26a2:	f0 91 0f 07 	lds	r31, 0x070F
    26a6:	05 80       	ldd	r0, Z+5	; 0x05
    26a8:	f6 81       	ldd	r31, Z+6	; 0x06
    26aa:	e0 2d       	mov	r30, r0
    26ac:	86 81       	ldd	r24, Z+6	; 0x06
    26ae:	97 81       	ldd	r25, Z+7	; 0x07
    26b0:	9c 83       	std	Y+4, r25	; 0x04
    26b2:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    26b4:	eb 81       	ldd	r30, Y+3	; 0x03
    26b6:	fc 81       	ldd	r31, Y+4	; 0x04
    26b8:	22 81       	ldd	r18, Z+2	; 0x02
    26ba:	33 81       	ldd	r19, Z+3	; 0x03
    26bc:	80 91 15 07 	lds	r24, 0x0715
    26c0:	90 91 16 07 	lds	r25, 0x0716
    26c4:	82 17       	cp	r24, r18
    26c6:	93 07       	cpc	r25, r19
    26c8:	08 f4       	brcc	.+2      	; 0x26cc <prvCheckDelayedList+0xb0>
    26ca:	40 c0       	rjmp	.+128    	; 0x274c <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    26cc:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    26ce:	8b 81       	ldd	r24, Y+3	; 0x03
    26d0:	9c 81       	ldd	r25, Y+4	; 0x04
    26d2:	02 96       	adiw	r24, 0x02	; 2
    26d4:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    26d8:	eb 81       	ldd	r30, Y+3	; 0x03
    26da:	fc 81       	ldd	r31, Y+4	; 0x04
    26dc:	84 89       	ldd	r24, Z+20	; 0x14
    26de:	95 89       	ldd	r25, Z+21	; 0x15
    26e0:	00 97       	sbiw	r24, 0x00	; 0
    26e2:	29 f0       	breq	.+10     	; 0x26ee <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    26e4:	8b 81       	ldd	r24, Y+3	; 0x03
    26e6:	9c 81       	ldd	r25, Y+4	; 0x04
    26e8:	0c 96       	adiw	r24, 0x0c	; 12
    26ea:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    26ee:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    26f0:	eb 81       	ldd	r30, Y+3	; 0x03
    26f2:	fc 81       	ldd	r31, Y+4	; 0x04
    26f4:	96 89       	ldd	r25, Z+22	; 0x16
    26f6:	80 91 14 07 	lds	r24, 0x0714
    26fa:	89 17       	cp	r24, r25
    26fc:	28 f4       	brcc	.+10     	; 0x2708 <prvCheckDelayedList+0xec>
    26fe:	eb 81       	ldd	r30, Y+3	; 0x03
    2700:	fc 81       	ldd	r31, Y+4	; 0x04
    2702:	86 89       	ldd	r24, Z+22	; 0x16
    2704:	80 93 14 07 	sts	0x0714, r24
    2708:	eb 81       	ldd	r30, Y+3	; 0x03
    270a:	fc 81       	ldd	r31, Y+4	; 0x04
    270c:	86 89       	ldd	r24, Z+22	; 0x16
    270e:	28 2f       	mov	r18, r24
    2710:	30 e0       	ldi	r19, 0x00	; 0
    2712:	c9 01       	movw	r24, r18
    2714:	88 0f       	add	r24, r24
    2716:	99 1f       	adc	r25, r25
    2718:	88 0f       	add	r24, r24
    271a:	99 1f       	adc	r25, r25
    271c:	88 0f       	add	r24, r24
    271e:	99 1f       	adc	r25, r25
    2720:	82 0f       	add	r24, r18
    2722:	93 1f       	adc	r25, r19
    2724:	ac 01       	movw	r20, r24
    2726:	45 5e       	subi	r20, 0xE5	; 229
    2728:	58 4f       	sbci	r21, 0xF8	; 248
    272a:	8b 81       	ldd	r24, Y+3	; 0x03
    272c:	9c 81       	ldd	r25, Y+4	; 0x04
    272e:	9c 01       	movw	r18, r24
    2730:	2e 5f       	subi	r18, 0xFE	; 254
    2732:	3f 4f       	sbci	r19, 0xFF	; 255
    2734:	ca 01       	movw	r24, r20
    2736:	b9 01       	movw	r22, r18
    2738:	0e 94 2d 18 	call	0x305a	; 0x305a <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    273c:	e0 91 0e 07 	lds	r30, 0x070E
    2740:	f0 91 0f 07 	lds	r31, 0x070F
    2744:	80 81       	ld	r24, Z
    2746:	88 23       	and	r24, r24
    2748:	09 f0       	breq	.+2      	; 0x274c <prvCheckDelayedList+0x130>
    274a:	a9 cf       	rjmp	.-174    	; 0x269e <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    274c:	80 91 19 07 	lds	r24, 0x0719
    2750:	90 91 1a 07 	lds	r25, 0x071A
    2754:	00 97       	sbiw	r24, 0x00	; 0
    2756:	09 f0       	breq	.+2      	; 0x275a <prvCheckDelayedList+0x13e>
    2758:	74 cf       	rjmp	.-280    	; 0x2642 <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    275a:	80 91 15 07 	lds	r24, 0x0715
    275e:	90 91 16 07 	lds	r25, 0x0716
    2762:	90 93 18 07 	sts	0x0718, r25
    2766:	80 93 17 07 	sts	0x0717, r24
    }
    276a:	0f 90       	pop	r0
    276c:	0f 90       	pop	r0
    276e:	0f 90       	pop	r0
    2770:	0f 90       	pop	r0
    2772:	cf 91       	pop	r28
    2774:	df 91       	pop	r29
    2776:	08 95       	ret

00002778 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    2778:	df 93       	push	r29
    277a:	cf 93       	push	r28
    277c:	00 d0       	rcall	.+0      	; 0x277e <vCoRoutineSchedule+0x6>
    277e:	cd b7       	in	r28, 0x3d	; 61
    2780:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    2782:	80 91 0e 07 	lds	r24, 0x070E
    2786:	90 91 0f 07 	lds	r25, 0x070F
    278a:	00 97       	sbiw	r24, 0x00	; 0
    278c:	09 f4       	brne	.+2      	; 0x2790 <vCoRoutineSchedule+0x18>
    278e:	70 c0       	rjmp	.+224    	; 0x2870 <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    2790:	0e 94 c4 12 	call	0x2588	; 0x2588 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    2794:	0e 94 0e 13 	call	0x261c	; 0x261c <prvCheckDelayedList>
    2798:	0a c0       	rjmp	.+20     	; 0x27ae <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    279a:	80 91 14 07 	lds	r24, 0x0714
    279e:	88 23       	and	r24, r24
    27a0:	09 f4       	brne	.+2      	; 0x27a4 <vCoRoutineSchedule+0x2c>
    27a2:	66 c0       	rjmp	.+204    	; 0x2870 <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    27a4:	80 91 14 07 	lds	r24, 0x0714
    27a8:	81 50       	subi	r24, 0x01	; 1
    27aa:	80 93 14 07 	sts	0x0714, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    27ae:	80 91 14 07 	lds	r24, 0x0714
    27b2:	28 2f       	mov	r18, r24
    27b4:	30 e0       	ldi	r19, 0x00	; 0
    27b6:	c9 01       	movw	r24, r18
    27b8:	88 0f       	add	r24, r24
    27ba:	99 1f       	adc	r25, r25
    27bc:	88 0f       	add	r24, r24
    27be:	99 1f       	adc	r25, r25
    27c0:	88 0f       	add	r24, r24
    27c2:	99 1f       	adc	r25, r25
    27c4:	82 0f       	add	r24, r18
    27c6:	93 1f       	adc	r25, r19
    27c8:	fc 01       	movw	r30, r24
    27ca:	e5 5e       	subi	r30, 0xE5	; 229
    27cc:	f8 4f       	sbci	r31, 0xF8	; 248
    27ce:	80 81       	ld	r24, Z
    27d0:	88 23       	and	r24, r24
    27d2:	19 f3       	breq	.-58     	; 0x279a <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    27d4:	80 91 14 07 	lds	r24, 0x0714
    27d8:	28 2f       	mov	r18, r24
    27da:	30 e0       	ldi	r19, 0x00	; 0
    27dc:	c9 01       	movw	r24, r18
    27de:	88 0f       	add	r24, r24
    27e0:	99 1f       	adc	r25, r25
    27e2:	88 0f       	add	r24, r24
    27e4:	99 1f       	adc	r25, r25
    27e6:	88 0f       	add	r24, r24
    27e8:	99 1f       	adc	r25, r25
    27ea:	82 0f       	add	r24, r18
    27ec:	93 1f       	adc	r25, r19
    27ee:	85 5e       	subi	r24, 0xE5	; 229
    27f0:	98 4f       	sbci	r25, 0xF8	; 248
    27f2:	9a 83       	std	Y+2, r25	; 0x02
    27f4:	89 83       	std	Y+1, r24	; 0x01
    27f6:	e9 81       	ldd	r30, Y+1	; 0x01
    27f8:	fa 81       	ldd	r31, Y+2	; 0x02
    27fa:	01 80       	ldd	r0, Z+1	; 0x01
    27fc:	f2 81       	ldd	r31, Z+2	; 0x02
    27fe:	e0 2d       	mov	r30, r0
    2800:	82 81       	ldd	r24, Z+2	; 0x02
    2802:	93 81       	ldd	r25, Z+3	; 0x03
    2804:	e9 81       	ldd	r30, Y+1	; 0x01
    2806:	fa 81       	ldd	r31, Y+2	; 0x02
    2808:	92 83       	std	Z+2, r25	; 0x02
    280a:	81 83       	std	Z+1, r24	; 0x01
    280c:	e9 81       	ldd	r30, Y+1	; 0x01
    280e:	fa 81       	ldd	r31, Y+2	; 0x02
    2810:	21 81       	ldd	r18, Z+1	; 0x01
    2812:	32 81       	ldd	r19, Z+2	; 0x02
    2814:	89 81       	ldd	r24, Y+1	; 0x01
    2816:	9a 81       	ldd	r25, Y+2	; 0x02
    2818:	03 96       	adiw	r24, 0x03	; 3
    281a:	28 17       	cp	r18, r24
    281c:	39 07       	cpc	r19, r25
    281e:	59 f4       	brne	.+22     	; 0x2836 <vCoRoutineSchedule+0xbe>
    2820:	e9 81       	ldd	r30, Y+1	; 0x01
    2822:	fa 81       	ldd	r31, Y+2	; 0x02
    2824:	01 80       	ldd	r0, Z+1	; 0x01
    2826:	f2 81       	ldd	r31, Z+2	; 0x02
    2828:	e0 2d       	mov	r30, r0
    282a:	82 81       	ldd	r24, Z+2	; 0x02
    282c:	93 81       	ldd	r25, Z+3	; 0x03
    282e:	e9 81       	ldd	r30, Y+1	; 0x01
    2830:	fa 81       	ldd	r31, Y+2	; 0x02
    2832:	92 83       	std	Z+2, r25	; 0x02
    2834:	81 83       	std	Z+1, r24	; 0x01
    2836:	e9 81       	ldd	r30, Y+1	; 0x01
    2838:	fa 81       	ldd	r31, Y+2	; 0x02
    283a:	01 80       	ldd	r0, Z+1	; 0x01
    283c:	f2 81       	ldd	r31, Z+2	; 0x02
    283e:	e0 2d       	mov	r30, r0
    2840:	86 81       	ldd	r24, Z+6	; 0x06
    2842:	97 81       	ldd	r25, Z+7	; 0x07
    2844:	90 93 13 07 	sts	0x0713, r25
    2848:	80 93 12 07 	sts	0x0712, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    284c:	e0 91 12 07 	lds	r30, 0x0712
    2850:	f0 91 13 07 	lds	r31, 0x0713
    2854:	40 81       	ld	r20, Z
    2856:	51 81       	ldd	r21, Z+1	; 0x01
    2858:	80 91 12 07 	lds	r24, 0x0712
    285c:	90 91 13 07 	lds	r25, 0x0713
    2860:	e0 91 12 07 	lds	r30, 0x0712
    2864:	f0 91 13 07 	lds	r31, 0x0713
    2868:	27 89       	ldd	r18, Z+23	; 0x17
    286a:	62 2f       	mov	r22, r18
    286c:	fa 01       	movw	r30, r20
    286e:	09 95       	icall
        }
    }
    2870:	0f 90       	pop	r0
    2872:	0f 90       	pop	r0
    2874:	cf 91       	pop	r28
    2876:	df 91       	pop	r29
    2878:	08 95       	ret

0000287a <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    287a:	df 93       	push	r29
    287c:	cf 93       	push	r28
    287e:	0f 92       	push	r0
    2880:	cd b7       	in	r28, 0x3d	; 61
    2882:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2884:	19 82       	std	Y+1, r1	; 0x01
    2886:	13 c0       	rjmp	.+38     	; 0x28ae <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2888:	89 81       	ldd	r24, Y+1	; 0x01
    288a:	28 2f       	mov	r18, r24
    288c:	30 e0       	ldi	r19, 0x00	; 0
    288e:	c9 01       	movw	r24, r18
    2890:	88 0f       	add	r24, r24
    2892:	99 1f       	adc	r25, r25
    2894:	88 0f       	add	r24, r24
    2896:	99 1f       	adc	r25, r25
    2898:	88 0f       	add	r24, r24
    289a:	99 1f       	adc	r25, r25
    289c:	82 0f       	add	r24, r18
    289e:	93 1f       	adc	r25, r19
    28a0:	85 5e       	subi	r24, 0xE5	; 229
    28a2:	98 4f       	sbci	r25, 0xF8	; 248
    28a4:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    28a8:	89 81       	ldd	r24, Y+1	; 0x01
    28aa:	8f 5f       	subi	r24, 0xFF	; 255
    28ac:	89 83       	std	Y+1, r24	; 0x01
    28ae:	89 81       	ldd	r24, Y+1	; 0x01
    28b0:	82 30       	cpi	r24, 0x02	; 2
    28b2:	50 f3       	brcs	.-44     	; 0x2888 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    28b4:	8d e2       	ldi	r24, 0x2D	; 45
    28b6:	97 e0       	ldi	r25, 0x07	; 7
    28b8:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    28bc:	86 e3       	ldi	r24, 0x36	; 54
    28be:	97 e0       	ldi	r25, 0x07	; 7
    28c0:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    28c4:	8f e3       	ldi	r24, 0x3F	; 63
    28c6:	97 e0       	ldi	r25, 0x07	; 7
    28c8:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    28cc:	8d e2       	ldi	r24, 0x2D	; 45
    28ce:	97 e0       	ldi	r25, 0x07	; 7
    28d0:	90 93 0f 07 	sts	0x070F, r25
    28d4:	80 93 0e 07 	sts	0x070E, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    28d8:	86 e3       	ldi	r24, 0x36	; 54
    28da:	97 e0       	ldi	r25, 0x07	; 7
    28dc:	90 93 11 07 	sts	0x0711, r25
    28e0:	80 93 10 07 	sts	0x0710, r24
    }
    28e4:	0f 90       	pop	r0
    28e6:	cf 91       	pop	r28
    28e8:	df 91       	pop	r29
    28ea:	08 95       	ret

000028ec <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    28ec:	df 93       	push	r29
    28ee:	cf 93       	push	r28
    28f0:	00 d0       	rcall	.+0      	; 0x28f2 <xCoRoutineRemoveFromEventList+0x6>
    28f2:	00 d0       	rcall	.+0      	; 0x28f4 <xCoRoutineRemoveFromEventList+0x8>
    28f4:	0f 92       	push	r0
    28f6:	cd b7       	in	r28, 0x3d	; 61
    28f8:	de b7       	in	r29, 0x3e	; 62
    28fa:	9d 83       	std	Y+5, r25	; 0x05
    28fc:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    28fe:	ec 81       	ldd	r30, Y+4	; 0x04
    2900:	fd 81       	ldd	r31, Y+5	; 0x05
    2902:	05 80       	ldd	r0, Z+5	; 0x05
    2904:	f6 81       	ldd	r31, Z+6	; 0x06
    2906:	e0 2d       	mov	r30, r0
    2908:	86 81       	ldd	r24, Z+6	; 0x06
    290a:	97 81       	ldd	r25, Z+7	; 0x07
    290c:	9b 83       	std	Y+3, r25	; 0x03
    290e:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2910:	8a 81       	ldd	r24, Y+2	; 0x02
    2912:	9b 81       	ldd	r25, Y+3	; 0x03
    2914:	0c 96       	adiw	r24, 0x0c	; 12
    2916:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    291a:	8a 81       	ldd	r24, Y+2	; 0x02
    291c:	9b 81       	ldd	r25, Y+3	; 0x03
    291e:	9c 01       	movw	r18, r24
    2920:	24 5f       	subi	r18, 0xF4	; 244
    2922:	3f 4f       	sbci	r19, 0xFF	; 255
    2924:	8f e3       	ldi	r24, 0x3F	; 63
    2926:	97 e0       	ldi	r25, 0x07	; 7
    2928:	b9 01       	movw	r22, r18
    292a:	0e 94 2d 18 	call	0x305a	; 0x305a <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    292e:	ea 81       	ldd	r30, Y+2	; 0x02
    2930:	fb 81       	ldd	r31, Y+3	; 0x03
    2932:	96 89       	ldd	r25, Z+22	; 0x16
    2934:	e0 91 12 07 	lds	r30, 0x0712
    2938:	f0 91 13 07 	lds	r31, 0x0713
    293c:	86 89       	ldd	r24, Z+22	; 0x16
    293e:	98 17       	cp	r25, r24
    2940:	18 f0       	brcs	.+6      	; 0x2948 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    2942:	81 e0       	ldi	r24, 0x01	; 1
    2944:	89 83       	std	Y+1, r24	; 0x01
    2946:	01 c0       	rjmp	.+2      	; 0x294a <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    2948:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    294a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    294c:	0f 90       	pop	r0
    294e:	0f 90       	pop	r0
    2950:	0f 90       	pop	r0
    2952:	0f 90       	pop	r0
    2954:	0f 90       	pop	r0
    2956:	cf 91       	pop	r28
    2958:	df 91       	pop	r29
    295a:	08 95       	ret

0000295c <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    295c:	df 93       	push	r29
    295e:	cf 93       	push	r28
    2960:	00 d0       	rcall	.+0      	; 0x2962 <xEventGroupCreate+0x6>
    2962:	cd b7       	in	r28, 0x3d	; 61
    2964:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    2966:	8b e0       	ldi	r24, 0x0B	; 11
    2968:	90 e0       	ldi	r25, 0x00	; 0
    296a:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <pvPortMalloc>
    296e:	9a 83       	std	Y+2, r25	; 0x02
    2970:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    2972:	89 81       	ldd	r24, Y+1	; 0x01
    2974:	9a 81       	ldd	r25, Y+2	; 0x02
    2976:	00 97       	sbiw	r24, 0x00	; 0
    2978:	49 f0       	breq	.+18     	; 0x298c <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    297a:	e9 81       	ldd	r30, Y+1	; 0x01
    297c:	fa 81       	ldd	r31, Y+2	; 0x02
    297e:	11 82       	std	Z+1, r1	; 0x01
    2980:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    2982:	89 81       	ldd	r24, Y+1	; 0x01
    2984:	9a 81       	ldd	r25, Y+2	; 0x02
    2986:	02 96       	adiw	r24, 0x02	; 2
    2988:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    298c:	89 81       	ldd	r24, Y+1	; 0x01
    298e:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    2990:	0f 90       	pop	r0
    2992:	0f 90       	pop	r0
    2994:	cf 91       	pop	r28
    2996:	df 91       	pop	r29
    2998:	08 95       	ret

0000299a <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    299a:	df 93       	push	r29
    299c:	cf 93       	push	r28
    299e:	cd b7       	in	r28, 0x3d	; 61
    29a0:	de b7       	in	r29, 0x3e	; 62
    29a2:	60 97       	sbiw	r28, 0x10	; 16
    29a4:	0f b6       	in	r0, 0x3f	; 63
    29a6:	f8 94       	cli
    29a8:	de bf       	out	0x3e, r29	; 62
    29aa:	0f be       	out	0x3f, r0	; 63
    29ac:	cd bf       	out	0x3d, r28	; 61
    29ae:	9a 87       	std	Y+10, r25	; 0x0a
    29b0:	89 87       	std	Y+9, r24	; 0x09
    29b2:	7c 87       	std	Y+12, r23	; 0x0c
    29b4:	6b 87       	std	Y+11, r22	; 0x0b
    29b6:	5e 87       	std	Y+14, r21	; 0x0e
    29b8:	4d 87       	std	Y+13, r20	; 0x0d
    29ba:	38 8b       	std	Y+16, r19	; 0x10
    29bc:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    29be:	89 85       	ldd	r24, Y+9	; 0x09
    29c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    29c2:	9c 83       	std	Y+4, r25	; 0x04
    29c4:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    29c6:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    29c8:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    29cc:	eb 81       	ldd	r30, Y+3	; 0x03
    29ce:	fc 81       	ldd	r31, Y+4	; 0x04
    29d0:	80 81       	ld	r24, Z
    29d2:	91 81       	ldd	r25, Z+1	; 0x01
    29d4:	98 87       	std	Y+8, r25	; 0x08
    29d6:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    29d8:	89 85       	ldd	r24, Y+9	; 0x09
    29da:	9a 85       	ldd	r25, Y+10	; 0x0a
    29dc:	2b 85       	ldd	r18, Y+11	; 0x0b
    29de:	3c 85       	ldd	r19, Y+12	; 0x0c
    29e0:	b9 01       	movw	r22, r18
    29e2:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    29e6:	2f 81       	ldd	r18, Y+7	; 0x07
    29e8:	38 85       	ldd	r19, Y+8	; 0x08
    29ea:	8b 85       	ldd	r24, Y+11	; 0x0b
    29ec:	9c 85       	ldd	r25, Y+12	; 0x0c
    29ee:	28 2b       	or	r18, r24
    29f0:	39 2b       	or	r19, r25
    29f2:	8d 85       	ldd	r24, Y+13	; 0x0d
    29f4:	9e 85       	ldd	r25, Y+14	; 0x0e
    29f6:	28 23       	and	r18, r24
    29f8:	39 23       	and	r19, r25
    29fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    29fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    29fe:	28 17       	cp	r18, r24
    2a00:	39 07       	cpc	r19, r25
    2a02:	c9 f4       	brne	.+50     	; 0x2a36 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    2a04:	2f 81       	ldd	r18, Y+7	; 0x07
    2a06:	38 85       	ldd	r19, Y+8	; 0x08
    2a08:	8b 85       	ldd	r24, Y+11	; 0x0b
    2a0a:	9c 85       	ldd	r25, Y+12	; 0x0c
    2a0c:	82 2b       	or	r24, r18
    2a0e:	93 2b       	or	r25, r19
    2a10:	9e 83       	std	Y+6, r25	; 0x06
    2a12:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2a14:	eb 81       	ldd	r30, Y+3	; 0x03
    2a16:	fc 81       	ldd	r31, Y+4	; 0x04
    2a18:	20 81       	ld	r18, Z
    2a1a:	31 81       	ldd	r19, Z+1	; 0x01
    2a1c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a1e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a20:	80 95       	com	r24
    2a22:	90 95       	com	r25
    2a24:	82 23       	and	r24, r18
    2a26:	93 23       	and	r25, r19
    2a28:	eb 81       	ldd	r30, Y+3	; 0x03
    2a2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a2c:	91 83       	std	Z+1, r25	; 0x01
    2a2e:	80 83       	st	Z, r24

            xTicksToWait = 0;
    2a30:	18 8a       	std	Y+16, r1	; 0x10
    2a32:	1f 86       	std	Y+15, r1	; 0x0f
    2a34:	1e c0       	rjmp	.+60     	; 0x2a72 <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    2a36:	8f 85       	ldd	r24, Y+15	; 0x0f
    2a38:	98 89       	ldd	r25, Y+16	; 0x10
    2a3a:	00 97       	sbiw	r24, 0x00	; 0
    2a3c:	91 f0       	breq	.+36     	; 0x2a62 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    2a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a40:	9c 81       	ldd	r25, Y+4	; 0x04
    2a42:	bc 01       	movw	r22, r24
    2a44:	6e 5f       	subi	r22, 0xFE	; 254
    2a46:	7f 4f       	sbci	r23, 0xFF	; 255
    2a48:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a4a:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a4c:	9c 01       	movw	r18, r24
    2a4e:	35 60       	ori	r19, 0x05	; 5
    2a50:	4f 85       	ldd	r20, Y+15	; 0x0f
    2a52:	58 89       	ldd	r21, Y+16	; 0x10
    2a54:	cb 01       	movw	r24, r22
    2a56:	b9 01       	movw	r22, r18
    2a58:	0e 94 cf 29 	call	0x539e	; 0x539e <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    2a5c:	1e 82       	std	Y+6, r1	; 0x06
    2a5e:	1d 82       	std	Y+5, r1	; 0x05
    2a60:	08 c0       	rjmp	.+16     	; 0x2a72 <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    2a62:	eb 81       	ldd	r30, Y+3	; 0x03
    2a64:	fc 81       	ldd	r31, Y+4	; 0x04
    2a66:	80 81       	ld	r24, Z
    2a68:	91 81       	ldd	r25, Z+1	; 0x01
    2a6a:	9e 83       	std	Y+6, r25	; 0x06
    2a6c:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    2a6e:	81 e0       	ldi	r24, 0x01	; 1
    2a70:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    2a72:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    2a76:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    2a78:	8f 85       	ldd	r24, Y+15	; 0x0f
    2a7a:	98 89       	ldd	r25, Y+16	; 0x10
    2a7c:	00 97       	sbiw	r24, 0x00	; 0
    2a7e:	09 f4       	brne	.+2      	; 0x2a82 <xEventGroupSync+0xe8>
    2a80:	3a c0       	rjmp	.+116    	; 0x2af6 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    2a82:	8a 81       	ldd	r24, Y+2	; 0x02
    2a84:	88 23       	and	r24, r24
    2a86:	11 f4       	brne	.+4      	; 0x2a8c <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    2a88:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    2a8c:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <uxTaskResetEventItemValue>
    2a90:	9e 83       	std	Y+6, r25	; 0x06
    2a92:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2a94:	8d 81       	ldd	r24, Y+5	; 0x05
    2a96:	9e 81       	ldd	r25, Y+6	; 0x06
    2a98:	80 70       	andi	r24, 0x00	; 0
    2a9a:	92 70       	andi	r25, 0x02	; 2
    2a9c:	00 97       	sbiw	r24, 0x00	; 0
    2a9e:	31 f5       	brne	.+76     	; 0x2aec <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    2aa0:	0f b6       	in	r0, 0x3f	; 63
    2aa2:	f8 94       	cli
    2aa4:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    2aa6:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aaa:	80 81       	ld	r24, Z
    2aac:	91 81       	ldd	r25, Z+1	; 0x01
    2aae:	9e 83       	std	Y+6, r25	; 0x06
    2ab0:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2ab2:	2d 81       	ldd	r18, Y+5	; 0x05
    2ab4:	3e 81       	ldd	r19, Y+6	; 0x06
    2ab6:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ab8:	9e 85       	ldd	r25, Y+14	; 0x0e
    2aba:	28 23       	and	r18, r24
    2abc:	39 23       	and	r19, r25
    2abe:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ac0:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ac2:	28 17       	cp	r18, r24
    2ac4:	39 07       	cpc	r19, r25
    2ac6:	71 f4       	brne	.+28     	; 0x2ae4 <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2ac8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aca:	fc 81       	ldd	r31, Y+4	; 0x04
    2acc:	20 81       	ld	r18, Z
    2ace:	31 81       	ldd	r19, Z+1	; 0x01
    2ad0:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ad2:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ad4:	80 95       	com	r24
    2ad6:	90 95       	com	r25
    2ad8:	82 23       	and	r24, r18
    2ada:	93 23       	and	r25, r19
    2adc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ade:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae0:	91 83       	std	Z+1, r25	; 0x01
    2ae2:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    2ae4:	0f 90       	pop	r0
    2ae6:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    2ae8:	81 e0       	ldi	r24, 0x01	; 1
    2aea:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2aec:	8d 81       	ldd	r24, Y+5	; 0x05
    2aee:	9e 81       	ldd	r25, Y+6	; 0x06
    2af0:	90 70       	andi	r25, 0x00	; 0
    2af2:	9e 83       	std	Y+6, r25	; 0x06
    2af4:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    2af6:	8d 81       	ldd	r24, Y+5	; 0x05
    2af8:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2afa:	60 96       	adiw	r28, 0x10	; 16
    2afc:	0f b6       	in	r0, 0x3f	; 63
    2afe:	f8 94       	cli
    2b00:	de bf       	out	0x3e, r29	; 62
    2b02:	0f be       	out	0x3f, r0	; 63
    2b04:	cd bf       	out	0x3d, r28	; 61
    2b06:	cf 91       	pop	r28
    2b08:	df 91       	pop	r29
    2b0a:	08 95       	ret

00002b0c <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    2b0c:	0f 93       	push	r16
    2b0e:	1f 93       	push	r17
    2b10:	df 93       	push	r29
    2b12:	cf 93       	push	r28
    2b14:	cd b7       	in	r28, 0x3d	; 61
    2b16:	de b7       	in	r29, 0x3e	; 62
    2b18:	63 97       	sbiw	r28, 0x13	; 19
    2b1a:	0f b6       	in	r0, 0x3f	; 63
    2b1c:	f8 94       	cli
    2b1e:	de bf       	out	0x3e, r29	; 62
    2b20:	0f be       	out	0x3f, r0	; 63
    2b22:	cd bf       	out	0x3d, r28	; 61
    2b24:	9d 87       	std	Y+13, r25	; 0x0d
    2b26:	8c 87       	std	Y+12, r24	; 0x0c
    2b28:	7f 87       	std	Y+15, r23	; 0x0f
    2b2a:	6e 87       	std	Y+14, r22	; 0x0e
    2b2c:	48 8b       	std	Y+16, r20	; 0x10
    2b2e:	29 8b       	std	Y+17, r18	; 0x11
    2b30:	1b 8b       	std	Y+19, r17	; 0x13
    2b32:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    2b34:	8c 85       	ldd	r24, Y+12	; 0x0c
    2b36:	9d 85       	ldd	r25, Y+13	; 0x0d
    2b38:	9b 87       	std	Y+11, r25	; 0x0b
    2b3a:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    2b3c:	1f 82       	std	Y+7, r1	; 0x07
    2b3e:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    2b40:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    2b42:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2b46:	ea 85       	ldd	r30, Y+10	; 0x0a
    2b48:	fb 85       	ldd	r31, Y+11	; 0x0b
    2b4a:	80 81       	ld	r24, Z
    2b4c:	91 81       	ldd	r25, Z+1	; 0x01
    2b4e:	9a 83       	std	Y+2, r25	; 0x02
    2b50:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2b52:	89 81       	ldd	r24, Y+1	; 0x01
    2b54:	9a 81       	ldd	r25, Y+2	; 0x02
    2b56:	2e 85       	ldd	r18, Y+14	; 0x0e
    2b58:	3f 85       	ldd	r19, Y+15	; 0x0f
    2b5a:	b9 01       	movw	r22, r18
    2b5c:	49 89       	ldd	r20, Y+17	; 0x11
    2b5e:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <prvTestWaitCondition>
    2b62:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    2b64:	8d 81       	ldd	r24, Y+5	; 0x05
    2b66:	88 23       	and	r24, r24
    2b68:	c1 f0       	breq	.+48     	; 0x2b9a <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    2b6a:	89 81       	ldd	r24, Y+1	; 0x01
    2b6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b6e:	99 87       	std	Y+9, r25	; 0x09
    2b70:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    2b72:	1b 8a       	std	Y+19, r1	; 0x13
    2b74:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    2b76:	88 89       	ldd	r24, Y+16	; 0x10
    2b78:	88 23       	and	r24, r24
    2b7a:	e9 f1       	breq	.+122    	; 0x2bf6 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2b7c:	ea 85       	ldd	r30, Y+10	; 0x0a
    2b7e:	fb 85       	ldd	r31, Y+11	; 0x0b
    2b80:	20 81       	ld	r18, Z
    2b82:	31 81       	ldd	r19, Z+1	; 0x01
    2b84:	8e 85       	ldd	r24, Y+14	; 0x0e
    2b86:	9f 85       	ldd	r25, Y+15	; 0x0f
    2b88:	80 95       	com	r24
    2b8a:	90 95       	com	r25
    2b8c:	82 23       	and	r24, r18
    2b8e:	93 23       	and	r25, r19
    2b90:	ea 85       	ldd	r30, Y+10	; 0x0a
    2b92:	fb 85       	ldd	r31, Y+11	; 0x0b
    2b94:	91 83       	std	Z+1, r25	; 0x01
    2b96:	80 83       	st	Z, r24
    2b98:	2e c0       	rjmp	.+92     	; 0x2bf6 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    2b9a:	8a 89       	ldd	r24, Y+18	; 0x12
    2b9c:	9b 89       	ldd	r25, Y+19	; 0x13
    2b9e:	00 97       	sbiw	r24, 0x00	; 0
    2ba0:	39 f4       	brne	.+14     	; 0x2bb0 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    2ba2:	89 81       	ldd	r24, Y+1	; 0x01
    2ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ba6:	99 87       	std	Y+9, r25	; 0x09
    2ba8:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    2baa:	81 e0       	ldi	r24, 0x01	; 1
    2bac:	8b 83       	std	Y+3, r24	; 0x03
    2bae:	23 c0       	rjmp	.+70     	; 0x2bf6 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    2bb0:	88 89       	ldd	r24, Y+16	; 0x10
    2bb2:	88 23       	and	r24, r24
    2bb4:	29 f0       	breq	.+10     	; 0x2bc0 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2bb6:	8e 81       	ldd	r24, Y+6	; 0x06
    2bb8:	9f 81       	ldd	r25, Y+7	; 0x07
    2bba:	91 60       	ori	r25, 0x01	; 1
    2bbc:	9f 83       	std	Y+7, r25	; 0x07
    2bbe:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    2bc0:	89 89       	ldd	r24, Y+17	; 0x11
    2bc2:	88 23       	and	r24, r24
    2bc4:	29 f0       	breq	.+10     	; 0x2bd0 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    2bc6:	8e 81       	ldd	r24, Y+6	; 0x06
    2bc8:	9f 81       	ldd	r25, Y+7	; 0x07
    2bca:	94 60       	ori	r25, 0x04	; 4
    2bcc:	9f 83       	std	Y+7, r25	; 0x07
    2bce:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2bd0:	8a 85       	ldd	r24, Y+10	; 0x0a
    2bd2:	9b 85       	ldd	r25, Y+11	; 0x0b
    2bd4:	bc 01       	movw	r22, r24
    2bd6:	6e 5f       	subi	r22, 0xFE	; 254
    2bd8:	7f 4f       	sbci	r23, 0xFF	; 255
    2bda:	2e 85       	ldd	r18, Y+14	; 0x0e
    2bdc:	3f 85       	ldd	r19, Y+15	; 0x0f
    2bde:	8e 81       	ldd	r24, Y+6	; 0x06
    2be0:	9f 81       	ldd	r25, Y+7	; 0x07
    2be2:	28 2b       	or	r18, r24
    2be4:	39 2b       	or	r19, r25
    2be6:	4a 89       	ldd	r20, Y+18	; 0x12
    2be8:	5b 89       	ldd	r21, Y+19	; 0x13
    2bea:	cb 01       	movw	r24, r22
    2bec:	b9 01       	movw	r22, r18
    2bee:	0e 94 cf 29 	call	0x539e	; 0x539e <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    2bf2:	19 86       	std	Y+9, r1	; 0x09
    2bf4:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    2bf6:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    2bfa:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    2bfc:	8a 89       	ldd	r24, Y+18	; 0x12
    2bfe:	9b 89       	ldd	r25, Y+19	; 0x13
    2c00:	00 97       	sbiw	r24, 0x00	; 0
    2c02:	09 f4       	brne	.+2      	; 0x2c06 <xEventGroupWaitBits+0xfa>
    2c04:	3c c0       	rjmp	.+120    	; 0x2c7e <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    2c06:	8c 81       	ldd	r24, Y+4	; 0x04
    2c08:	88 23       	and	r24, r24
    2c0a:	11 f4       	brne	.+4      	; 0x2c10 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    2c0c:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    2c10:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <uxTaskResetEventItemValue>
    2c14:	99 87       	std	Y+9, r25	; 0x09
    2c16:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2c18:	88 85       	ldd	r24, Y+8	; 0x08
    2c1a:	99 85       	ldd	r25, Y+9	; 0x09
    2c1c:	80 70       	andi	r24, 0x00	; 0
    2c1e:	92 70       	andi	r25, 0x02	; 2
    2c20:	00 97       	sbiw	r24, 0x00	; 0
    2c22:	41 f5       	brne	.+80     	; 0x2c74 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    2c24:	0f b6       	in	r0, 0x3f	; 63
    2c26:	f8 94       	cli
    2c28:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    2c2a:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c2c:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c2e:	80 81       	ld	r24, Z
    2c30:	91 81       	ldd	r25, Z+1	; 0x01
    2c32:	99 87       	std	Y+9, r25	; 0x09
    2c34:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2c36:	88 85       	ldd	r24, Y+8	; 0x08
    2c38:	99 85       	ldd	r25, Y+9	; 0x09
    2c3a:	2e 85       	ldd	r18, Y+14	; 0x0e
    2c3c:	3f 85       	ldd	r19, Y+15	; 0x0f
    2c3e:	b9 01       	movw	r22, r18
    2c40:	49 89       	ldd	r20, Y+17	; 0x11
    2c42:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <prvTestWaitCondition>
    2c46:	88 23       	and	r24, r24
    2c48:	89 f0       	breq	.+34     	; 0x2c6c <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    2c4a:	88 89       	ldd	r24, Y+16	; 0x10
    2c4c:	88 23       	and	r24, r24
    2c4e:	71 f0       	breq	.+28     	; 0x2c6c <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2c50:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c52:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c54:	20 81       	ld	r18, Z
    2c56:	31 81       	ldd	r19, Z+1	; 0x01
    2c58:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c5a:	9f 85       	ldd	r25, Y+15	; 0x0f
    2c5c:	80 95       	com	r24
    2c5e:	90 95       	com	r25
    2c60:	82 23       	and	r24, r18
    2c62:	93 23       	and	r25, r19
    2c64:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c66:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c68:	91 83       	std	Z+1, r25	; 0x01
    2c6a:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    2c6c:	81 e0       	ldi	r24, 0x01	; 1
    2c6e:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    2c70:	0f 90       	pop	r0
    2c72:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2c74:	88 85       	ldd	r24, Y+8	; 0x08
    2c76:	99 85       	ldd	r25, Y+9	; 0x09
    2c78:	90 70       	andi	r25, 0x00	; 0
    2c7a:	99 87       	std	Y+9, r25	; 0x09
    2c7c:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    2c7e:	88 85       	ldd	r24, Y+8	; 0x08
    2c80:	99 85       	ldd	r25, Y+9	; 0x09
}
    2c82:	63 96       	adiw	r28, 0x13	; 19
    2c84:	0f b6       	in	r0, 0x3f	; 63
    2c86:	f8 94       	cli
    2c88:	de bf       	out	0x3e, r29	; 62
    2c8a:	0f be       	out	0x3f, r0	; 63
    2c8c:	cd bf       	out	0x3d, r28	; 61
    2c8e:	cf 91       	pop	r28
    2c90:	df 91       	pop	r29
    2c92:	1f 91       	pop	r17
    2c94:	0f 91       	pop	r16
    2c96:	08 95       	ret

00002c98 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    2c98:	df 93       	push	r29
    2c9a:	cf 93       	push	r28
    2c9c:	cd b7       	in	r28, 0x3d	; 61
    2c9e:	de b7       	in	r29, 0x3e	; 62
    2ca0:	28 97       	sbiw	r28, 0x08	; 8
    2ca2:	0f b6       	in	r0, 0x3f	; 63
    2ca4:	f8 94       	cli
    2ca6:	de bf       	out	0x3e, r29	; 62
    2ca8:	0f be       	out	0x3f, r0	; 63
    2caa:	cd bf       	out	0x3d, r28	; 61
    2cac:	9e 83       	std	Y+6, r25	; 0x06
    2cae:	8d 83       	std	Y+5, r24	; 0x05
    2cb0:	78 87       	std	Y+8, r23	; 0x08
    2cb2:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    2cb4:	8d 81       	ldd	r24, Y+5	; 0x05
    2cb6:	9e 81       	ldd	r25, Y+6	; 0x06
    2cb8:	9c 83       	std	Y+4, r25	; 0x04
    2cba:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    2cbc:	0f b6       	in	r0, 0x3f	; 63
    2cbe:	f8 94       	cli
    2cc0:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    2cc2:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc4:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc6:	80 81       	ld	r24, Z
    2cc8:	91 81       	ldd	r25, Z+1	; 0x01
    2cca:	9a 83       	std	Y+2, r25	; 0x02
    2ccc:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    2cce:	eb 81       	ldd	r30, Y+3	; 0x03
    2cd0:	fc 81       	ldd	r31, Y+4	; 0x04
    2cd2:	20 81       	ld	r18, Z
    2cd4:	31 81       	ldd	r19, Z+1	; 0x01
    2cd6:	8f 81       	ldd	r24, Y+7	; 0x07
    2cd8:	98 85       	ldd	r25, Y+8	; 0x08
    2cda:	80 95       	com	r24
    2cdc:	90 95       	com	r25
    2cde:	82 23       	and	r24, r18
    2ce0:	93 23       	and	r25, r19
    2ce2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ce6:	91 83       	std	Z+1, r25	; 0x01
    2ce8:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    2cea:	0f 90       	pop	r0
    2cec:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2cee:	89 81       	ldd	r24, Y+1	; 0x01
    2cf0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2cf2:	28 96       	adiw	r28, 0x08	; 8
    2cf4:	0f b6       	in	r0, 0x3f	; 63
    2cf6:	f8 94       	cli
    2cf8:	de bf       	out	0x3e, r29	; 62
    2cfa:	0f be       	out	0x3f, r0	; 63
    2cfc:	cd bf       	out	0x3d, r28	; 61
    2cfe:	cf 91       	pop	r28
    2d00:	df 91       	pop	r29
    2d02:	08 95       	ret

00002d04 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    2d04:	df 93       	push	r29
    2d06:	cf 93       	push	r28
    2d08:	cd b7       	in	r28, 0x3d	; 61
    2d0a:	de b7       	in	r29, 0x3e	; 62
    2d0c:	27 97       	sbiw	r28, 0x07	; 7
    2d0e:	0f b6       	in	r0, 0x3f	; 63
    2d10:	f8 94       	cli
    2d12:	de bf       	out	0x3e, r29	; 62
    2d14:	0f be       	out	0x3f, r0	; 63
    2d16:	cd bf       	out	0x3d, r28	; 61
    2d18:	9f 83       	std	Y+7, r25	; 0x07
    2d1a:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    2d1c:	8e 81       	ldd	r24, Y+6	; 0x06
    2d1e:	9f 81       	ldd	r25, Y+7	; 0x07
    2d20:	9c 83       	std	Y+4, r25	; 0x04
    2d22:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d24:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    2d26:	eb 81       	ldd	r30, Y+3	; 0x03
    2d28:	fc 81       	ldd	r31, Y+4	; 0x04
    2d2a:	80 81       	ld	r24, Z
    2d2c:	91 81       	ldd	r25, Z+1	; 0x01
    2d2e:	9a 83       	std	Y+2, r25	; 0x02
    2d30:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    2d32:	89 81       	ldd	r24, Y+1	; 0x01
    2d34:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    2d36:	27 96       	adiw	r28, 0x07	; 7
    2d38:	0f b6       	in	r0, 0x3f	; 63
    2d3a:	f8 94       	cli
    2d3c:	de bf       	out	0x3e, r29	; 62
    2d3e:	0f be       	out	0x3f, r0	; 63
    2d40:	cd bf       	out	0x3d, r28	; 61
    2d42:	cf 91       	pop	r28
    2d44:	df 91       	pop	r29
    2d46:	08 95       	ret

00002d48 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    2d48:	df 93       	push	r29
    2d4a:	cf 93       	push	r28
    2d4c:	cd b7       	in	r28, 0x3d	; 61
    2d4e:	de b7       	in	r29, 0x3e	; 62
    2d50:	65 97       	sbiw	r28, 0x15	; 21
    2d52:	0f b6       	in	r0, 0x3f	; 63
    2d54:	f8 94       	cli
    2d56:	de bf       	out	0x3e, r29	; 62
    2d58:	0f be       	out	0x3f, r0	; 63
    2d5a:	cd bf       	out	0x3d, r28	; 61
    2d5c:	9b 8b       	std	Y+19, r25	; 0x13
    2d5e:	8a 8b       	std	Y+18, r24	; 0x12
    2d60:	7d 8b       	std	Y+21, r23	; 0x15
    2d62:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2d64:	19 86       	std	Y+9, r1	; 0x09
    2d66:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    2d68:	8a 89       	ldd	r24, Y+18	; 0x12
    2d6a:	9b 89       	ldd	r25, Y+19	; 0x13
    2d6c:	9b 83       	std	Y+3, r25	; 0x03
    2d6e:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    2d70:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    2d72:	8a 81       	ldd	r24, Y+2	; 0x02
    2d74:	9b 81       	ldd	r25, Y+3	; 0x03
    2d76:	02 96       	adiw	r24, 0x02	; 2
    2d78:	9b 87       	std	Y+11, r25	; 0x0b
    2d7a:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2d7c:	8a 85       	ldd	r24, Y+10	; 0x0a
    2d7e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2d80:	03 96       	adiw	r24, 0x03	; 3
    2d82:	9d 87       	std	Y+13, r25	; 0x0d
    2d84:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    2d86:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    2d8a:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d8c:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d8e:	85 81       	ldd	r24, Z+5	; 0x05
    2d90:	96 81       	ldd	r25, Z+6	; 0x06
    2d92:	99 8b       	std	Y+17, r25	; 0x11
    2d94:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    2d96:	ea 81       	ldd	r30, Y+2	; 0x02
    2d98:	fb 81       	ldd	r31, Y+3	; 0x03
    2d9a:	20 81       	ld	r18, Z
    2d9c:	31 81       	ldd	r19, Z+1	; 0x01
    2d9e:	8c 89       	ldd	r24, Y+20	; 0x14
    2da0:	9d 89       	ldd	r25, Y+21	; 0x15
    2da2:	82 2b       	or	r24, r18
    2da4:	93 2b       	or	r25, r19
    2da6:	ea 81       	ldd	r30, Y+2	; 0x02
    2da8:	fb 81       	ldd	r31, Y+3	; 0x03
    2daa:	91 83       	std	Z+1, r25	; 0x01
    2dac:	80 83       	st	Z, r24
    2dae:	59 c0       	rjmp	.+178    	; 0x2e62 <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    2db0:	e8 89       	ldd	r30, Y+16	; 0x10
    2db2:	f9 89       	ldd	r31, Y+17	; 0x11
    2db4:	82 81       	ldd	r24, Z+2	; 0x02
    2db6:	93 81       	ldd	r25, Z+3	; 0x03
    2db8:	9f 87       	std	Y+15, r25	; 0x0f
    2dba:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2dbc:	e8 89       	ldd	r30, Y+16	; 0x10
    2dbe:	f9 89       	ldd	r31, Y+17	; 0x11
    2dc0:	80 81       	ld	r24, Z
    2dc2:	91 81       	ldd	r25, Z+1	; 0x01
    2dc4:	9f 83       	std	Y+7, r25	; 0x07
    2dc6:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    2dc8:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2dca:	8e 81       	ldd	r24, Y+6	; 0x06
    2dcc:	9f 81       	ldd	r25, Y+7	; 0x07
    2dce:	80 70       	andi	r24, 0x00	; 0
    2dd0:	9d 83       	std	Y+5, r25	; 0x05
    2dd2:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    2dd4:	8e 81       	ldd	r24, Y+6	; 0x06
    2dd6:	9f 81       	ldd	r25, Y+7	; 0x07
    2dd8:	90 70       	andi	r25, 0x00	; 0
    2dda:	9f 83       	std	Y+7, r25	; 0x07
    2ddc:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2dde:	8c 81       	ldd	r24, Y+4	; 0x04
    2de0:	9d 81       	ldd	r25, Y+5	; 0x05
    2de2:	80 70       	andi	r24, 0x00	; 0
    2de4:	94 70       	andi	r25, 0x04	; 4
    2de6:	00 97       	sbiw	r24, 0x00	; 0
    2de8:	69 f4       	brne	.+26     	; 0x2e04 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2dea:	ea 81       	ldd	r30, Y+2	; 0x02
    2dec:	fb 81       	ldd	r31, Y+3	; 0x03
    2dee:	20 81       	ld	r18, Z
    2df0:	31 81       	ldd	r19, Z+1	; 0x01
    2df2:	8e 81       	ldd	r24, Y+6	; 0x06
    2df4:	9f 81       	ldd	r25, Y+7	; 0x07
    2df6:	82 23       	and	r24, r18
    2df8:	93 23       	and	r25, r19
    2dfa:	00 97       	sbiw	r24, 0x00	; 0
    2dfc:	91 f0       	breq	.+36     	; 0x2e22 <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    2dfe:	81 e0       	ldi	r24, 0x01	; 1
    2e00:	89 83       	std	Y+1, r24	; 0x01
    2e02:	0f c0       	rjmp	.+30     	; 0x2e22 <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    2e04:	ea 81       	ldd	r30, Y+2	; 0x02
    2e06:	fb 81       	ldd	r31, Y+3	; 0x03
    2e08:	20 81       	ld	r18, Z
    2e0a:	31 81       	ldd	r19, Z+1	; 0x01
    2e0c:	8e 81       	ldd	r24, Y+6	; 0x06
    2e0e:	9f 81       	ldd	r25, Y+7	; 0x07
    2e10:	28 23       	and	r18, r24
    2e12:	39 23       	and	r19, r25
    2e14:	8e 81       	ldd	r24, Y+6	; 0x06
    2e16:	9f 81       	ldd	r25, Y+7	; 0x07
    2e18:	28 17       	cp	r18, r24
    2e1a:	39 07       	cpc	r19, r25
    2e1c:	11 f4       	brne	.+4      	; 0x2e22 <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    2e1e:	81 e0       	ldi	r24, 0x01	; 1
    2e20:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    2e22:	89 81       	ldd	r24, Y+1	; 0x01
    2e24:	88 23       	and	r24, r24
    2e26:	c9 f0       	breq	.+50     	; 0x2e5a <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2e28:	8c 81       	ldd	r24, Y+4	; 0x04
    2e2a:	9d 81       	ldd	r25, Y+5	; 0x05
    2e2c:	80 70       	andi	r24, 0x00	; 0
    2e2e:	91 70       	andi	r25, 0x01	; 1
    2e30:	00 97       	sbiw	r24, 0x00	; 0
    2e32:	41 f0       	breq	.+16     	; 0x2e44 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    2e34:	88 85       	ldd	r24, Y+8	; 0x08
    2e36:	99 85       	ldd	r25, Y+9	; 0x09
    2e38:	2e 81       	ldd	r18, Y+6	; 0x06
    2e3a:	3f 81       	ldd	r19, Y+7	; 0x07
    2e3c:	82 2b       	or	r24, r18
    2e3e:	93 2b       	or	r25, r19
    2e40:	99 87       	std	Y+9, r25	; 0x09
    2e42:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    2e44:	ea 81       	ldd	r30, Y+2	; 0x02
    2e46:	fb 81       	ldd	r31, Y+3	; 0x03
    2e48:	80 81       	ld	r24, Z
    2e4a:	91 81       	ldd	r25, Z+1	; 0x01
    2e4c:	9c 01       	movw	r18, r24
    2e4e:	32 60       	ori	r19, 0x02	; 2
    2e50:	88 89       	ldd	r24, Y+16	; 0x10
    2e52:	99 89       	ldd	r25, Y+17	; 0x11
    2e54:	b9 01       	movw	r22, r18
    2e56:	0e 94 da 2b 	call	0x57b4	; 0x57b4 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    2e5a:	8e 85       	ldd	r24, Y+14	; 0x0e
    2e5c:	9f 85       	ldd	r25, Y+15	; 0x0f
    2e5e:	99 8b       	std	Y+17, r25	; 0x11
    2e60:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    2e62:	28 89       	ldd	r18, Y+16	; 0x10
    2e64:	39 89       	ldd	r19, Y+17	; 0x11
    2e66:	8c 85       	ldd	r24, Y+12	; 0x0c
    2e68:	9d 85       	ldd	r25, Y+13	; 0x0d
    2e6a:	28 17       	cp	r18, r24
    2e6c:	39 07       	cpc	r19, r25
    2e6e:	09 f0       	breq	.+2      	; 0x2e72 <xEventGroupSetBits+0x12a>
    2e70:	9f cf       	rjmp	.-194    	; 0x2db0 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    2e72:	ea 81       	ldd	r30, Y+2	; 0x02
    2e74:	fb 81       	ldd	r31, Y+3	; 0x03
    2e76:	20 81       	ld	r18, Z
    2e78:	31 81       	ldd	r19, Z+1	; 0x01
    2e7a:	88 85       	ldd	r24, Y+8	; 0x08
    2e7c:	99 85       	ldd	r25, Y+9	; 0x09
    2e7e:	80 95       	com	r24
    2e80:	90 95       	com	r25
    2e82:	82 23       	and	r24, r18
    2e84:	93 23       	and	r25, r19
    2e86:	ea 81       	ldd	r30, Y+2	; 0x02
    2e88:	fb 81       	ldd	r31, Y+3	; 0x03
    2e8a:	91 83       	std	Z+1, r25	; 0x01
    2e8c:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    2e8e:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    2e92:	ea 81       	ldd	r30, Y+2	; 0x02
    2e94:	fb 81       	ldd	r31, Y+3	; 0x03
    2e96:	80 81       	ld	r24, Z
    2e98:	91 81       	ldd	r25, Z+1	; 0x01
}
    2e9a:	65 96       	adiw	r28, 0x15	; 21
    2e9c:	0f b6       	in	r0, 0x3f	; 63
    2e9e:	f8 94       	cli
    2ea0:	de bf       	out	0x3e, r29	; 62
    2ea2:	0f be       	out	0x3f, r0	; 63
    2ea4:	cd bf       	out	0x3d, r28	; 61
    2ea6:	cf 91       	pop	r28
    2ea8:	df 91       	pop	r29
    2eaa:	08 95       	ret

00002eac <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2eac:	df 93       	push	r29
    2eae:	cf 93       	push	r28
    2eb0:	00 d0       	rcall	.+0      	; 0x2eb2 <vEventGroupDelete+0x6>
    2eb2:	00 d0       	rcall	.+0      	; 0x2eb4 <vEventGroupDelete+0x8>
    2eb4:	00 d0       	rcall	.+0      	; 0x2eb6 <vEventGroupDelete+0xa>
    2eb6:	cd b7       	in	r28, 0x3d	; 61
    2eb8:	de b7       	in	r29, 0x3e	; 62
    2eba:	9e 83       	std	Y+6, r25	; 0x06
    2ebc:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    2ebe:	8d 81       	ldd	r24, Y+5	; 0x05
    2ec0:	9e 81       	ldd	r25, Y+6	; 0x06
    2ec2:	9c 83       	std	Y+4, r25	; 0x04
    2ec4:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    2ec6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eca:	02 96       	adiw	r24, 0x02	; 2
    2ecc:	9a 83       	std	Y+2, r25	; 0x02
    2ece:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    2ed0:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
    2ed4:	08 c0       	rjmp	.+16     	; 0x2ee6 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2ed6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ed8:	fa 81       	ldd	r31, Y+2	; 0x02
    2eda:	85 81       	ldd	r24, Z+5	; 0x05
    2edc:	96 81       	ldd	r25, Z+6	; 0x06
    2ede:	60 e0       	ldi	r22, 0x00	; 0
    2ee0:	72 e0       	ldi	r23, 0x02	; 2
    2ee2:	0e 94 da 2b 	call	0x57b4	; 0x57b4 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2ee6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ee8:	fa 81       	ldd	r31, Y+2	; 0x02
    2eea:	80 81       	ld	r24, Z
    2eec:	88 23       	and	r24, r24
    2eee:	99 f7       	brne	.-26     	; 0x2ed6 <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    2ef0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ef2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ef4:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    2ef8:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
}
    2efc:	26 96       	adiw	r28, 0x06	; 6
    2efe:	0f b6       	in	r0, 0x3f	; 63
    2f00:	f8 94       	cli
    2f02:	de bf       	out	0x3e, r29	; 62
    2f04:	0f be       	out	0x3f, r0	; 63
    2f06:	cd bf       	out	0x3d, r28	; 61
    2f08:	cf 91       	pop	r28
    2f0a:	df 91       	pop	r29
    2f0c:	08 95       	ret

00002f0e <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    2f0e:	df 93       	push	r29
    2f10:	cf 93       	push	r28
    2f12:	00 d0       	rcall	.+0      	; 0x2f14 <vEventGroupSetBitsCallback+0x6>
    2f14:	00 d0       	rcall	.+0      	; 0x2f16 <vEventGroupSetBitsCallback+0x8>
    2f16:	00 d0       	rcall	.+0      	; 0x2f18 <vEventGroupSetBitsCallback+0xa>
    2f18:	cd b7       	in	r28, 0x3d	; 61
    2f1a:	de b7       	in	r29, 0x3e	; 62
    2f1c:	9a 83       	std	Y+2, r25	; 0x02
    2f1e:	89 83       	std	Y+1, r24	; 0x01
    2f20:	4b 83       	std	Y+3, r20	; 0x03
    2f22:	5c 83       	std	Y+4, r21	; 0x04
    2f24:	6d 83       	std	Y+5, r22	; 0x05
    2f26:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2f28:	89 81       	ldd	r24, Y+1	; 0x01
    2f2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f2c:	2b 81       	ldd	r18, Y+3	; 0x03
    2f2e:	3c 81       	ldd	r19, Y+4	; 0x04
    2f30:	b9 01       	movw	r22, r18
    2f32:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <xEventGroupSetBits>
}
    2f36:	26 96       	adiw	r28, 0x06	; 6
    2f38:	0f b6       	in	r0, 0x3f	; 63
    2f3a:	f8 94       	cli
    2f3c:	de bf       	out	0x3e, r29	; 62
    2f3e:	0f be       	out	0x3f, r0	; 63
    2f40:	cd bf       	out	0x3d, r28	; 61
    2f42:	cf 91       	pop	r28
    2f44:	df 91       	pop	r29
    2f46:	08 95       	ret

00002f48 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    2f48:	df 93       	push	r29
    2f4a:	cf 93       	push	r28
    2f4c:	00 d0       	rcall	.+0      	; 0x2f4e <vEventGroupClearBitsCallback+0x6>
    2f4e:	00 d0       	rcall	.+0      	; 0x2f50 <vEventGroupClearBitsCallback+0x8>
    2f50:	00 d0       	rcall	.+0      	; 0x2f52 <vEventGroupClearBitsCallback+0xa>
    2f52:	cd b7       	in	r28, 0x3d	; 61
    2f54:	de b7       	in	r29, 0x3e	; 62
    2f56:	9a 83       	std	Y+2, r25	; 0x02
    2f58:	89 83       	std	Y+1, r24	; 0x01
    2f5a:	4b 83       	std	Y+3, r20	; 0x03
    2f5c:	5c 83       	std	Y+4, r21	; 0x04
    2f5e:	6d 83       	std	Y+5, r22	; 0x05
    2f60:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2f62:	89 81       	ldd	r24, Y+1	; 0x01
    2f64:	9a 81       	ldd	r25, Y+2	; 0x02
    2f66:	2b 81       	ldd	r18, Y+3	; 0x03
    2f68:	3c 81       	ldd	r19, Y+4	; 0x04
    2f6a:	b9 01       	movw	r22, r18
    2f6c:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <xEventGroupClearBits>
}
    2f70:	26 96       	adiw	r28, 0x06	; 6
    2f72:	0f b6       	in	r0, 0x3f	; 63
    2f74:	f8 94       	cli
    2f76:	de bf       	out	0x3e, r29	; 62
    2f78:	0f be       	out	0x3f, r0	; 63
    2f7a:	cd bf       	out	0x3d, r28	; 61
    2f7c:	cf 91       	pop	r28
    2f7e:	df 91       	pop	r29
    2f80:	08 95       	ret

00002f82 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    2f82:	df 93       	push	r29
    2f84:	cf 93       	push	r28
    2f86:	00 d0       	rcall	.+0      	; 0x2f88 <prvTestWaitCondition+0x6>
    2f88:	00 d0       	rcall	.+0      	; 0x2f8a <prvTestWaitCondition+0x8>
    2f8a:	00 d0       	rcall	.+0      	; 0x2f8c <prvTestWaitCondition+0xa>
    2f8c:	cd b7       	in	r28, 0x3d	; 61
    2f8e:	de b7       	in	r29, 0x3e	; 62
    2f90:	9b 83       	std	Y+3, r25	; 0x03
    2f92:	8a 83       	std	Y+2, r24	; 0x02
    2f94:	7d 83       	std	Y+5, r23	; 0x05
    2f96:	6c 83       	std	Y+4, r22	; 0x04
    2f98:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    2f9a:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    2f9c:	8e 81       	ldd	r24, Y+6	; 0x06
    2f9e:	88 23       	and	r24, r24
    2fa0:	59 f4       	brne	.+22     	; 0x2fb8 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2fa2:	8a 81       	ldd	r24, Y+2	; 0x02
    2fa4:	9b 81       	ldd	r25, Y+3	; 0x03
    2fa6:	2c 81       	ldd	r18, Y+4	; 0x04
    2fa8:	3d 81       	ldd	r19, Y+5	; 0x05
    2faa:	82 23       	and	r24, r18
    2fac:	93 23       	and	r25, r19
    2fae:	00 97       	sbiw	r24, 0x00	; 0
    2fb0:	81 f0       	breq	.+32     	; 0x2fd2 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2fb2:	81 e0       	ldi	r24, 0x01	; 1
    2fb4:	89 83       	std	Y+1, r24	; 0x01
    2fb6:	0d c0       	rjmp	.+26     	; 0x2fd2 <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2fb8:	2a 81       	ldd	r18, Y+2	; 0x02
    2fba:	3b 81       	ldd	r19, Y+3	; 0x03
    2fbc:	8c 81       	ldd	r24, Y+4	; 0x04
    2fbe:	9d 81       	ldd	r25, Y+5	; 0x05
    2fc0:	28 23       	and	r18, r24
    2fc2:	39 23       	and	r19, r25
    2fc4:	8c 81       	ldd	r24, Y+4	; 0x04
    2fc6:	9d 81       	ldd	r25, Y+5	; 0x05
    2fc8:	28 17       	cp	r18, r24
    2fca:	39 07       	cpc	r19, r25
    2fcc:	11 f4       	brne	.+4      	; 0x2fd2 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2fce:	81 e0       	ldi	r24, 0x01	; 1
    2fd0:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    2fd2:	89 81       	ldd	r24, Y+1	; 0x01
}
    2fd4:	26 96       	adiw	r28, 0x06	; 6
    2fd6:	0f b6       	in	r0, 0x3f	; 63
    2fd8:	f8 94       	cli
    2fda:	de bf       	out	0x3e, r29	; 62
    2fdc:	0f be       	out	0x3f, r0	; 63
    2fde:	cd bf       	out	0x3d, r28	; 61
    2fe0:	cf 91       	pop	r28
    2fe2:	df 91       	pop	r29
    2fe4:	08 95       	ret

00002fe6 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2fe6:	df 93       	push	r29
    2fe8:	cf 93       	push	r28
    2fea:	00 d0       	rcall	.+0      	; 0x2fec <vListInitialise+0x6>
    2fec:	cd b7       	in	r28, 0x3d	; 61
    2fee:	de b7       	in	r29, 0x3e	; 62
    2ff0:	9a 83       	std	Y+2, r25	; 0x02
    2ff2:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2ff4:	89 81       	ldd	r24, Y+1	; 0x01
    2ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ff8:	03 96       	adiw	r24, 0x03	; 3
    2ffa:	e9 81       	ldd	r30, Y+1	; 0x01
    2ffc:	fa 81       	ldd	r31, Y+2	; 0x02
    2ffe:	92 83       	std	Z+2, r25	; 0x02
    3000:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    3002:	e9 81       	ldd	r30, Y+1	; 0x01
    3004:	fa 81       	ldd	r31, Y+2	; 0x02
    3006:	8f ef       	ldi	r24, 0xFF	; 255
    3008:	9f ef       	ldi	r25, 0xFF	; 255
    300a:	94 83       	std	Z+4, r25	; 0x04
    300c:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    300e:	89 81       	ldd	r24, Y+1	; 0x01
    3010:	9a 81       	ldd	r25, Y+2	; 0x02
    3012:	03 96       	adiw	r24, 0x03	; 3
    3014:	e9 81       	ldd	r30, Y+1	; 0x01
    3016:	fa 81       	ldd	r31, Y+2	; 0x02
    3018:	96 83       	std	Z+6, r25	; 0x06
    301a:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    301c:	89 81       	ldd	r24, Y+1	; 0x01
    301e:	9a 81       	ldd	r25, Y+2	; 0x02
    3020:	03 96       	adiw	r24, 0x03	; 3
    3022:	e9 81       	ldd	r30, Y+1	; 0x01
    3024:	fa 81       	ldd	r31, Y+2	; 0x02
    3026:	90 87       	std	Z+8, r25	; 0x08
    3028:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    302a:	e9 81       	ldd	r30, Y+1	; 0x01
    302c:	fa 81       	ldd	r31, Y+2	; 0x02
    302e:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    3030:	0f 90       	pop	r0
    3032:	0f 90       	pop	r0
    3034:	cf 91       	pop	r28
    3036:	df 91       	pop	r29
    3038:	08 95       	ret

0000303a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    303a:	df 93       	push	r29
    303c:	cf 93       	push	r28
    303e:	00 d0       	rcall	.+0      	; 0x3040 <vListInitialiseItem+0x6>
    3040:	cd b7       	in	r28, 0x3d	; 61
    3042:	de b7       	in	r29, 0x3e	; 62
    3044:	9a 83       	std	Y+2, r25	; 0x02
    3046:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    3048:	e9 81       	ldd	r30, Y+1	; 0x01
    304a:	fa 81       	ldd	r31, Y+2	; 0x02
    304c:	11 86       	std	Z+9, r1	; 0x09
    304e:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    3050:	0f 90       	pop	r0
    3052:	0f 90       	pop	r0
    3054:	cf 91       	pop	r28
    3056:	df 91       	pop	r29
    3058:	08 95       	ret

0000305a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    305a:	df 93       	push	r29
    305c:	cf 93       	push	r28
    305e:	00 d0       	rcall	.+0      	; 0x3060 <vListInsertEnd+0x6>
    3060:	00 d0       	rcall	.+0      	; 0x3062 <vListInsertEnd+0x8>
    3062:	00 d0       	rcall	.+0      	; 0x3064 <vListInsertEnd+0xa>
    3064:	cd b7       	in	r28, 0x3d	; 61
    3066:	de b7       	in	r29, 0x3e	; 62
    3068:	9c 83       	std	Y+4, r25	; 0x04
    306a:	8b 83       	std	Y+3, r24	; 0x03
    306c:	7e 83       	std	Y+6, r23	; 0x06
    306e:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    3070:	eb 81       	ldd	r30, Y+3	; 0x03
    3072:	fc 81       	ldd	r31, Y+4	; 0x04
    3074:	81 81       	ldd	r24, Z+1	; 0x01
    3076:	92 81       	ldd	r25, Z+2	; 0x02
    3078:	9a 83       	std	Y+2, r25	; 0x02
    307a:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    307c:	ed 81       	ldd	r30, Y+5	; 0x05
    307e:	fe 81       	ldd	r31, Y+6	; 0x06
    3080:	89 81       	ldd	r24, Y+1	; 0x01
    3082:	9a 81       	ldd	r25, Y+2	; 0x02
    3084:	93 83       	std	Z+3, r25	; 0x03
    3086:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3088:	e9 81       	ldd	r30, Y+1	; 0x01
    308a:	fa 81       	ldd	r31, Y+2	; 0x02
    308c:	84 81       	ldd	r24, Z+4	; 0x04
    308e:	95 81       	ldd	r25, Z+5	; 0x05
    3090:	ed 81       	ldd	r30, Y+5	; 0x05
    3092:	fe 81       	ldd	r31, Y+6	; 0x06
    3094:	95 83       	std	Z+5, r25	; 0x05
    3096:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    3098:	e9 81       	ldd	r30, Y+1	; 0x01
    309a:	fa 81       	ldd	r31, Y+2	; 0x02
    309c:	04 80       	ldd	r0, Z+4	; 0x04
    309e:	f5 81       	ldd	r31, Z+5	; 0x05
    30a0:	e0 2d       	mov	r30, r0
    30a2:	8d 81       	ldd	r24, Y+5	; 0x05
    30a4:	9e 81       	ldd	r25, Y+6	; 0x06
    30a6:	93 83       	std	Z+3, r25	; 0x03
    30a8:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    30aa:	e9 81       	ldd	r30, Y+1	; 0x01
    30ac:	fa 81       	ldd	r31, Y+2	; 0x02
    30ae:	8d 81       	ldd	r24, Y+5	; 0x05
    30b0:	9e 81       	ldd	r25, Y+6	; 0x06
    30b2:	95 83       	std	Z+5, r25	; 0x05
    30b4:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    30b6:	ed 81       	ldd	r30, Y+5	; 0x05
    30b8:	fe 81       	ldd	r31, Y+6	; 0x06
    30ba:	8b 81       	ldd	r24, Y+3	; 0x03
    30bc:	9c 81       	ldd	r25, Y+4	; 0x04
    30be:	91 87       	std	Z+9, r25	; 0x09
    30c0:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    30c2:	eb 81       	ldd	r30, Y+3	; 0x03
    30c4:	fc 81       	ldd	r31, Y+4	; 0x04
    30c6:	80 81       	ld	r24, Z
    30c8:	8f 5f       	subi	r24, 0xFF	; 255
    30ca:	eb 81       	ldd	r30, Y+3	; 0x03
    30cc:	fc 81       	ldd	r31, Y+4	; 0x04
    30ce:	80 83       	st	Z, r24
}
    30d0:	26 96       	adiw	r28, 0x06	; 6
    30d2:	0f b6       	in	r0, 0x3f	; 63
    30d4:	f8 94       	cli
    30d6:	de bf       	out	0x3e, r29	; 62
    30d8:	0f be       	out	0x3f, r0	; 63
    30da:	cd bf       	out	0x3d, r28	; 61
    30dc:	cf 91       	pop	r28
    30de:	df 91       	pop	r29
    30e0:	08 95       	ret

000030e2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    30e2:	df 93       	push	r29
    30e4:	cf 93       	push	r28
    30e6:	cd b7       	in	r28, 0x3d	; 61
    30e8:	de b7       	in	r29, 0x3e	; 62
    30ea:	28 97       	sbiw	r28, 0x08	; 8
    30ec:	0f b6       	in	r0, 0x3f	; 63
    30ee:	f8 94       	cli
    30f0:	de bf       	out	0x3e, r29	; 62
    30f2:	0f be       	out	0x3f, r0	; 63
    30f4:	cd bf       	out	0x3d, r28	; 61
    30f6:	9e 83       	std	Y+6, r25	; 0x06
    30f8:	8d 83       	std	Y+5, r24	; 0x05
    30fa:	78 87       	std	Y+8, r23	; 0x08
    30fc:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    30fe:	ef 81       	ldd	r30, Y+7	; 0x07
    3100:	f8 85       	ldd	r31, Y+8	; 0x08
    3102:	80 81       	ld	r24, Z
    3104:	91 81       	ldd	r25, Z+1	; 0x01
    3106:	9a 83       	std	Y+2, r25	; 0x02
    3108:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    310a:	89 81       	ldd	r24, Y+1	; 0x01
    310c:	9a 81       	ldd	r25, Y+2	; 0x02
    310e:	2f ef       	ldi	r18, 0xFF	; 255
    3110:	8f 3f       	cpi	r24, 0xFF	; 255
    3112:	92 07       	cpc	r25, r18
    3114:	39 f4       	brne	.+14     	; 0x3124 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    3116:	ed 81       	ldd	r30, Y+5	; 0x05
    3118:	fe 81       	ldd	r31, Y+6	; 0x06
    311a:	87 81       	ldd	r24, Z+7	; 0x07
    311c:	90 85       	ldd	r25, Z+8	; 0x08
    311e:	9c 83       	std	Y+4, r25	; 0x04
    3120:	8b 83       	std	Y+3, r24	; 0x03
    3122:	18 c0       	rjmp	.+48     	; 0x3154 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3124:	8d 81       	ldd	r24, Y+5	; 0x05
    3126:	9e 81       	ldd	r25, Y+6	; 0x06
    3128:	03 96       	adiw	r24, 0x03	; 3
    312a:	9c 83       	std	Y+4, r25	; 0x04
    312c:	8b 83       	std	Y+3, r24	; 0x03
    312e:	06 c0       	rjmp	.+12     	; 0x313c <vListInsert+0x5a>
    3130:	eb 81       	ldd	r30, Y+3	; 0x03
    3132:	fc 81       	ldd	r31, Y+4	; 0x04
    3134:	82 81       	ldd	r24, Z+2	; 0x02
    3136:	93 81       	ldd	r25, Z+3	; 0x03
    3138:	9c 83       	std	Y+4, r25	; 0x04
    313a:	8b 83       	std	Y+3, r24	; 0x03
    313c:	eb 81       	ldd	r30, Y+3	; 0x03
    313e:	fc 81       	ldd	r31, Y+4	; 0x04
    3140:	02 80       	ldd	r0, Z+2	; 0x02
    3142:	f3 81       	ldd	r31, Z+3	; 0x03
    3144:	e0 2d       	mov	r30, r0
    3146:	20 81       	ld	r18, Z
    3148:	31 81       	ldd	r19, Z+1	; 0x01
    314a:	89 81       	ldd	r24, Y+1	; 0x01
    314c:	9a 81       	ldd	r25, Y+2	; 0x02
    314e:	82 17       	cp	r24, r18
    3150:	93 07       	cpc	r25, r19
    3152:	70 f7       	brcc	.-36     	; 0x3130 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    3154:	eb 81       	ldd	r30, Y+3	; 0x03
    3156:	fc 81       	ldd	r31, Y+4	; 0x04
    3158:	82 81       	ldd	r24, Z+2	; 0x02
    315a:	93 81       	ldd	r25, Z+3	; 0x03
    315c:	ef 81       	ldd	r30, Y+7	; 0x07
    315e:	f8 85       	ldd	r31, Y+8	; 0x08
    3160:	93 83       	std	Z+3, r25	; 0x03
    3162:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3164:	ef 81       	ldd	r30, Y+7	; 0x07
    3166:	f8 85       	ldd	r31, Y+8	; 0x08
    3168:	02 80       	ldd	r0, Z+2	; 0x02
    316a:	f3 81       	ldd	r31, Z+3	; 0x03
    316c:	e0 2d       	mov	r30, r0
    316e:	8f 81       	ldd	r24, Y+7	; 0x07
    3170:	98 85       	ldd	r25, Y+8	; 0x08
    3172:	95 83       	std	Z+5, r25	; 0x05
    3174:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    3176:	ef 81       	ldd	r30, Y+7	; 0x07
    3178:	f8 85       	ldd	r31, Y+8	; 0x08
    317a:	8b 81       	ldd	r24, Y+3	; 0x03
    317c:	9c 81       	ldd	r25, Y+4	; 0x04
    317e:	95 83       	std	Z+5, r25	; 0x05
    3180:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    3182:	eb 81       	ldd	r30, Y+3	; 0x03
    3184:	fc 81       	ldd	r31, Y+4	; 0x04
    3186:	8f 81       	ldd	r24, Y+7	; 0x07
    3188:	98 85       	ldd	r25, Y+8	; 0x08
    318a:	93 83       	std	Z+3, r25	; 0x03
    318c:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    318e:	ef 81       	ldd	r30, Y+7	; 0x07
    3190:	f8 85       	ldd	r31, Y+8	; 0x08
    3192:	8d 81       	ldd	r24, Y+5	; 0x05
    3194:	9e 81       	ldd	r25, Y+6	; 0x06
    3196:	91 87       	std	Z+9, r25	; 0x09
    3198:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    319a:	ed 81       	ldd	r30, Y+5	; 0x05
    319c:	fe 81       	ldd	r31, Y+6	; 0x06
    319e:	80 81       	ld	r24, Z
    31a0:	8f 5f       	subi	r24, 0xFF	; 255
    31a2:	ed 81       	ldd	r30, Y+5	; 0x05
    31a4:	fe 81       	ldd	r31, Y+6	; 0x06
    31a6:	80 83       	st	Z, r24
}
    31a8:	28 96       	adiw	r28, 0x08	; 8
    31aa:	0f b6       	in	r0, 0x3f	; 63
    31ac:	f8 94       	cli
    31ae:	de bf       	out	0x3e, r29	; 62
    31b0:	0f be       	out	0x3f, r0	; 63
    31b2:	cd bf       	out	0x3d, r28	; 61
    31b4:	cf 91       	pop	r28
    31b6:	df 91       	pop	r29
    31b8:	08 95       	ret

000031ba <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    31ba:	df 93       	push	r29
    31bc:	cf 93       	push	r28
    31be:	00 d0       	rcall	.+0      	; 0x31c0 <uxListRemove+0x6>
    31c0:	00 d0       	rcall	.+0      	; 0x31c2 <uxListRemove+0x8>
    31c2:	cd b7       	in	r28, 0x3d	; 61
    31c4:	de b7       	in	r29, 0x3e	; 62
    31c6:	9c 83       	std	Y+4, r25	; 0x04
    31c8:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    31ca:	eb 81       	ldd	r30, Y+3	; 0x03
    31cc:	fc 81       	ldd	r31, Y+4	; 0x04
    31ce:	80 85       	ldd	r24, Z+8	; 0x08
    31d0:	91 85       	ldd	r25, Z+9	; 0x09
    31d2:	9a 83       	std	Y+2, r25	; 0x02
    31d4:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    31d6:	eb 81       	ldd	r30, Y+3	; 0x03
    31d8:	fc 81       	ldd	r31, Y+4	; 0x04
    31da:	a2 81       	ldd	r26, Z+2	; 0x02
    31dc:	b3 81       	ldd	r27, Z+3	; 0x03
    31de:	eb 81       	ldd	r30, Y+3	; 0x03
    31e0:	fc 81       	ldd	r31, Y+4	; 0x04
    31e2:	84 81       	ldd	r24, Z+4	; 0x04
    31e4:	95 81       	ldd	r25, Z+5	; 0x05
    31e6:	15 96       	adiw	r26, 0x05	; 5
    31e8:	9c 93       	st	X, r25
    31ea:	8e 93       	st	-X, r24
    31ec:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    31ee:	eb 81       	ldd	r30, Y+3	; 0x03
    31f0:	fc 81       	ldd	r31, Y+4	; 0x04
    31f2:	a4 81       	ldd	r26, Z+4	; 0x04
    31f4:	b5 81       	ldd	r27, Z+5	; 0x05
    31f6:	eb 81       	ldd	r30, Y+3	; 0x03
    31f8:	fc 81       	ldd	r31, Y+4	; 0x04
    31fa:	82 81       	ldd	r24, Z+2	; 0x02
    31fc:	93 81       	ldd	r25, Z+3	; 0x03
    31fe:	13 96       	adiw	r26, 0x03	; 3
    3200:	9c 93       	st	X, r25
    3202:	8e 93       	st	-X, r24
    3204:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    3206:	e9 81       	ldd	r30, Y+1	; 0x01
    3208:	fa 81       	ldd	r31, Y+2	; 0x02
    320a:	21 81       	ldd	r18, Z+1	; 0x01
    320c:	32 81       	ldd	r19, Z+2	; 0x02
    320e:	8b 81       	ldd	r24, Y+3	; 0x03
    3210:	9c 81       	ldd	r25, Y+4	; 0x04
    3212:	28 17       	cp	r18, r24
    3214:	39 07       	cpc	r19, r25
    3216:	41 f4       	brne	.+16     	; 0x3228 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    3218:	eb 81       	ldd	r30, Y+3	; 0x03
    321a:	fc 81       	ldd	r31, Y+4	; 0x04
    321c:	84 81       	ldd	r24, Z+4	; 0x04
    321e:	95 81       	ldd	r25, Z+5	; 0x05
    3220:	e9 81       	ldd	r30, Y+1	; 0x01
    3222:	fa 81       	ldd	r31, Y+2	; 0x02
    3224:	92 83       	std	Z+2, r25	; 0x02
    3226:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    3228:	eb 81       	ldd	r30, Y+3	; 0x03
    322a:	fc 81       	ldd	r31, Y+4	; 0x04
    322c:	11 86       	std	Z+9, r1	; 0x09
    322e:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    3230:	e9 81       	ldd	r30, Y+1	; 0x01
    3232:	fa 81       	ldd	r31, Y+2	; 0x02
    3234:	80 81       	ld	r24, Z
    3236:	81 50       	subi	r24, 0x01	; 1
    3238:	e9 81       	ldd	r30, Y+1	; 0x01
    323a:	fa 81       	ldd	r31, Y+2	; 0x02
    323c:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    323e:	e9 81       	ldd	r30, Y+1	; 0x01
    3240:	fa 81       	ldd	r31, Y+2	; 0x02
    3242:	80 81       	ld	r24, Z
}
    3244:	0f 90       	pop	r0
    3246:	0f 90       	pop	r0
    3248:	0f 90       	pop	r0
    324a:	0f 90       	pop	r0
    324c:	cf 91       	pop	r28
    324e:	df 91       	pop	r29
    3250:	08 95       	ret

00003252 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    3252:	df 93       	push	r29
    3254:	cf 93       	push	r28
    3256:	00 d0       	rcall	.+0      	; 0x3258 <xQueueGenericReset+0x6>
    3258:	00 d0       	rcall	.+0      	; 0x325a <xQueueGenericReset+0x8>
    325a:	00 d0       	rcall	.+0      	; 0x325c <xQueueGenericReset+0xa>
    325c:	cd b7       	in	r28, 0x3d	; 61
    325e:	de b7       	in	r29, 0x3e	; 62
    3260:	9d 83       	std	Y+5, r25	; 0x05
    3262:	8c 83       	std	Y+4, r24	; 0x04
    3264:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    3266:	81 e0       	ldi	r24, 0x01	; 1
    3268:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    326a:	8c 81       	ldd	r24, Y+4	; 0x04
    326c:	9d 81       	ldd	r25, Y+5	; 0x05
    326e:	9a 83       	std	Y+2, r25	; 0x02
    3270:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    3272:	89 81       	ldd	r24, Y+1	; 0x01
    3274:	9a 81       	ldd	r25, Y+2	; 0x02
    3276:	00 97       	sbiw	r24, 0x00	; 0
    3278:	09 f4       	brne	.+2      	; 0x327c <xQueueGenericReset+0x2a>
    327a:	8b c0       	rjmp	.+278    	; 0x3392 <xQueueGenericReset+0x140>
    327c:	e9 81       	ldd	r30, Y+1	; 0x01
    327e:	fa 81       	ldd	r31, Y+2	; 0x02
    3280:	83 8d       	ldd	r24, Z+27	; 0x1b
    3282:	88 23       	and	r24, r24
    3284:	09 f4       	brne	.+2      	; 0x3288 <xQueueGenericReset+0x36>
    3286:	85 c0       	rjmp	.+266    	; 0x3392 <xQueueGenericReset+0x140>
    3288:	e9 81       	ldd	r30, Y+1	; 0x01
    328a:	fa 81       	ldd	r31, Y+2	; 0x02
    328c:	83 8d       	ldd	r24, Z+27	; 0x1b
    328e:	28 2f       	mov	r18, r24
    3290:	30 e0       	ldi	r19, 0x00	; 0
    3292:	8f ef       	ldi	r24, 0xFF	; 255
    3294:	9f e7       	ldi	r25, 0x7F	; 127
    3296:	b9 01       	movw	r22, r18
    3298:	0e 94 cb 3b 	call	0x7796	; 0x7796 <__udivmodhi4>
    329c:	cb 01       	movw	r24, r22
    329e:	9c 01       	movw	r18, r24
    32a0:	e9 81       	ldd	r30, Y+1	; 0x01
    32a2:	fa 81       	ldd	r31, Y+2	; 0x02
    32a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    32a6:	88 2f       	mov	r24, r24
    32a8:	90 e0       	ldi	r25, 0x00	; 0
    32aa:	28 17       	cp	r18, r24
    32ac:	39 07       	cpc	r19, r25
    32ae:	08 f4       	brcc	.+2      	; 0x32b2 <xQueueGenericReset+0x60>
    32b0:	70 c0       	rjmp	.+224    	; 0x3392 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    32b2:	0f b6       	in	r0, 0x3f	; 63
    32b4:	f8 94       	cli
    32b6:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    32b8:	e9 81       	ldd	r30, Y+1	; 0x01
    32ba:	fa 81       	ldd	r31, Y+2	; 0x02
    32bc:	40 81       	ld	r20, Z
    32be:	51 81       	ldd	r21, Z+1	; 0x01
    32c0:	e9 81       	ldd	r30, Y+1	; 0x01
    32c2:	fa 81       	ldd	r31, Y+2	; 0x02
    32c4:	83 8d       	ldd	r24, Z+27	; 0x1b
    32c6:	28 2f       	mov	r18, r24
    32c8:	30 e0       	ldi	r19, 0x00	; 0
    32ca:	e9 81       	ldd	r30, Y+1	; 0x01
    32cc:	fa 81       	ldd	r31, Y+2	; 0x02
    32ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    32d0:	88 2f       	mov	r24, r24
    32d2:	90 e0       	ldi	r25, 0x00	; 0
    32d4:	bc 01       	movw	r22, r24
    32d6:	26 9f       	mul	r18, r22
    32d8:	c0 01       	movw	r24, r0
    32da:	27 9f       	mul	r18, r23
    32dc:	90 0d       	add	r25, r0
    32de:	36 9f       	mul	r19, r22
    32e0:	90 0d       	add	r25, r0
    32e2:	11 24       	eor	r1, r1
    32e4:	84 0f       	add	r24, r20
    32e6:	95 1f       	adc	r25, r21
    32e8:	e9 81       	ldd	r30, Y+1	; 0x01
    32ea:	fa 81       	ldd	r31, Y+2	; 0x02
    32ec:	95 83       	std	Z+5, r25	; 0x05
    32ee:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    32f0:	e9 81       	ldd	r30, Y+1	; 0x01
    32f2:	fa 81       	ldd	r31, Y+2	; 0x02
    32f4:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    32f6:	e9 81       	ldd	r30, Y+1	; 0x01
    32f8:	fa 81       	ldd	r31, Y+2	; 0x02
    32fa:	80 81       	ld	r24, Z
    32fc:	91 81       	ldd	r25, Z+1	; 0x01
    32fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3300:	fa 81       	ldd	r31, Y+2	; 0x02
    3302:	93 83       	std	Z+3, r25	; 0x03
    3304:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3306:	e9 81       	ldd	r30, Y+1	; 0x01
    3308:	fa 81       	ldd	r31, Y+2	; 0x02
    330a:	40 81       	ld	r20, Z
    330c:	51 81       	ldd	r21, Z+1	; 0x01
    330e:	e9 81       	ldd	r30, Y+1	; 0x01
    3310:	fa 81       	ldd	r31, Y+2	; 0x02
    3312:	83 8d       	ldd	r24, Z+27	; 0x1b
    3314:	88 2f       	mov	r24, r24
    3316:	90 e0       	ldi	r25, 0x00	; 0
    3318:	9c 01       	movw	r18, r24
    331a:	21 50       	subi	r18, 0x01	; 1
    331c:	30 40       	sbci	r19, 0x00	; 0
    331e:	e9 81       	ldd	r30, Y+1	; 0x01
    3320:	fa 81       	ldd	r31, Y+2	; 0x02
    3322:	84 8d       	ldd	r24, Z+28	; 0x1c
    3324:	88 2f       	mov	r24, r24
    3326:	90 e0       	ldi	r25, 0x00	; 0
    3328:	bc 01       	movw	r22, r24
    332a:	26 9f       	mul	r18, r22
    332c:	c0 01       	movw	r24, r0
    332e:	27 9f       	mul	r18, r23
    3330:	90 0d       	add	r25, r0
    3332:	36 9f       	mul	r19, r22
    3334:	90 0d       	add	r25, r0
    3336:	11 24       	eor	r1, r1
    3338:	84 0f       	add	r24, r20
    333a:	95 1f       	adc	r25, r21
    333c:	e9 81       	ldd	r30, Y+1	; 0x01
    333e:	fa 81       	ldd	r31, Y+2	; 0x02
    3340:	97 83       	std	Z+7, r25	; 0x07
    3342:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    3344:	e9 81       	ldd	r30, Y+1	; 0x01
    3346:	fa 81       	ldd	r31, Y+2	; 0x02
    3348:	8f ef       	ldi	r24, 0xFF	; 255
    334a:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    334c:	e9 81       	ldd	r30, Y+1	; 0x01
    334e:	fa 81       	ldd	r31, Y+2	; 0x02
    3350:	8f ef       	ldi	r24, 0xFF	; 255
    3352:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    3354:	8e 81       	ldd	r24, Y+6	; 0x06
    3356:	88 23       	and	r24, r24
    3358:	79 f4       	brne	.+30     	; 0x3378 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    335a:	e9 81       	ldd	r30, Y+1	; 0x01
    335c:	fa 81       	ldd	r31, Y+2	; 0x02
    335e:	80 85       	ldd	r24, Z+8	; 0x08
    3360:	88 23       	and	r24, r24
    3362:	a1 f0       	breq	.+40     	; 0x338c <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3364:	89 81       	ldd	r24, Y+1	; 0x01
    3366:	9a 81       	ldd	r25, Y+2	; 0x02
    3368:	08 96       	adiw	r24, 0x08	; 8
    336a:	0e 94 96 2a 	call	0x552c	; 0x552c <xTaskRemoveFromEventList>
    336e:	88 23       	and	r24, r24
    3370:	69 f0       	breq	.+26     	; 0x338c <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    3372:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
    3376:	0a c0       	rjmp	.+20     	; 0x338c <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3378:	89 81       	ldd	r24, Y+1	; 0x01
    337a:	9a 81       	ldd	r25, Y+2	; 0x02
    337c:	08 96       	adiw	r24, 0x08	; 8
    337e:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3382:	89 81       	ldd	r24, Y+1	; 0x01
    3384:	9a 81       	ldd	r25, Y+2	; 0x02
    3386:	41 96       	adiw	r24, 0x11	; 17
    3388:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    338c:	0f 90       	pop	r0
    338e:	0f be       	out	0x3f, r0	; 63
    3390:	01 c0       	rjmp	.+2      	; 0x3394 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    3392:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    3394:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3396:	26 96       	adiw	r28, 0x06	; 6
    3398:	0f b6       	in	r0, 0x3f	; 63
    339a:	f8 94       	cli
    339c:	de bf       	out	0x3e, r29	; 62
    339e:	0f be       	out	0x3f, r0	; 63
    33a0:	cd bf       	out	0x3d, r28	; 61
    33a2:	cf 91       	pop	r28
    33a4:	df 91       	pop	r29
    33a6:	08 95       	ret

000033a8 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    33a8:	0f 93       	push	r16
    33aa:	1f 93       	push	r17
    33ac:	df 93       	push	r29
    33ae:	cf 93       	push	r28
    33b0:	cd b7       	in	r28, 0x3d	; 61
    33b2:	de b7       	in	r29, 0x3e	; 62
    33b4:	29 97       	sbiw	r28, 0x09	; 9
    33b6:	0f b6       	in	r0, 0x3f	; 63
    33b8:	f8 94       	cli
    33ba:	de bf       	out	0x3e, r29	; 62
    33bc:	0f be       	out	0x3f, r0	; 63
    33be:	cd bf       	out	0x3d, r28	; 61
    33c0:	8f 83       	std	Y+7, r24	; 0x07
    33c2:	68 87       	std	Y+8, r22	; 0x08
    33c4:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    33c6:	1e 82       	std	Y+6, r1	; 0x06
    33c8:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    33ca:	8f 81       	ldd	r24, Y+7	; 0x07
    33cc:	88 23       	and	r24, r24
    33ce:	09 f4       	brne	.+2      	; 0x33d2 <xQueueGenericCreate+0x2a>
    33d0:	52 c0       	rjmp	.+164    	; 0x3476 <xQueueGenericCreate+0xce>
    33d2:	8f 81       	ldd	r24, Y+7	; 0x07
    33d4:	28 2f       	mov	r18, r24
    33d6:	30 e0       	ldi	r19, 0x00	; 0
    33d8:	8f ef       	ldi	r24, 0xFF	; 255
    33da:	9f e7       	ldi	r25, 0x7F	; 127
    33dc:	b9 01       	movw	r22, r18
    33de:	0e 94 cb 3b 	call	0x7796	; 0x7796 <__udivmodhi4>
    33e2:	cb 01       	movw	r24, r22
    33e4:	9c 01       	movw	r18, r24
    33e6:	88 85       	ldd	r24, Y+8	; 0x08
    33e8:	88 2f       	mov	r24, r24
    33ea:	90 e0       	ldi	r25, 0x00	; 0
    33ec:	28 17       	cp	r18, r24
    33ee:	39 07       	cpc	r19, r25
    33f0:	08 f4       	brcc	.+2      	; 0x33f4 <xQueueGenericCreate+0x4c>
    33f2:	41 c0       	rjmp	.+130    	; 0x3476 <xQueueGenericCreate+0xce>
    33f4:	8f 81       	ldd	r24, Y+7	; 0x07
    33f6:	28 2f       	mov	r18, r24
    33f8:	30 e0       	ldi	r19, 0x00	; 0
    33fa:	88 85       	ldd	r24, Y+8	; 0x08
    33fc:	88 2f       	mov	r24, r24
    33fe:	90 e0       	ldi	r25, 0x00	; 0
    3400:	ac 01       	movw	r20, r24
    3402:	24 9f       	mul	r18, r20
    3404:	c0 01       	movw	r24, r0
    3406:	25 9f       	mul	r18, r21
    3408:	90 0d       	add	r25, r0
    340a:	34 9f       	mul	r19, r20
    340c:	90 0d       	add	r25, r0
    340e:	11 24       	eor	r1, r1
    3410:	5f e7       	ldi	r21, 0x7F	; 127
    3412:	81 3e       	cpi	r24, 0xE1	; 225
    3414:	95 07       	cpc	r25, r21
    3416:	78 f5       	brcc	.+94     	; 0x3476 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3418:	8f 81       	ldd	r24, Y+7	; 0x07
    341a:	28 2f       	mov	r18, r24
    341c:	30 e0       	ldi	r19, 0x00	; 0
    341e:	88 85       	ldd	r24, Y+8	; 0x08
    3420:	88 2f       	mov	r24, r24
    3422:	90 e0       	ldi	r25, 0x00	; 0
    3424:	ac 01       	movw	r20, r24
    3426:	24 9f       	mul	r18, r20
    3428:	c0 01       	movw	r24, r0
    342a:	25 9f       	mul	r18, r21
    342c:	90 0d       	add	r25, r0
    342e:	34 9f       	mul	r19, r20
    3430:	90 0d       	add	r25, r0
    3432:	11 24       	eor	r1, r1
    3434:	9c 83       	std	Y+4, r25	; 0x04
    3436:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    3438:	8b 81       	ldd	r24, Y+3	; 0x03
    343a:	9c 81       	ldd	r25, Y+4	; 0x04
    343c:	4f 96       	adiw	r24, 0x1f	; 31
    343e:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <pvPortMalloc>
    3442:	9e 83       	std	Y+6, r25	; 0x06
    3444:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    3446:	8d 81       	ldd	r24, Y+5	; 0x05
    3448:	9e 81       	ldd	r25, Y+6	; 0x06
    344a:	00 97       	sbiw	r24, 0x00	; 0
    344c:	a1 f0       	breq	.+40     	; 0x3476 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    344e:	8d 81       	ldd	r24, Y+5	; 0x05
    3450:	9e 81       	ldd	r25, Y+6	; 0x06
    3452:	9a 83       	std	Y+2, r25	; 0x02
    3454:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3456:	89 81       	ldd	r24, Y+1	; 0x01
    3458:	9a 81       	ldd	r25, Y+2	; 0x02
    345a:	4f 96       	adiw	r24, 0x1f	; 31
    345c:	9a 83       	std	Y+2, r25	; 0x02
    345e:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    3460:	29 81       	ldd	r18, Y+1	; 0x01
    3462:	3a 81       	ldd	r19, Y+2	; 0x02
    3464:	ed 81       	ldd	r30, Y+5	; 0x05
    3466:	fe 81       	ldd	r31, Y+6	; 0x06
    3468:	8f 81       	ldd	r24, Y+7	; 0x07
    346a:	68 85       	ldd	r22, Y+8	; 0x08
    346c:	a9 01       	movw	r20, r18
    346e:	29 85       	ldd	r18, Y+9	; 0x09
    3470:	8f 01       	movw	r16, r30
    3472:	0e 94 48 1a 	call	0x3490	; 0x3490 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    3476:	8d 81       	ldd	r24, Y+5	; 0x05
    3478:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    347a:	29 96       	adiw	r28, 0x09	; 9
    347c:	0f b6       	in	r0, 0x3f	; 63
    347e:	f8 94       	cli
    3480:	de bf       	out	0x3e, r29	; 62
    3482:	0f be       	out	0x3f, r0	; 63
    3484:	cd bf       	out	0x3d, r28	; 61
    3486:	cf 91       	pop	r28
    3488:	df 91       	pop	r29
    348a:	1f 91       	pop	r17
    348c:	0f 91       	pop	r16
    348e:	08 95       	ret

00003490 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    3490:	0f 93       	push	r16
    3492:	1f 93       	push	r17
    3494:	df 93       	push	r29
    3496:	cf 93       	push	r28
    3498:	cd b7       	in	r28, 0x3d	; 61
    349a:	de b7       	in	r29, 0x3e	; 62
    349c:	27 97       	sbiw	r28, 0x07	; 7
    349e:	0f b6       	in	r0, 0x3f	; 63
    34a0:	f8 94       	cli
    34a2:	de bf       	out	0x3e, r29	; 62
    34a4:	0f be       	out	0x3f, r0	; 63
    34a6:	cd bf       	out	0x3d, r28	; 61
    34a8:	89 83       	std	Y+1, r24	; 0x01
    34aa:	6a 83       	std	Y+2, r22	; 0x02
    34ac:	5c 83       	std	Y+4, r21	; 0x04
    34ae:	4b 83       	std	Y+3, r20	; 0x03
    34b0:	2d 83       	std	Y+5, r18	; 0x05
    34b2:	1f 83       	std	Y+7, r17	; 0x07
    34b4:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    34b6:	8a 81       	ldd	r24, Y+2	; 0x02
    34b8:	88 23       	and	r24, r24
    34ba:	39 f4       	brne	.+14     	; 0x34ca <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    34bc:	8e 81       	ldd	r24, Y+6	; 0x06
    34be:	9f 81       	ldd	r25, Y+7	; 0x07
    34c0:	ee 81       	ldd	r30, Y+6	; 0x06
    34c2:	ff 81       	ldd	r31, Y+7	; 0x07
    34c4:	91 83       	std	Z+1, r25	; 0x01
    34c6:	80 83       	st	Z, r24
    34c8:	06 c0       	rjmp	.+12     	; 0x34d6 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    34ca:	8b 81       	ldd	r24, Y+3	; 0x03
    34cc:	9c 81       	ldd	r25, Y+4	; 0x04
    34ce:	ee 81       	ldd	r30, Y+6	; 0x06
    34d0:	ff 81       	ldd	r31, Y+7	; 0x07
    34d2:	91 83       	std	Z+1, r25	; 0x01
    34d4:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    34d6:	ee 81       	ldd	r30, Y+6	; 0x06
    34d8:	ff 81       	ldd	r31, Y+7	; 0x07
    34da:	89 81       	ldd	r24, Y+1	; 0x01
    34dc:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    34de:	ee 81       	ldd	r30, Y+6	; 0x06
    34e0:	ff 81       	ldd	r31, Y+7	; 0x07
    34e2:	8a 81       	ldd	r24, Y+2	; 0x02
    34e4:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    34e6:	8e 81       	ldd	r24, Y+6	; 0x06
    34e8:	9f 81       	ldd	r25, Y+7	; 0x07
    34ea:	61 e0       	ldi	r22, 0x01	; 1
    34ec:	0e 94 29 19 	call	0x3252	; 0x3252 <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    34f0:	27 96       	adiw	r28, 0x07	; 7
    34f2:	0f b6       	in	r0, 0x3f	; 63
    34f4:	f8 94       	cli
    34f6:	de bf       	out	0x3e, r29	; 62
    34f8:	0f be       	out	0x3f, r0	; 63
    34fa:	cd bf       	out	0x3d, r28	; 61
    34fc:	cf 91       	pop	r28
    34fe:	df 91       	pop	r29
    3500:	1f 91       	pop	r17
    3502:	0f 91       	pop	r16
    3504:	08 95       	ret

00003506 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    3506:	df 93       	push	r29
    3508:	cf 93       	push	r28
    350a:	cd b7       	in	r28, 0x3d	; 61
    350c:	de b7       	in	r29, 0x3e	; 62
    350e:	2f 97       	sbiw	r28, 0x0f	; 15
    3510:	0f b6       	in	r0, 0x3f	; 63
    3512:	f8 94       	cli
    3514:	de bf       	out	0x3e, r29	; 62
    3516:	0f be       	out	0x3f, r0	; 63
    3518:	cd bf       	out	0x3d, r28	; 61
    351a:	99 87       	std	Y+9, r25	; 0x09
    351c:	88 87       	std	Y+8, r24	; 0x08
    351e:	7b 87       	std	Y+11, r23	; 0x0b
    3520:	6a 87       	std	Y+10, r22	; 0x0a
    3522:	5d 87       	std	Y+13, r21	; 0x0d
    3524:	4c 87       	std	Y+12, r20	; 0x0c
    3526:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    3528:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    352a:	88 85       	ldd	r24, Y+8	; 0x08
    352c:	99 85       	ldd	r25, Y+9	; 0x09
    352e:	9a 83       	std	Y+2, r25	; 0x02
    3530:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3532:	0f b6       	in	r0, 0x3f	; 63
    3534:	f8 94       	cli
    3536:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3538:	e9 81       	ldd	r30, Y+1	; 0x01
    353a:	fa 81       	ldd	r31, Y+2	; 0x02
    353c:	92 8d       	ldd	r25, Z+26	; 0x1a
    353e:	e9 81       	ldd	r30, Y+1	; 0x01
    3540:	fa 81       	ldd	r31, Y+2	; 0x02
    3542:	83 8d       	ldd	r24, Z+27	; 0x1b
    3544:	98 17       	cp	r25, r24
    3546:	18 f0       	brcs	.+6      	; 0x354e <xQueueGenericSend+0x48>
    3548:	8e 85       	ldd	r24, Y+14	; 0x0e
    354a:	82 30       	cpi	r24, 0x02	; 2
    354c:	11 f5       	brne	.+68     	; 0x3592 <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    354e:	89 81       	ldd	r24, Y+1	; 0x01
    3550:	9a 81       	ldd	r25, Y+2	; 0x02
    3552:	2a 85       	ldd	r18, Y+10	; 0x0a
    3554:	3b 85       	ldd	r19, Y+11	; 0x0b
    3556:	b9 01       	movw	r22, r18
    3558:	4e 85       	ldd	r20, Y+14	; 0x0e
    355a:	0e 94 d9 1e 	call	0x3db2	; 0x3db2 <prvCopyDataToQueue>
    355e:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3560:	e9 81       	ldd	r30, Y+1	; 0x01
    3562:	fa 81       	ldd	r31, Y+2	; 0x02
    3564:	81 89       	ldd	r24, Z+17	; 0x11
    3566:	88 23       	and	r24, r24
    3568:	51 f0       	breq	.+20     	; 0x357e <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    356a:	89 81       	ldd	r24, Y+1	; 0x01
    356c:	9a 81       	ldd	r25, Y+2	; 0x02
    356e:	41 96       	adiw	r24, 0x11	; 17
    3570:	0e 94 96 2a 	call	0x552c	; 0x552c <xTaskRemoveFromEventList>
    3574:	88 23       	and	r24, r24
    3576:	41 f0       	breq	.+16     	; 0x3588 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    3578:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
    357c:	05 c0       	rjmp	.+10     	; 0x3588 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    357e:	8b 81       	ldd	r24, Y+3	; 0x03
    3580:	88 23       	and	r24, r24
    3582:	11 f0       	breq	.+4      	; 0x3588 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    3584:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    3588:	0f 90       	pop	r0
    358a:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    358c:	81 e0       	ldi	r24, 0x01	; 1
    358e:	8f 87       	std	Y+15, r24	; 0x0f
    3590:	5c c0       	rjmp	.+184    	; 0x364a <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3592:	8c 85       	ldd	r24, Y+12	; 0x0c
    3594:	9d 85       	ldd	r25, Y+13	; 0x0d
    3596:	00 97       	sbiw	r24, 0x00	; 0
    3598:	21 f4       	brne	.+8      	; 0x35a2 <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    359a:	0f 90       	pop	r0
    359c:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    359e:	1f 86       	std	Y+15, r1	; 0x0f
    35a0:	54 c0       	rjmp	.+168    	; 0x364a <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    35a2:	8c 81       	ldd	r24, Y+4	; 0x04
    35a4:	88 23       	and	r24, r24
    35a6:	31 f4       	brne	.+12     	; 0x35b4 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    35a8:	ce 01       	movw	r24, r28
    35aa:	05 96       	adiw	r24, 0x05	; 5
    35ac:	0e 94 06 2d 	call	0x5a0c	; 0x5a0c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    35b0:	81 e0       	ldi	r24, 0x01	; 1
    35b2:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    35b4:	0f 90       	pop	r0
    35b6:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    35b8:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    35bc:	0f b6       	in	r0, 0x3f	; 63
    35be:	f8 94       	cli
    35c0:	0f 92       	push	r0
    35c2:	e9 81       	ldd	r30, Y+1	; 0x01
    35c4:	fa 81       	ldd	r31, Y+2	; 0x02
    35c6:	85 8d       	ldd	r24, Z+29	; 0x1d
    35c8:	8f 3f       	cpi	r24, 0xFF	; 255
    35ca:	19 f4       	brne	.+6      	; 0x35d2 <xQueueGenericSend+0xcc>
    35cc:	e9 81       	ldd	r30, Y+1	; 0x01
    35ce:	fa 81       	ldd	r31, Y+2	; 0x02
    35d0:	15 8e       	std	Z+29, r1	; 0x1d
    35d2:	e9 81       	ldd	r30, Y+1	; 0x01
    35d4:	fa 81       	ldd	r31, Y+2	; 0x02
    35d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    35d8:	8f 3f       	cpi	r24, 0xFF	; 255
    35da:	19 f4       	brne	.+6      	; 0x35e2 <xQueueGenericSend+0xdc>
    35dc:	e9 81       	ldd	r30, Y+1	; 0x01
    35de:	fa 81       	ldd	r31, Y+2	; 0x02
    35e0:	16 8e       	std	Z+30, r1	; 0x1e
    35e2:	0f 90       	pop	r0
    35e4:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    35e6:	ce 01       	movw	r24, r28
    35e8:	05 96       	adiw	r24, 0x05	; 5
    35ea:	9e 01       	movw	r18, r28
    35ec:	24 5f       	subi	r18, 0xF4	; 244
    35ee:	3f 4f       	sbci	r19, 0xFF	; 255
    35f0:	b9 01       	movw	r22, r18
    35f2:	0e 94 1f 2d 	call	0x5a3e	; 0x5a3e <xTaskCheckForTimeOut>
    35f6:	88 23       	and	r24, r24
    35f8:	09 f5       	brne	.+66     	; 0x363c <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    35fa:	89 81       	ldd	r24, Y+1	; 0x01
    35fc:	9a 81       	ldd	r25, Y+2	; 0x02
    35fe:	0e 94 55 20 	call	0x40aa	; 0x40aa <prvIsQueueFull>
    3602:	88 23       	and	r24, r24
    3604:	a1 f0       	breq	.+40     	; 0x362e <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3606:	89 81       	ldd	r24, Y+1	; 0x01
    3608:	9a 81       	ldd	r25, Y+2	; 0x02
    360a:	08 96       	adiw	r24, 0x08	; 8
    360c:	2c 85       	ldd	r18, Y+12	; 0x0c
    360e:	3d 85       	ldd	r19, Y+13	; 0x0d
    3610:	b9 01       	movw	r22, r18
    3612:	0e 94 ad 29 	call	0x535a	; 0x535a <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    3616:	89 81       	ldd	r24, Y+1	; 0x01
    3618:	9a 81       	ldd	r25, Y+2	; 0x02
    361a:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    361e:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    3622:	88 23       	and	r24, r24
    3624:	09 f0       	breq	.+2      	; 0x3628 <xQueueGenericSend+0x122>
    3626:	85 cf       	rjmp	.-246    	; 0x3532 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    3628:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
    362c:	82 cf       	rjmp	.-252    	; 0x3532 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    362e:	89 81       	ldd	r24, Y+1	; 0x01
    3630:	9a 81       	ldd	r25, Y+2	; 0x02
    3632:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3636:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    363a:	7b cf       	rjmp	.-266    	; 0x3532 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    363c:	89 81       	ldd	r24, Y+1	; 0x01
    363e:	9a 81       	ldd	r25, Y+2	; 0x02
    3640:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3644:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    3648:	1f 86       	std	Y+15, r1	; 0x0f
    364a:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    364c:	2f 96       	adiw	r28, 0x0f	; 15
    364e:	0f b6       	in	r0, 0x3f	; 63
    3650:	f8 94       	cli
    3652:	de bf       	out	0x3e, r29	; 62
    3654:	0f be       	out	0x3f, r0	; 63
    3656:	cd bf       	out	0x3d, r28	; 61
    3658:	cf 91       	pop	r28
    365a:	df 91       	pop	r29
    365c:	08 95       	ret

0000365e <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    365e:	df 93       	push	r29
    3660:	cf 93       	push	r28
    3662:	cd b7       	in	r28, 0x3d	; 61
    3664:	de b7       	in	r29, 0x3e	; 62
    3666:	2d 97       	sbiw	r28, 0x0d	; 13
    3668:	0f b6       	in	r0, 0x3f	; 63
    366a:	f8 94       	cli
    366c:	de bf       	out	0x3e, r29	; 62
    366e:	0f be       	out	0x3f, r0	; 63
    3670:	cd bf       	out	0x3d, r28	; 61
    3672:	98 87       	std	Y+8, r25	; 0x08
    3674:	8f 83       	std	Y+7, r24	; 0x07
    3676:	7a 87       	std	Y+10, r23	; 0x0a
    3678:	69 87       	std	Y+9, r22	; 0x09
    367a:	5c 87       	std	Y+12, r21	; 0x0c
    367c:	4b 87       	std	Y+11, r20	; 0x0b
    367e:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3680:	8f 81       	ldd	r24, Y+7	; 0x07
    3682:	98 85       	ldd	r25, Y+8	; 0x08
    3684:	9c 83       	std	Y+4, r25	; 0x04
    3686:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3688:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    368a:	eb 81       	ldd	r30, Y+3	; 0x03
    368c:	fc 81       	ldd	r31, Y+4	; 0x04
    368e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3690:	eb 81       	ldd	r30, Y+3	; 0x03
    3692:	fc 81       	ldd	r31, Y+4	; 0x04
    3694:	83 8d       	ldd	r24, Z+27	; 0x1b
    3696:	98 17       	cp	r25, r24
    3698:	18 f0       	brcs	.+6      	; 0x36a0 <xQueueGenericSendFromISR+0x42>
    369a:	8d 85       	ldd	r24, Y+13	; 0x0d
    369c:	82 30       	cpi	r24, 0x02	; 2
    369e:	81 f5       	brne	.+96     	; 0x3700 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    36a0:	eb 81       	ldd	r30, Y+3	; 0x03
    36a2:	fc 81       	ldd	r31, Y+4	; 0x04
    36a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    36a6:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    36a8:	eb 81       	ldd	r30, Y+3	; 0x03
    36aa:	fc 81       	ldd	r31, Y+4	; 0x04
    36ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    36ae:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    36b0:	8b 81       	ldd	r24, Y+3	; 0x03
    36b2:	9c 81       	ldd	r25, Y+4	; 0x04
    36b4:	29 85       	ldd	r18, Y+9	; 0x09
    36b6:	3a 85       	ldd	r19, Y+10	; 0x0a
    36b8:	b9 01       	movw	r22, r18
    36ba:	4d 85       	ldd	r20, Y+13	; 0x0d
    36bc:	0e 94 d9 1e 	call	0x3db2	; 0x3db2 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    36c0:	8a 81       	ldd	r24, Y+2	; 0x02
    36c2:	8f 3f       	cpi	r24, 0xFF	; 255
    36c4:	a9 f4       	brne	.+42     	; 0x36f0 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    36c6:	eb 81       	ldd	r30, Y+3	; 0x03
    36c8:	fc 81       	ldd	r31, Y+4	; 0x04
    36ca:	81 89       	ldd	r24, Z+17	; 0x11
    36cc:	88 23       	and	r24, r24
    36ce:	a9 f0       	breq	.+42     	; 0x36fa <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    36d0:	8b 81       	ldd	r24, Y+3	; 0x03
    36d2:	9c 81       	ldd	r25, Y+4	; 0x04
    36d4:	41 96       	adiw	r24, 0x11	; 17
    36d6:	0e 94 96 2a 	call	0x552c	; 0x552c <xTaskRemoveFromEventList>
    36da:	88 23       	and	r24, r24
    36dc:	71 f0       	breq	.+28     	; 0x36fa <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    36de:	8b 85       	ldd	r24, Y+11	; 0x0b
    36e0:	9c 85       	ldd	r25, Y+12	; 0x0c
    36e2:	00 97       	sbiw	r24, 0x00	; 0
    36e4:	51 f0       	breq	.+20     	; 0x36fa <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    36e6:	eb 85       	ldd	r30, Y+11	; 0x0b
    36e8:	fc 85       	ldd	r31, Y+12	; 0x0c
    36ea:	81 e0       	ldi	r24, 0x01	; 1
    36ec:	80 83       	st	Z, r24
    36ee:	05 c0       	rjmp	.+10     	; 0x36fa <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    36f0:	8a 81       	ldd	r24, Y+2	; 0x02
    36f2:	8f 5f       	subi	r24, 0xFF	; 255
    36f4:	eb 81       	ldd	r30, Y+3	; 0x03
    36f6:	fc 81       	ldd	r31, Y+4	; 0x04
    36f8:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    36fa:	81 e0       	ldi	r24, 0x01	; 1
    36fc:	8e 83       	std	Y+6, r24	; 0x06
    36fe:	01 c0       	rjmp	.+2      	; 0x3702 <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    3700:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3702:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3704:	2d 96       	adiw	r28, 0x0d	; 13
    3706:	0f b6       	in	r0, 0x3f	; 63
    3708:	f8 94       	cli
    370a:	de bf       	out	0x3e, r29	; 62
    370c:	0f be       	out	0x3f, r0	; 63
    370e:	cd bf       	out	0x3d, r28	; 61
    3710:	cf 91       	pop	r28
    3712:	df 91       	pop	r29
    3714:	08 95       	ret

00003716 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    3716:	df 93       	push	r29
    3718:	cf 93       	push	r28
    371a:	cd b7       	in	r28, 0x3d	; 61
    371c:	de b7       	in	r29, 0x3e	; 62
    371e:	2a 97       	sbiw	r28, 0x0a	; 10
    3720:	0f b6       	in	r0, 0x3f	; 63
    3722:	f8 94       	cli
    3724:	de bf       	out	0x3e, r29	; 62
    3726:	0f be       	out	0x3f, r0	; 63
    3728:	cd bf       	out	0x3d, r28	; 61
    372a:	98 87       	std	Y+8, r25	; 0x08
    372c:	8f 83       	std	Y+7, r24	; 0x07
    372e:	7a 87       	std	Y+10, r23	; 0x0a
    3730:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3732:	8f 81       	ldd	r24, Y+7	; 0x07
    3734:	98 85       	ldd	r25, Y+8	; 0x08
    3736:	9c 83       	std	Y+4, r25	; 0x04
    3738:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    373a:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    373c:	eb 81       	ldd	r30, Y+3	; 0x03
    373e:	fc 81       	ldd	r31, Y+4	; 0x04
    3740:	82 8d       	ldd	r24, Z+26	; 0x1a
    3742:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    3744:	eb 81       	ldd	r30, Y+3	; 0x03
    3746:	fc 81       	ldd	r31, Y+4	; 0x04
    3748:	93 8d       	ldd	r25, Z+27	; 0x1b
    374a:	8a 81       	ldd	r24, Y+2	; 0x02
    374c:	89 17       	cp	r24, r25
    374e:	48 f5       	brcc	.+82     	; 0x37a2 <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    3750:	eb 81       	ldd	r30, Y+3	; 0x03
    3752:	fc 81       	ldd	r31, Y+4	; 0x04
    3754:	86 8d       	ldd	r24, Z+30	; 0x1e
    3756:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3758:	8a 81       	ldd	r24, Y+2	; 0x02
    375a:	8f 5f       	subi	r24, 0xFF	; 255
    375c:	eb 81       	ldd	r30, Y+3	; 0x03
    375e:	fc 81       	ldd	r31, Y+4	; 0x04
    3760:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    3762:	89 81       	ldd	r24, Y+1	; 0x01
    3764:	8f 3f       	cpi	r24, 0xFF	; 255
    3766:	a9 f4       	brne	.+42     	; 0x3792 <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3768:	eb 81       	ldd	r30, Y+3	; 0x03
    376a:	fc 81       	ldd	r31, Y+4	; 0x04
    376c:	81 89       	ldd	r24, Z+17	; 0x11
    376e:	88 23       	and	r24, r24
    3770:	a9 f0       	breq	.+42     	; 0x379c <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3772:	8b 81       	ldd	r24, Y+3	; 0x03
    3774:	9c 81       	ldd	r25, Y+4	; 0x04
    3776:	41 96       	adiw	r24, 0x11	; 17
    3778:	0e 94 96 2a 	call	0x552c	; 0x552c <xTaskRemoveFromEventList>
    377c:	88 23       	and	r24, r24
    377e:	71 f0       	breq	.+28     	; 0x379c <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    3780:	89 85       	ldd	r24, Y+9	; 0x09
    3782:	9a 85       	ldd	r25, Y+10	; 0x0a
    3784:	00 97       	sbiw	r24, 0x00	; 0
    3786:	51 f0       	breq	.+20     	; 0x379c <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    3788:	e9 85       	ldd	r30, Y+9	; 0x09
    378a:	fa 85       	ldd	r31, Y+10	; 0x0a
    378c:	81 e0       	ldi	r24, 0x01	; 1
    378e:	80 83       	st	Z, r24
    3790:	05 c0       	rjmp	.+10     	; 0x379c <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    3792:	89 81       	ldd	r24, Y+1	; 0x01
    3794:	8f 5f       	subi	r24, 0xFF	; 255
    3796:	eb 81       	ldd	r30, Y+3	; 0x03
    3798:	fc 81       	ldd	r31, Y+4	; 0x04
    379a:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    379c:	81 e0       	ldi	r24, 0x01	; 1
    379e:	8e 83       	std	Y+6, r24	; 0x06
    37a0:	01 c0       	rjmp	.+2      	; 0x37a4 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    37a2:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    37a4:	8e 81       	ldd	r24, Y+6	; 0x06
}
    37a6:	2a 96       	adiw	r28, 0x0a	; 10
    37a8:	0f b6       	in	r0, 0x3f	; 63
    37aa:	f8 94       	cli
    37ac:	de bf       	out	0x3e, r29	; 62
    37ae:	0f be       	out	0x3f, r0	; 63
    37b0:	cd bf       	out	0x3d, r28	; 61
    37b2:	cf 91       	pop	r28
    37b4:	df 91       	pop	r29
    37b6:	08 95       	ret

000037b8 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    37b8:	df 93       	push	r29
    37ba:	cf 93       	push	r28
    37bc:	cd b7       	in	r28, 0x3d	; 61
    37be:	de b7       	in	r29, 0x3e	; 62
    37c0:	2e 97       	sbiw	r28, 0x0e	; 14
    37c2:	0f b6       	in	r0, 0x3f	; 63
    37c4:	f8 94       	cli
    37c6:	de bf       	out	0x3e, r29	; 62
    37c8:	0f be       	out	0x3f, r0	; 63
    37ca:	cd bf       	out	0x3d, r28	; 61
    37cc:	99 87       	std	Y+9, r25	; 0x09
    37ce:	88 87       	std	Y+8, r24	; 0x08
    37d0:	7b 87       	std	Y+11, r23	; 0x0b
    37d2:	6a 87       	std	Y+10, r22	; 0x0a
    37d4:	5d 87       	std	Y+13, r21	; 0x0d
    37d6:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    37d8:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    37da:	88 85       	ldd	r24, Y+8	; 0x08
    37dc:	99 85       	ldd	r25, Y+9	; 0x09
    37de:	9b 83       	std	Y+3, r25	; 0x03
    37e0:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    37e2:	0f b6       	in	r0, 0x3f	; 63
    37e4:	f8 94       	cli
    37e6:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    37e8:	ea 81       	ldd	r30, Y+2	; 0x02
    37ea:	fb 81       	ldd	r31, Y+3	; 0x03
    37ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    37ee:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    37f0:	89 81       	ldd	r24, Y+1	; 0x01
    37f2:	88 23       	and	r24, r24
    37f4:	f9 f0       	breq	.+62     	; 0x3834 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    37f6:	8a 81       	ldd	r24, Y+2	; 0x02
    37f8:	9b 81       	ldd	r25, Y+3	; 0x03
    37fa:	2a 85       	ldd	r18, Y+10	; 0x0a
    37fc:	3b 85       	ldd	r19, Y+11	; 0x0b
    37fe:	b9 01       	movw	r22, r18
    3800:	0e 94 7f 1f 	call	0x3efe	; 0x3efe <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3804:	89 81       	ldd	r24, Y+1	; 0x01
    3806:	81 50       	subi	r24, 0x01	; 1
    3808:	ea 81       	ldd	r30, Y+2	; 0x02
    380a:	fb 81       	ldd	r31, Y+3	; 0x03
    380c:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    380e:	ea 81       	ldd	r30, Y+2	; 0x02
    3810:	fb 81       	ldd	r31, Y+3	; 0x03
    3812:	80 85       	ldd	r24, Z+8	; 0x08
    3814:	88 23       	and	r24, r24
    3816:	49 f0       	breq	.+18     	; 0x382a <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3818:	8a 81       	ldd	r24, Y+2	; 0x02
    381a:	9b 81       	ldd	r25, Y+3	; 0x03
    381c:	08 96       	adiw	r24, 0x08	; 8
    381e:	0e 94 96 2a 	call	0x552c	; 0x552c <xTaskRemoveFromEventList>
    3822:	88 23       	and	r24, r24
    3824:	11 f0       	breq	.+4      	; 0x382a <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    3826:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    382a:	0f 90       	pop	r0
    382c:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    382e:	81 e0       	ldi	r24, 0x01	; 1
    3830:	8e 87       	std	Y+14, r24	; 0x0e
    3832:	63 c0       	rjmp	.+198    	; 0x38fa <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3834:	8c 85       	ldd	r24, Y+12	; 0x0c
    3836:	9d 85       	ldd	r25, Y+13	; 0x0d
    3838:	00 97       	sbiw	r24, 0x00	; 0
    383a:	21 f4       	brne	.+8      	; 0x3844 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    383c:	0f 90       	pop	r0
    383e:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    3840:	1e 86       	std	Y+14, r1	; 0x0e
    3842:	5b c0       	rjmp	.+182    	; 0x38fa <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    3844:	8c 81       	ldd	r24, Y+4	; 0x04
    3846:	88 23       	and	r24, r24
    3848:	31 f4       	brne	.+12     	; 0x3856 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    384a:	ce 01       	movw	r24, r28
    384c:	05 96       	adiw	r24, 0x05	; 5
    384e:	0e 94 06 2d 	call	0x5a0c	; 0x5a0c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    3852:	81 e0       	ldi	r24, 0x01	; 1
    3854:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3856:	0f 90       	pop	r0
    3858:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    385a:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    385e:	0f b6       	in	r0, 0x3f	; 63
    3860:	f8 94       	cli
    3862:	0f 92       	push	r0
    3864:	ea 81       	ldd	r30, Y+2	; 0x02
    3866:	fb 81       	ldd	r31, Y+3	; 0x03
    3868:	85 8d       	ldd	r24, Z+29	; 0x1d
    386a:	8f 3f       	cpi	r24, 0xFF	; 255
    386c:	19 f4       	brne	.+6      	; 0x3874 <xQueueReceive+0xbc>
    386e:	ea 81       	ldd	r30, Y+2	; 0x02
    3870:	fb 81       	ldd	r31, Y+3	; 0x03
    3872:	15 8e       	std	Z+29, r1	; 0x1d
    3874:	ea 81       	ldd	r30, Y+2	; 0x02
    3876:	fb 81       	ldd	r31, Y+3	; 0x03
    3878:	86 8d       	ldd	r24, Z+30	; 0x1e
    387a:	8f 3f       	cpi	r24, 0xFF	; 255
    387c:	19 f4       	brne	.+6      	; 0x3884 <xQueueReceive+0xcc>
    387e:	ea 81       	ldd	r30, Y+2	; 0x02
    3880:	fb 81       	ldd	r31, Y+3	; 0x03
    3882:	16 8e       	std	Z+30, r1	; 0x1e
    3884:	0f 90       	pop	r0
    3886:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3888:	ce 01       	movw	r24, r28
    388a:	05 96       	adiw	r24, 0x05	; 5
    388c:	9e 01       	movw	r18, r28
    388e:	24 5f       	subi	r18, 0xF4	; 244
    3890:	3f 4f       	sbci	r19, 0xFF	; 255
    3892:	b9 01       	movw	r22, r18
    3894:	0e 94 1f 2d 	call	0x5a3e	; 0x5a3e <xTaskCheckForTimeOut>
    3898:	88 23       	and	r24, r24
    389a:	09 f5       	brne	.+66     	; 0x38de <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    389c:	8a 81       	ldd	r24, Y+2	; 0x02
    389e:	9b 81       	ldd	r25, Y+3	; 0x03
    38a0:	0e 94 19 20 	call	0x4032	; 0x4032 <prvIsQueueEmpty>
    38a4:	88 23       	and	r24, r24
    38a6:	a1 f0       	breq	.+40     	; 0x38d0 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    38a8:	8a 81       	ldd	r24, Y+2	; 0x02
    38aa:	9b 81       	ldd	r25, Y+3	; 0x03
    38ac:	41 96       	adiw	r24, 0x11	; 17
    38ae:	2c 85       	ldd	r18, Y+12	; 0x0c
    38b0:	3d 85       	ldd	r19, Y+13	; 0x0d
    38b2:	b9 01       	movw	r22, r18
    38b4:	0e 94 ad 29 	call	0x535a	; 0x535a <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    38b8:	8a 81       	ldd	r24, Y+2	; 0x02
    38ba:	9b 81       	ldd	r25, Y+3	; 0x03
    38bc:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    38c0:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    38c4:	88 23       	and	r24, r24
    38c6:	09 f0       	breq	.+2      	; 0x38ca <xQueueReceive+0x112>
    38c8:	8c cf       	rjmp	.-232    	; 0x37e2 <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    38ca:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
    38ce:	89 cf       	rjmp	.-238    	; 0x37e2 <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    38d0:	8a 81       	ldd	r24, Y+2	; 0x02
    38d2:	9b 81       	ldd	r25, Y+3	; 0x03
    38d4:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    38d8:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    38dc:	82 cf       	rjmp	.-252    	; 0x37e2 <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    38de:	8a 81       	ldd	r24, Y+2	; 0x02
    38e0:	9b 81       	ldd	r25, Y+3	; 0x03
    38e2:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    38e6:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    38ea:	8a 81       	ldd	r24, Y+2	; 0x02
    38ec:	9b 81       	ldd	r25, Y+3	; 0x03
    38ee:	0e 94 19 20 	call	0x4032	; 0x4032 <prvIsQueueEmpty>
    38f2:	88 23       	and	r24, r24
    38f4:	09 f4       	brne	.+2      	; 0x38f8 <xQueueReceive+0x140>
    38f6:	75 cf       	rjmp	.-278    	; 0x37e2 <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    38f8:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    38fa:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    38fc:	2e 96       	adiw	r28, 0x0e	; 14
    38fe:	0f b6       	in	r0, 0x3f	; 63
    3900:	f8 94       	cli
    3902:	de bf       	out	0x3e, r29	; 62
    3904:	0f be       	out	0x3f, r0	; 63
    3906:	cd bf       	out	0x3d, r28	; 61
    3908:	cf 91       	pop	r28
    390a:	df 91       	pop	r29
    390c:	08 95       	ret

0000390e <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    390e:	df 93       	push	r29
    3910:	cf 93       	push	r28
    3912:	cd b7       	in	r28, 0x3d	; 61
    3914:	de b7       	in	r29, 0x3e	; 62
    3916:	2c 97       	sbiw	r28, 0x0c	; 12
    3918:	0f b6       	in	r0, 0x3f	; 63
    391a:	f8 94       	cli
    391c:	de bf       	out	0x3e, r29	; 62
    391e:	0f be       	out	0x3f, r0	; 63
    3920:	cd bf       	out	0x3d, r28	; 61
    3922:	99 87       	std	Y+9, r25	; 0x09
    3924:	88 87       	std	Y+8, r24	; 0x08
    3926:	7b 87       	std	Y+11, r23	; 0x0b
    3928:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    392a:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    392c:	88 85       	ldd	r24, Y+8	; 0x08
    392e:	99 85       	ldd	r25, Y+9	; 0x09
    3930:	9b 83       	std	Y+3, r25	; 0x03
    3932:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3934:	0f b6       	in	r0, 0x3f	; 63
    3936:	f8 94       	cli
    3938:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    393a:	ea 81       	ldd	r30, Y+2	; 0x02
    393c:	fb 81       	ldd	r31, Y+3	; 0x03
    393e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3940:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    3942:	89 81       	ldd	r24, Y+1	; 0x01
    3944:	88 23       	and	r24, r24
    3946:	c1 f0       	breq	.+48     	; 0x3978 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3948:	89 81       	ldd	r24, Y+1	; 0x01
    394a:	81 50       	subi	r24, 0x01	; 1
    394c:	ea 81       	ldd	r30, Y+2	; 0x02
    394e:	fb 81       	ldd	r31, Y+3	; 0x03
    3950:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3952:	ea 81       	ldd	r30, Y+2	; 0x02
    3954:	fb 81       	ldd	r31, Y+3	; 0x03
    3956:	80 85       	ldd	r24, Z+8	; 0x08
    3958:	88 23       	and	r24, r24
    395a:	49 f0       	breq	.+18     	; 0x396e <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    395c:	8a 81       	ldd	r24, Y+2	; 0x02
    395e:	9b 81       	ldd	r25, Y+3	; 0x03
    3960:	08 96       	adiw	r24, 0x08	; 8
    3962:	0e 94 96 2a 	call	0x552c	; 0x552c <xTaskRemoveFromEventList>
    3966:	88 23       	and	r24, r24
    3968:	11 f0       	breq	.+4      	; 0x396e <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    396a:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    396e:	0f 90       	pop	r0
    3970:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    3972:	81 e0       	ldi	r24, 0x01	; 1
    3974:	8c 87       	std	Y+12, r24	; 0x0c
    3976:	63 c0       	rjmp	.+198    	; 0x3a3e <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3978:	8a 85       	ldd	r24, Y+10	; 0x0a
    397a:	9b 85       	ldd	r25, Y+11	; 0x0b
    397c:	00 97       	sbiw	r24, 0x00	; 0
    397e:	21 f4       	brne	.+8      	; 0x3988 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    3980:	0f 90       	pop	r0
    3982:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    3984:	1c 86       	std	Y+12, r1	; 0x0c
    3986:	5b c0       	rjmp	.+182    	; 0x3a3e <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    3988:	8c 81       	ldd	r24, Y+4	; 0x04
    398a:	88 23       	and	r24, r24
    398c:	31 f4       	brne	.+12     	; 0x399a <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    398e:	ce 01       	movw	r24, r28
    3990:	05 96       	adiw	r24, 0x05	; 5
    3992:	0e 94 06 2d 	call	0x5a0c	; 0x5a0c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    3996:	81 e0       	ldi	r24, 0x01	; 1
    3998:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    399a:	0f 90       	pop	r0
    399c:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    399e:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    39a2:	0f b6       	in	r0, 0x3f	; 63
    39a4:	f8 94       	cli
    39a6:	0f 92       	push	r0
    39a8:	ea 81       	ldd	r30, Y+2	; 0x02
    39aa:	fb 81       	ldd	r31, Y+3	; 0x03
    39ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    39ae:	8f 3f       	cpi	r24, 0xFF	; 255
    39b0:	19 f4       	brne	.+6      	; 0x39b8 <xQueueSemaphoreTake+0xaa>
    39b2:	ea 81       	ldd	r30, Y+2	; 0x02
    39b4:	fb 81       	ldd	r31, Y+3	; 0x03
    39b6:	15 8e       	std	Z+29, r1	; 0x1d
    39b8:	ea 81       	ldd	r30, Y+2	; 0x02
    39ba:	fb 81       	ldd	r31, Y+3	; 0x03
    39bc:	86 8d       	ldd	r24, Z+30	; 0x1e
    39be:	8f 3f       	cpi	r24, 0xFF	; 255
    39c0:	19 f4       	brne	.+6      	; 0x39c8 <xQueueSemaphoreTake+0xba>
    39c2:	ea 81       	ldd	r30, Y+2	; 0x02
    39c4:	fb 81       	ldd	r31, Y+3	; 0x03
    39c6:	16 8e       	std	Z+30, r1	; 0x1e
    39c8:	0f 90       	pop	r0
    39ca:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    39cc:	ce 01       	movw	r24, r28
    39ce:	05 96       	adiw	r24, 0x05	; 5
    39d0:	9e 01       	movw	r18, r28
    39d2:	26 5f       	subi	r18, 0xF6	; 246
    39d4:	3f 4f       	sbci	r19, 0xFF	; 255
    39d6:	b9 01       	movw	r22, r18
    39d8:	0e 94 1f 2d 	call	0x5a3e	; 0x5a3e <xTaskCheckForTimeOut>
    39dc:	88 23       	and	r24, r24
    39de:	09 f5       	brne	.+66     	; 0x3a22 <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    39e0:	8a 81       	ldd	r24, Y+2	; 0x02
    39e2:	9b 81       	ldd	r25, Y+3	; 0x03
    39e4:	0e 94 19 20 	call	0x4032	; 0x4032 <prvIsQueueEmpty>
    39e8:	88 23       	and	r24, r24
    39ea:	a1 f0       	breq	.+40     	; 0x3a14 <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    39ec:	8a 81       	ldd	r24, Y+2	; 0x02
    39ee:	9b 81       	ldd	r25, Y+3	; 0x03
    39f0:	41 96       	adiw	r24, 0x11	; 17
    39f2:	2a 85       	ldd	r18, Y+10	; 0x0a
    39f4:	3b 85       	ldd	r19, Y+11	; 0x0b
    39f6:	b9 01       	movw	r22, r18
    39f8:	0e 94 ad 29 	call	0x535a	; 0x535a <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    39fc:	8a 81       	ldd	r24, Y+2	; 0x02
    39fe:	9b 81       	ldd	r25, Y+3	; 0x03
    3a00:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3a04:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    3a08:	88 23       	and	r24, r24
    3a0a:	09 f0       	breq	.+2      	; 0x3a0e <xQueueSemaphoreTake+0x100>
    3a0c:	93 cf       	rjmp	.-218    	; 0x3934 <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    3a0e:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
    3a12:	90 cf       	rjmp	.-224    	; 0x3934 <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    3a14:	8a 81       	ldd	r24, Y+2	; 0x02
    3a16:	9b 81       	ldd	r25, Y+3	; 0x03
    3a18:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3a1c:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    3a20:	89 cf       	rjmp	.-238    	; 0x3934 <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    3a22:	8a 81       	ldd	r24, Y+2	; 0x02
    3a24:	9b 81       	ldd	r25, Y+3	; 0x03
    3a26:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3a2a:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3a2e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a30:	9b 81       	ldd	r25, Y+3	; 0x03
    3a32:	0e 94 19 20 	call	0x4032	; 0x4032 <prvIsQueueEmpty>
    3a36:	88 23       	and	r24, r24
    3a38:	09 f4       	brne	.+2      	; 0x3a3c <xQueueSemaphoreTake+0x12e>
    3a3a:	7c cf       	rjmp	.-264    	; 0x3934 <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    3a3c:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    3a3e:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    3a40:	2c 96       	adiw	r28, 0x0c	; 12
    3a42:	0f b6       	in	r0, 0x3f	; 63
    3a44:	f8 94       	cli
    3a46:	de bf       	out	0x3e, r29	; 62
    3a48:	0f be       	out	0x3f, r0	; 63
    3a4a:	cd bf       	out	0x3d, r28	; 61
    3a4c:	cf 91       	pop	r28
    3a4e:	df 91       	pop	r29
    3a50:	08 95       	ret

00003a52 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    3a52:	df 93       	push	r29
    3a54:	cf 93       	push	r28
    3a56:	cd b7       	in	r28, 0x3d	; 61
    3a58:	de b7       	in	r29, 0x3e	; 62
    3a5a:	60 97       	sbiw	r28, 0x10	; 16
    3a5c:	0f b6       	in	r0, 0x3f	; 63
    3a5e:	f8 94       	cli
    3a60:	de bf       	out	0x3e, r29	; 62
    3a62:	0f be       	out	0x3f, r0	; 63
    3a64:	cd bf       	out	0x3d, r28	; 61
    3a66:	9b 87       	std	Y+11, r25	; 0x0b
    3a68:	8a 87       	std	Y+10, r24	; 0x0a
    3a6a:	7d 87       	std	Y+13, r23	; 0x0d
    3a6c:	6c 87       	std	Y+12, r22	; 0x0c
    3a6e:	5f 87       	std	Y+15, r21	; 0x0f
    3a70:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    3a72:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    3a74:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a76:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a78:	9b 83       	std	Y+3, r25	; 0x03
    3a7a:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3a7c:	0f b6       	in	r0, 0x3f	; 63
    3a7e:	f8 94       	cli
    3a80:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3a82:	ea 81       	ldd	r30, Y+2	; 0x02
    3a84:	fb 81       	ldd	r31, Y+3	; 0x03
    3a86:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a88:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3a8a:	89 81       	ldd	r24, Y+1	; 0x01
    3a8c:	88 23       	and	r24, r24
    3a8e:	31 f1       	breq	.+76     	; 0x3adc <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3a90:	ea 81       	ldd	r30, Y+2	; 0x02
    3a92:	fb 81       	ldd	r31, Y+3	; 0x03
    3a94:	86 81       	ldd	r24, Z+6	; 0x06
    3a96:	97 81       	ldd	r25, Z+7	; 0x07
    3a98:	9d 83       	std	Y+5, r25	; 0x05
    3a9a:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    3a9c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a9e:	9b 81       	ldd	r25, Y+3	; 0x03
    3aa0:	2c 85       	ldd	r18, Y+12	; 0x0c
    3aa2:	3d 85       	ldd	r19, Y+13	; 0x0d
    3aa4:	b9 01       	movw	r22, r18
    3aa6:	0e 94 7f 1f 	call	0x3efe	; 0x3efe <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3aaa:	ea 81       	ldd	r30, Y+2	; 0x02
    3aac:	fb 81       	ldd	r31, Y+3	; 0x03
    3aae:	8c 81       	ldd	r24, Y+4	; 0x04
    3ab0:	9d 81       	ldd	r25, Y+5	; 0x05
    3ab2:	97 83       	std	Z+7, r25	; 0x07
    3ab4:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3ab6:	ea 81       	ldd	r30, Y+2	; 0x02
    3ab8:	fb 81       	ldd	r31, Y+3	; 0x03
    3aba:	81 89       	ldd	r24, Z+17	; 0x11
    3abc:	88 23       	and	r24, r24
    3abe:	49 f0       	breq	.+18     	; 0x3ad2 <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3ac0:	8a 81       	ldd	r24, Y+2	; 0x02
    3ac2:	9b 81       	ldd	r25, Y+3	; 0x03
    3ac4:	41 96       	adiw	r24, 0x11	; 17
    3ac6:	0e 94 96 2a 	call	0x552c	; 0x552c <xTaskRemoveFromEventList>
    3aca:	88 23       	and	r24, r24
    3acc:	11 f0       	breq	.+4      	; 0x3ad2 <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    3ace:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3ad2:	0f 90       	pop	r0
    3ad4:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    3ad6:	81 e0       	ldi	r24, 0x01	; 1
    3ad8:	88 8b       	std	Y+16, r24	; 0x10
    3ada:	63 c0       	rjmp	.+198    	; 0x3ba2 <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3adc:	8e 85       	ldd	r24, Y+14	; 0x0e
    3ade:	9f 85       	ldd	r25, Y+15	; 0x0f
    3ae0:	00 97       	sbiw	r24, 0x00	; 0
    3ae2:	21 f4       	brne	.+8      	; 0x3aec <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3ae4:	0f 90       	pop	r0
    3ae6:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    3ae8:	18 8a       	std	Y+16, r1	; 0x10
    3aea:	5b c0       	rjmp	.+182    	; 0x3ba2 <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    3aec:	8e 81       	ldd	r24, Y+6	; 0x06
    3aee:	88 23       	and	r24, r24
    3af0:	31 f4       	brne	.+12     	; 0x3afe <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3af2:	ce 01       	movw	r24, r28
    3af4:	07 96       	adiw	r24, 0x07	; 7
    3af6:	0e 94 06 2d 	call	0x5a0c	; 0x5a0c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    3afa:	81 e0       	ldi	r24, 0x01	; 1
    3afc:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3afe:	0f 90       	pop	r0
    3b00:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    3b02:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3b06:	0f b6       	in	r0, 0x3f	; 63
    3b08:	f8 94       	cli
    3b0a:	0f 92       	push	r0
    3b0c:	ea 81       	ldd	r30, Y+2	; 0x02
    3b0e:	fb 81       	ldd	r31, Y+3	; 0x03
    3b10:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b12:	8f 3f       	cpi	r24, 0xFF	; 255
    3b14:	19 f4       	brne	.+6      	; 0x3b1c <xQueuePeek+0xca>
    3b16:	ea 81       	ldd	r30, Y+2	; 0x02
    3b18:	fb 81       	ldd	r31, Y+3	; 0x03
    3b1a:	15 8e       	std	Z+29, r1	; 0x1d
    3b1c:	ea 81       	ldd	r30, Y+2	; 0x02
    3b1e:	fb 81       	ldd	r31, Y+3	; 0x03
    3b20:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b22:	8f 3f       	cpi	r24, 0xFF	; 255
    3b24:	19 f4       	brne	.+6      	; 0x3b2c <xQueuePeek+0xda>
    3b26:	ea 81       	ldd	r30, Y+2	; 0x02
    3b28:	fb 81       	ldd	r31, Y+3	; 0x03
    3b2a:	16 8e       	std	Z+30, r1	; 0x1e
    3b2c:	0f 90       	pop	r0
    3b2e:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3b30:	ce 01       	movw	r24, r28
    3b32:	07 96       	adiw	r24, 0x07	; 7
    3b34:	9e 01       	movw	r18, r28
    3b36:	22 5f       	subi	r18, 0xF2	; 242
    3b38:	3f 4f       	sbci	r19, 0xFF	; 255
    3b3a:	b9 01       	movw	r22, r18
    3b3c:	0e 94 1f 2d 	call	0x5a3e	; 0x5a3e <xTaskCheckForTimeOut>
    3b40:	88 23       	and	r24, r24
    3b42:	09 f5       	brne	.+66     	; 0x3b86 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3b44:	8a 81       	ldd	r24, Y+2	; 0x02
    3b46:	9b 81       	ldd	r25, Y+3	; 0x03
    3b48:	0e 94 19 20 	call	0x4032	; 0x4032 <prvIsQueueEmpty>
    3b4c:	88 23       	and	r24, r24
    3b4e:	a1 f0       	breq	.+40     	; 0x3b78 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3b50:	8a 81       	ldd	r24, Y+2	; 0x02
    3b52:	9b 81       	ldd	r25, Y+3	; 0x03
    3b54:	41 96       	adiw	r24, 0x11	; 17
    3b56:	2e 85       	ldd	r18, Y+14	; 0x0e
    3b58:	3f 85       	ldd	r19, Y+15	; 0x0f
    3b5a:	b9 01       	movw	r22, r18
    3b5c:	0e 94 ad 29 	call	0x535a	; 0x535a <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3b60:	8a 81       	ldd	r24, Y+2	; 0x02
    3b62:	9b 81       	ldd	r25, Y+3	; 0x03
    3b64:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3b68:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    3b6c:	88 23       	and	r24, r24
    3b6e:	09 f0       	breq	.+2      	; 0x3b72 <xQueuePeek+0x120>
    3b70:	85 cf       	rjmp	.-246    	; 0x3a7c <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    3b72:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
    3b76:	82 cf       	rjmp	.-252    	; 0x3a7c <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    3b78:	8a 81       	ldd	r24, Y+2	; 0x02
    3b7a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b7c:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3b80:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    3b84:	7b cf       	rjmp	.-266    	; 0x3a7c <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    3b86:	8a 81       	ldd	r24, Y+2	; 0x02
    3b88:	9b 81       	ldd	r25, Y+3	; 0x03
    3b8a:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3b8e:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3b92:	8a 81       	ldd	r24, Y+2	; 0x02
    3b94:	9b 81       	ldd	r25, Y+3	; 0x03
    3b96:	0e 94 19 20 	call	0x4032	; 0x4032 <prvIsQueueEmpty>
    3b9a:	88 23       	and	r24, r24
    3b9c:	09 f4       	brne	.+2      	; 0x3ba0 <xQueuePeek+0x14e>
    3b9e:	6e cf       	rjmp	.-292    	; 0x3a7c <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    3ba0:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    3ba2:	88 89       	ldd	r24, Y+16	; 0x10
}
    3ba4:	60 96       	adiw	r28, 0x10	; 16
    3ba6:	0f b6       	in	r0, 0x3f	; 63
    3ba8:	f8 94       	cli
    3baa:	de bf       	out	0x3e, r29	; 62
    3bac:	0f be       	out	0x3f, r0	; 63
    3bae:	cd bf       	out	0x3d, r28	; 61
    3bb0:	cf 91       	pop	r28
    3bb2:	df 91       	pop	r29
    3bb4:	08 95       	ret

00003bb6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3bb6:	df 93       	push	r29
    3bb8:	cf 93       	push	r28
    3bba:	cd b7       	in	r28, 0x3d	; 61
    3bbc:	de b7       	in	r29, 0x3e	; 62
    3bbe:	2c 97       	sbiw	r28, 0x0c	; 12
    3bc0:	0f b6       	in	r0, 0x3f	; 63
    3bc2:	f8 94       	cli
    3bc4:	de bf       	out	0x3e, r29	; 62
    3bc6:	0f be       	out	0x3f, r0	; 63
    3bc8:	cd bf       	out	0x3d, r28	; 61
    3bca:	98 87       	std	Y+8, r25	; 0x08
    3bcc:	8f 83       	std	Y+7, r24	; 0x07
    3bce:	7a 87       	std	Y+10, r23	; 0x0a
    3bd0:	69 87       	std	Y+9, r22	; 0x09
    3bd2:	5c 87       	std	Y+12, r21	; 0x0c
    3bd4:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3bd6:	8f 81       	ldd	r24, Y+7	; 0x07
    3bd8:	98 85       	ldd	r25, Y+8	; 0x08
    3bda:	9c 83       	std	Y+4, r25	; 0x04
    3bdc:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3bde:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3be0:	eb 81       	ldd	r30, Y+3	; 0x03
    3be2:	fc 81       	ldd	r31, Y+4	; 0x04
    3be4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3be6:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3be8:	8a 81       	ldd	r24, Y+2	; 0x02
    3bea:	88 23       	and	r24, r24
    3bec:	81 f1       	breq	.+96     	; 0x3c4e <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    3bee:	eb 81       	ldd	r30, Y+3	; 0x03
    3bf0:	fc 81       	ldd	r31, Y+4	; 0x04
    3bf2:	85 8d       	ldd	r24, Z+29	; 0x1d
    3bf4:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    3bf8:	9c 81       	ldd	r25, Y+4	; 0x04
    3bfa:	29 85       	ldd	r18, Y+9	; 0x09
    3bfc:	3a 85       	ldd	r19, Y+10	; 0x0a
    3bfe:	b9 01       	movw	r22, r18
    3c00:	0e 94 7f 1f 	call	0x3efe	; 0x3efe <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3c04:	8a 81       	ldd	r24, Y+2	; 0x02
    3c06:	81 50       	subi	r24, 0x01	; 1
    3c08:	eb 81       	ldd	r30, Y+3	; 0x03
    3c0a:	fc 81       	ldd	r31, Y+4	; 0x04
    3c0c:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    3c0e:	89 81       	ldd	r24, Y+1	; 0x01
    3c10:	8f 3f       	cpi	r24, 0xFF	; 255
    3c12:	a9 f4       	brne	.+42     	; 0x3c3e <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3c14:	eb 81       	ldd	r30, Y+3	; 0x03
    3c16:	fc 81       	ldd	r31, Y+4	; 0x04
    3c18:	80 85       	ldd	r24, Z+8	; 0x08
    3c1a:	88 23       	and	r24, r24
    3c1c:	a9 f0       	breq	.+42     	; 0x3c48 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3c1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c20:	9c 81       	ldd	r25, Y+4	; 0x04
    3c22:	08 96       	adiw	r24, 0x08	; 8
    3c24:	0e 94 96 2a 	call	0x552c	; 0x552c <xTaskRemoveFromEventList>
    3c28:	88 23       	and	r24, r24
    3c2a:	71 f0       	breq	.+28     	; 0x3c48 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    3c2c:	8b 85       	ldd	r24, Y+11	; 0x0b
    3c2e:	9c 85       	ldd	r25, Y+12	; 0x0c
    3c30:	00 97       	sbiw	r24, 0x00	; 0
    3c32:	51 f0       	breq	.+20     	; 0x3c48 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    3c34:	eb 85       	ldd	r30, Y+11	; 0x0b
    3c36:	fc 85       	ldd	r31, Y+12	; 0x0c
    3c38:	81 e0       	ldi	r24, 0x01	; 1
    3c3a:	80 83       	st	Z, r24
    3c3c:	05 c0       	rjmp	.+10     	; 0x3c48 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3c3e:	89 81       	ldd	r24, Y+1	; 0x01
    3c40:	8f 5f       	subi	r24, 0xFF	; 255
    3c42:	eb 81       	ldd	r30, Y+3	; 0x03
    3c44:	fc 81       	ldd	r31, Y+4	; 0x04
    3c46:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    3c48:	81 e0       	ldi	r24, 0x01	; 1
    3c4a:	8e 83       	std	Y+6, r24	; 0x06
    3c4c:	01 c0       	rjmp	.+2      	; 0x3c50 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    3c4e:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3c50:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3c52:	2c 96       	adiw	r28, 0x0c	; 12
    3c54:	0f b6       	in	r0, 0x3f	; 63
    3c56:	f8 94       	cli
    3c58:	de bf       	out	0x3e, r29	; 62
    3c5a:	0f be       	out	0x3f, r0	; 63
    3c5c:	cd bf       	out	0x3d, r28	; 61
    3c5e:	cf 91       	pop	r28
    3c60:	df 91       	pop	r29
    3c62:	08 95       	ret

00003c64 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    3c64:	df 93       	push	r29
    3c66:	cf 93       	push	r28
    3c68:	cd b7       	in	r28, 0x3d	; 61
    3c6a:	de b7       	in	r29, 0x3e	; 62
    3c6c:	2a 97       	sbiw	r28, 0x0a	; 10
    3c6e:	0f b6       	in	r0, 0x3f	; 63
    3c70:	f8 94       	cli
    3c72:	de bf       	out	0x3e, r29	; 62
    3c74:	0f be       	out	0x3f, r0	; 63
    3c76:	cd bf       	out	0x3d, r28	; 61
    3c78:	98 87       	std	Y+8, r25	; 0x08
    3c7a:	8f 83       	std	Y+7, r24	; 0x07
    3c7c:	7a 87       	std	Y+10, r23	; 0x0a
    3c7e:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    3c80:	8f 81       	ldd	r24, Y+7	; 0x07
    3c82:	98 85       	ldd	r25, Y+8	; 0x08
    3c84:	9a 83       	std	Y+2, r25	; 0x02
    3c86:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3c88:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c8e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c90:	88 23       	and	r24, r24
    3c92:	b1 f0       	breq	.+44     	; 0x3cc0 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3c94:	e9 81       	ldd	r30, Y+1	; 0x01
    3c96:	fa 81       	ldd	r31, Y+2	; 0x02
    3c98:	86 81       	ldd	r24, Z+6	; 0x06
    3c9a:	97 81       	ldd	r25, Z+7	; 0x07
    3c9c:	9c 83       	std	Y+4, r25	; 0x04
    3c9e:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3ca0:	89 81       	ldd	r24, Y+1	; 0x01
    3ca2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ca4:	29 85       	ldd	r18, Y+9	; 0x09
    3ca6:	3a 85       	ldd	r19, Y+10	; 0x0a
    3ca8:	b9 01       	movw	r22, r18
    3caa:	0e 94 7f 1f 	call	0x3efe	; 0x3efe <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3cae:	e9 81       	ldd	r30, Y+1	; 0x01
    3cb0:	fa 81       	ldd	r31, Y+2	; 0x02
    3cb2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb4:	9c 81       	ldd	r25, Y+4	; 0x04
    3cb6:	97 83       	std	Z+7, r25	; 0x07
    3cb8:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    3cba:	81 e0       	ldi	r24, 0x01	; 1
    3cbc:	8e 83       	std	Y+6, r24	; 0x06
    3cbe:	01 c0       	rjmp	.+2      	; 0x3cc2 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    3cc0:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3cc2:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3cc4:	2a 96       	adiw	r28, 0x0a	; 10
    3cc6:	0f b6       	in	r0, 0x3f	; 63
    3cc8:	f8 94       	cli
    3cca:	de bf       	out	0x3e, r29	; 62
    3ccc:	0f be       	out	0x3f, r0	; 63
    3cce:	cd bf       	out	0x3d, r28	; 61
    3cd0:	cf 91       	pop	r28
    3cd2:	df 91       	pop	r29
    3cd4:	08 95       	ret

00003cd6 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3cd6:	df 93       	push	r29
    3cd8:	cf 93       	push	r28
    3cda:	00 d0       	rcall	.+0      	; 0x3cdc <uxQueueMessagesWaiting+0x6>
    3cdc:	0f 92       	push	r0
    3cde:	cd b7       	in	r28, 0x3d	; 61
    3ce0:	de b7       	in	r29, 0x3e	; 62
    3ce2:	9b 83       	std	Y+3, r25	; 0x03
    3ce4:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    3ce6:	0f b6       	in	r0, 0x3f	; 63
    3ce8:	f8 94       	cli
    3cea:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3cec:	ea 81       	ldd	r30, Y+2	; 0x02
    3cee:	fb 81       	ldd	r31, Y+3	; 0x03
    3cf0:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cf2:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    3cf4:	0f 90       	pop	r0
    3cf6:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    3cf8:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3cfa:	0f 90       	pop	r0
    3cfc:	0f 90       	pop	r0
    3cfe:	0f 90       	pop	r0
    3d00:	cf 91       	pop	r28
    3d02:	df 91       	pop	r29
    3d04:	08 95       	ret

00003d06 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3d06:	df 93       	push	r29
    3d08:	cf 93       	push	r28
    3d0a:	00 d0       	rcall	.+0      	; 0x3d0c <uxQueueSpacesAvailable+0x6>
    3d0c:	00 d0       	rcall	.+0      	; 0x3d0e <uxQueueSpacesAvailable+0x8>
    3d0e:	0f 92       	push	r0
    3d10:	cd b7       	in	r28, 0x3d	; 61
    3d12:	de b7       	in	r29, 0x3e	; 62
    3d14:	9d 83       	std	Y+5, r25	; 0x05
    3d16:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    3d18:	8c 81       	ldd	r24, Y+4	; 0x04
    3d1a:	9d 81       	ldd	r25, Y+5	; 0x05
    3d1c:	9a 83       	std	Y+2, r25	; 0x02
    3d1e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    3d20:	0f b6       	in	r0, 0x3f	; 63
    3d22:	f8 94       	cli
    3d24:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3d26:	e9 81       	ldd	r30, Y+1	; 0x01
    3d28:	fa 81       	ldd	r31, Y+2	; 0x02
    3d2a:	93 8d       	ldd	r25, Z+27	; 0x1b
    3d2c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d2e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d30:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d32:	29 2f       	mov	r18, r25
    3d34:	28 1b       	sub	r18, r24
    3d36:	82 2f       	mov	r24, r18
    3d38:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    3d3a:	0f 90       	pop	r0
    3d3c:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    3d3e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3d40:	0f 90       	pop	r0
    3d42:	0f 90       	pop	r0
    3d44:	0f 90       	pop	r0
    3d46:	0f 90       	pop	r0
    3d48:	0f 90       	pop	r0
    3d4a:	cf 91       	pop	r28
    3d4c:	df 91       	pop	r29
    3d4e:	08 95       	ret

00003d50 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3d50:	df 93       	push	r29
    3d52:	cf 93       	push	r28
    3d54:	00 d0       	rcall	.+0      	; 0x3d56 <uxQueueMessagesWaitingFromISR+0x6>
    3d56:	00 d0       	rcall	.+0      	; 0x3d58 <uxQueueMessagesWaitingFromISR+0x8>
    3d58:	0f 92       	push	r0
    3d5a:	cd b7       	in	r28, 0x3d	; 61
    3d5c:	de b7       	in	r29, 0x3e	; 62
    3d5e:	9d 83       	std	Y+5, r25	; 0x05
    3d60:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    3d62:	8c 81       	ldd	r24, Y+4	; 0x04
    3d64:	9d 81       	ldd	r25, Y+5	; 0x05
    3d66:	9a 83       	std	Y+2, r25	; 0x02
    3d68:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    3d6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d70:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    3d72:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3d74:	0f 90       	pop	r0
    3d76:	0f 90       	pop	r0
    3d78:	0f 90       	pop	r0
    3d7a:	0f 90       	pop	r0
    3d7c:	0f 90       	pop	r0
    3d7e:	cf 91       	pop	r28
    3d80:	df 91       	pop	r29
    3d82:	08 95       	ret

00003d84 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3d84:	df 93       	push	r29
    3d86:	cf 93       	push	r28
    3d88:	00 d0       	rcall	.+0      	; 0x3d8a <vQueueDelete+0x6>
    3d8a:	00 d0       	rcall	.+0      	; 0x3d8c <vQueueDelete+0x8>
    3d8c:	cd b7       	in	r28, 0x3d	; 61
    3d8e:	de b7       	in	r29, 0x3e	; 62
    3d90:	9c 83       	std	Y+4, r25	; 0x04
    3d92:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    3d94:	8b 81       	ldd	r24, Y+3	; 0x03
    3d96:	9c 81       	ldd	r25, Y+4	; 0x04
    3d98:	9a 83       	std	Y+2, r25	; 0x02
    3d9a:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    3d9c:	89 81       	ldd	r24, Y+1	; 0x01
    3d9e:	9a 81       	ldd	r25, Y+2	; 0x02
    3da0:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3da4:	0f 90       	pop	r0
    3da6:	0f 90       	pop	r0
    3da8:	0f 90       	pop	r0
    3daa:	0f 90       	pop	r0
    3dac:	cf 91       	pop	r28
    3dae:	df 91       	pop	r29
    3db0:	08 95       	ret

00003db2 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    3db2:	df 93       	push	r29
    3db4:	cf 93       	push	r28
    3db6:	cd b7       	in	r28, 0x3d	; 61
    3db8:	de b7       	in	r29, 0x3e	; 62
    3dba:	27 97       	sbiw	r28, 0x07	; 7
    3dbc:	0f b6       	in	r0, 0x3f	; 63
    3dbe:	f8 94       	cli
    3dc0:	de bf       	out	0x3e, r29	; 62
    3dc2:	0f be       	out	0x3f, r0	; 63
    3dc4:	cd bf       	out	0x3d, r28	; 61
    3dc6:	9c 83       	std	Y+4, r25	; 0x04
    3dc8:	8b 83       	std	Y+3, r24	; 0x03
    3dca:	7e 83       	std	Y+6, r23	; 0x06
    3dcc:	6d 83       	std	Y+5, r22	; 0x05
    3dce:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    3dd0:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3dd2:	eb 81       	ldd	r30, Y+3	; 0x03
    3dd4:	fc 81       	ldd	r31, Y+4	; 0x04
    3dd6:	82 8d       	ldd	r24, Z+26	; 0x1a
    3dd8:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3dda:	eb 81       	ldd	r30, Y+3	; 0x03
    3ddc:	fc 81       	ldd	r31, Y+4	; 0x04
    3dde:	84 8d       	ldd	r24, Z+28	; 0x1c
    3de0:	88 23       	and	r24, r24
    3de2:	09 f4       	brne	.+2      	; 0x3de6 <prvCopyDataToQueue+0x34>
    3de4:	7d c0       	rjmp	.+250    	; 0x3ee0 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    3de6:	8f 81       	ldd	r24, Y+7	; 0x07
    3de8:	88 23       	and	r24, r24
    3dea:	99 f5       	brne	.+102    	; 0x3e52 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3dec:	eb 81       	ldd	r30, Y+3	; 0x03
    3dee:	fc 81       	ldd	r31, Y+4	; 0x04
    3df0:	62 81       	ldd	r22, Z+2	; 0x02
    3df2:	73 81       	ldd	r23, Z+3	; 0x03
    3df4:	eb 81       	ldd	r30, Y+3	; 0x03
    3df6:	fc 81       	ldd	r31, Y+4	; 0x04
    3df8:	84 8d       	ldd	r24, Z+28	; 0x1c
    3dfa:	48 2f       	mov	r20, r24
    3dfc:	50 e0       	ldi	r21, 0x00	; 0
    3dfe:	2d 81       	ldd	r18, Y+5	; 0x05
    3e00:	3e 81       	ldd	r19, Y+6	; 0x06
    3e02:	cb 01       	movw	r24, r22
    3e04:	b9 01       	movw	r22, r18
    3e06:	0e 94 16 3c 	call	0x782c	; 0x782c <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3e0a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e0c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e0e:	22 81       	ldd	r18, Z+2	; 0x02
    3e10:	33 81       	ldd	r19, Z+3	; 0x03
    3e12:	eb 81       	ldd	r30, Y+3	; 0x03
    3e14:	fc 81       	ldd	r31, Y+4	; 0x04
    3e16:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e18:	88 2f       	mov	r24, r24
    3e1a:	90 e0       	ldi	r25, 0x00	; 0
    3e1c:	82 0f       	add	r24, r18
    3e1e:	93 1f       	adc	r25, r19
    3e20:	eb 81       	ldd	r30, Y+3	; 0x03
    3e22:	fc 81       	ldd	r31, Y+4	; 0x04
    3e24:	93 83       	std	Z+3, r25	; 0x03
    3e26:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3e28:	eb 81       	ldd	r30, Y+3	; 0x03
    3e2a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e2c:	22 81       	ldd	r18, Z+2	; 0x02
    3e2e:	33 81       	ldd	r19, Z+3	; 0x03
    3e30:	eb 81       	ldd	r30, Y+3	; 0x03
    3e32:	fc 81       	ldd	r31, Y+4	; 0x04
    3e34:	84 81       	ldd	r24, Z+4	; 0x04
    3e36:	95 81       	ldd	r25, Z+5	; 0x05
    3e38:	28 17       	cp	r18, r24
    3e3a:	39 07       	cpc	r19, r25
    3e3c:	08 f4       	brcc	.+2      	; 0x3e40 <prvCopyDataToQueue+0x8e>
    3e3e:	50 c0       	rjmp	.+160    	; 0x3ee0 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    3e40:	eb 81       	ldd	r30, Y+3	; 0x03
    3e42:	fc 81       	ldd	r31, Y+4	; 0x04
    3e44:	80 81       	ld	r24, Z
    3e46:	91 81       	ldd	r25, Z+1	; 0x01
    3e48:	eb 81       	ldd	r30, Y+3	; 0x03
    3e4a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e4c:	93 83       	std	Z+3, r25	; 0x03
    3e4e:	82 83       	std	Z+2, r24	; 0x02
    3e50:	47 c0       	rjmp	.+142    	; 0x3ee0 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3e52:	eb 81       	ldd	r30, Y+3	; 0x03
    3e54:	fc 81       	ldd	r31, Y+4	; 0x04
    3e56:	66 81       	ldd	r22, Z+6	; 0x06
    3e58:	77 81       	ldd	r23, Z+7	; 0x07
    3e5a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e5c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e5e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e60:	48 2f       	mov	r20, r24
    3e62:	50 e0       	ldi	r21, 0x00	; 0
    3e64:	2d 81       	ldd	r18, Y+5	; 0x05
    3e66:	3e 81       	ldd	r19, Y+6	; 0x06
    3e68:	cb 01       	movw	r24, r22
    3e6a:	b9 01       	movw	r22, r18
    3e6c:	0e 94 16 3c 	call	0x782c	; 0x782c <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3e70:	eb 81       	ldd	r30, Y+3	; 0x03
    3e72:	fc 81       	ldd	r31, Y+4	; 0x04
    3e74:	26 81       	ldd	r18, Z+6	; 0x06
    3e76:	37 81       	ldd	r19, Z+7	; 0x07
    3e78:	eb 81       	ldd	r30, Y+3	; 0x03
    3e7a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e7c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e7e:	88 2f       	mov	r24, r24
    3e80:	90 e0       	ldi	r25, 0x00	; 0
    3e82:	90 95       	com	r25
    3e84:	81 95       	neg	r24
    3e86:	9f 4f       	sbci	r25, 0xFF	; 255
    3e88:	82 0f       	add	r24, r18
    3e8a:	93 1f       	adc	r25, r19
    3e8c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e8e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e90:	97 83       	std	Z+7, r25	; 0x07
    3e92:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3e94:	eb 81       	ldd	r30, Y+3	; 0x03
    3e96:	fc 81       	ldd	r31, Y+4	; 0x04
    3e98:	26 81       	ldd	r18, Z+6	; 0x06
    3e9a:	37 81       	ldd	r19, Z+7	; 0x07
    3e9c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e9e:	fc 81       	ldd	r31, Y+4	; 0x04
    3ea0:	80 81       	ld	r24, Z
    3ea2:	91 81       	ldd	r25, Z+1	; 0x01
    3ea4:	28 17       	cp	r18, r24
    3ea6:	39 07       	cpc	r19, r25
    3ea8:	90 f4       	brcc	.+36     	; 0x3ece <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3eaa:	eb 81       	ldd	r30, Y+3	; 0x03
    3eac:	fc 81       	ldd	r31, Y+4	; 0x04
    3eae:	24 81       	ldd	r18, Z+4	; 0x04
    3eb0:	35 81       	ldd	r19, Z+5	; 0x05
    3eb2:	eb 81       	ldd	r30, Y+3	; 0x03
    3eb4:	fc 81       	ldd	r31, Y+4	; 0x04
    3eb6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3eb8:	88 2f       	mov	r24, r24
    3eba:	90 e0       	ldi	r25, 0x00	; 0
    3ebc:	90 95       	com	r25
    3ebe:	81 95       	neg	r24
    3ec0:	9f 4f       	sbci	r25, 0xFF	; 255
    3ec2:	82 0f       	add	r24, r18
    3ec4:	93 1f       	adc	r25, r19
    3ec6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ec8:	fc 81       	ldd	r31, Y+4	; 0x04
    3eca:	97 83       	std	Z+7, r25	; 0x07
    3ecc:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    3ece:	8f 81       	ldd	r24, Y+7	; 0x07
    3ed0:	82 30       	cpi	r24, 0x02	; 2
    3ed2:	31 f4       	brne	.+12     	; 0x3ee0 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3ed4:	89 81       	ldd	r24, Y+1	; 0x01
    3ed6:	88 23       	and	r24, r24
    3ed8:	19 f0       	breq	.+6      	; 0x3ee0 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    3eda:	89 81       	ldd	r24, Y+1	; 0x01
    3edc:	81 50       	subi	r24, 0x01	; 1
    3ede:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3ee0:	89 81       	ldd	r24, Y+1	; 0x01
    3ee2:	8f 5f       	subi	r24, 0xFF	; 255
    3ee4:	eb 81       	ldd	r30, Y+3	; 0x03
    3ee6:	fc 81       	ldd	r31, Y+4	; 0x04
    3ee8:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    3eea:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3eec:	27 96       	adiw	r28, 0x07	; 7
    3eee:	0f b6       	in	r0, 0x3f	; 63
    3ef0:	f8 94       	cli
    3ef2:	de bf       	out	0x3e, r29	; 62
    3ef4:	0f be       	out	0x3f, r0	; 63
    3ef6:	cd bf       	out	0x3d, r28	; 61
    3ef8:	cf 91       	pop	r28
    3efa:	df 91       	pop	r29
    3efc:	08 95       	ret

00003efe <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    3efe:	df 93       	push	r29
    3f00:	cf 93       	push	r28
    3f02:	00 d0       	rcall	.+0      	; 0x3f04 <prvCopyDataFromQueue+0x6>
    3f04:	00 d0       	rcall	.+0      	; 0x3f06 <prvCopyDataFromQueue+0x8>
    3f06:	cd b7       	in	r28, 0x3d	; 61
    3f08:	de b7       	in	r29, 0x3e	; 62
    3f0a:	9a 83       	std	Y+2, r25	; 0x02
    3f0c:	89 83       	std	Y+1, r24	; 0x01
    3f0e:	7c 83       	std	Y+4, r23	; 0x04
    3f10:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3f12:	e9 81       	ldd	r30, Y+1	; 0x01
    3f14:	fa 81       	ldd	r31, Y+2	; 0x02
    3f16:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f18:	88 23       	and	r24, r24
    3f1a:	89 f1       	breq	.+98     	; 0x3f7e <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3f1c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f1e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f20:	26 81       	ldd	r18, Z+6	; 0x06
    3f22:	37 81       	ldd	r19, Z+7	; 0x07
    3f24:	e9 81       	ldd	r30, Y+1	; 0x01
    3f26:	fa 81       	ldd	r31, Y+2	; 0x02
    3f28:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f2a:	88 2f       	mov	r24, r24
    3f2c:	90 e0       	ldi	r25, 0x00	; 0
    3f2e:	82 0f       	add	r24, r18
    3f30:	93 1f       	adc	r25, r19
    3f32:	e9 81       	ldd	r30, Y+1	; 0x01
    3f34:	fa 81       	ldd	r31, Y+2	; 0x02
    3f36:	97 83       	std	Z+7, r25	; 0x07
    3f38:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3f3a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f3c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f3e:	26 81       	ldd	r18, Z+6	; 0x06
    3f40:	37 81       	ldd	r19, Z+7	; 0x07
    3f42:	e9 81       	ldd	r30, Y+1	; 0x01
    3f44:	fa 81       	ldd	r31, Y+2	; 0x02
    3f46:	84 81       	ldd	r24, Z+4	; 0x04
    3f48:	95 81       	ldd	r25, Z+5	; 0x05
    3f4a:	28 17       	cp	r18, r24
    3f4c:	39 07       	cpc	r19, r25
    3f4e:	40 f0       	brcs	.+16     	; 0x3f60 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3f50:	e9 81       	ldd	r30, Y+1	; 0x01
    3f52:	fa 81       	ldd	r31, Y+2	; 0x02
    3f54:	80 81       	ld	r24, Z
    3f56:	91 81       	ldd	r25, Z+1	; 0x01
    3f58:	e9 81       	ldd	r30, Y+1	; 0x01
    3f5a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f5c:	97 83       	std	Z+7, r25	; 0x07
    3f5e:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3f60:	e9 81       	ldd	r30, Y+1	; 0x01
    3f62:	fa 81       	ldd	r31, Y+2	; 0x02
    3f64:	46 81       	ldd	r20, Z+6	; 0x06
    3f66:	57 81       	ldd	r21, Z+7	; 0x07
    3f68:	e9 81       	ldd	r30, Y+1	; 0x01
    3f6a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f6c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f6e:	28 2f       	mov	r18, r24
    3f70:	30 e0       	ldi	r19, 0x00	; 0
    3f72:	8b 81       	ldd	r24, Y+3	; 0x03
    3f74:	9c 81       	ldd	r25, Y+4	; 0x04
    3f76:	ba 01       	movw	r22, r20
    3f78:	a9 01       	movw	r20, r18
    3f7a:	0e 94 16 3c 	call	0x782c	; 0x782c <memcpy>
    }
}
    3f7e:	0f 90       	pop	r0
    3f80:	0f 90       	pop	r0
    3f82:	0f 90       	pop	r0
    3f84:	0f 90       	pop	r0
    3f86:	cf 91       	pop	r28
    3f88:	df 91       	pop	r29
    3f8a:	08 95       	ret

00003f8c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3f8c:	df 93       	push	r29
    3f8e:	cf 93       	push	r28
    3f90:	00 d0       	rcall	.+0      	; 0x3f92 <prvUnlockQueue+0x6>
    3f92:	00 d0       	rcall	.+0      	; 0x3f94 <prvUnlockQueue+0x8>
    3f94:	cd b7       	in	r28, 0x3d	; 61
    3f96:	de b7       	in	r29, 0x3e	; 62
    3f98:	9c 83       	std	Y+4, r25	; 0x04
    3f9a:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    3f9c:	0f b6       	in	r0, 0x3f	; 63
    3f9e:	f8 94       	cli
    3fa0:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    3fa2:	eb 81       	ldd	r30, Y+3	; 0x03
    3fa4:	fc 81       	ldd	r31, Y+4	; 0x04
    3fa6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3fa8:	8a 83       	std	Y+2, r24	; 0x02
    3faa:	11 c0       	rjmp	.+34     	; 0x3fce <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3fac:	eb 81       	ldd	r30, Y+3	; 0x03
    3fae:	fc 81       	ldd	r31, Y+4	; 0x04
    3fb0:	81 89       	ldd	r24, Z+17	; 0x11
    3fb2:	88 23       	and	r24, r24
    3fb4:	79 f0       	breq	.+30     	; 0x3fd4 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3fb6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fb8:	9c 81       	ldd	r25, Y+4	; 0x04
    3fba:	41 96       	adiw	r24, 0x11	; 17
    3fbc:	0e 94 96 2a 	call	0x552c	; 0x552c <xTaskRemoveFromEventList>
    3fc0:	88 23       	and	r24, r24
    3fc2:	11 f0       	breq	.+4      	; 0x3fc8 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    3fc4:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    3fc8:	8a 81       	ldd	r24, Y+2	; 0x02
    3fca:	81 50       	subi	r24, 0x01	; 1
    3fcc:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    3fce:	8a 81       	ldd	r24, Y+2	; 0x02
    3fd0:	18 16       	cp	r1, r24
    3fd2:	64 f3       	brlt	.-40     	; 0x3fac <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    3fd4:	eb 81       	ldd	r30, Y+3	; 0x03
    3fd6:	fc 81       	ldd	r31, Y+4	; 0x04
    3fd8:	8f ef       	ldi	r24, 0xFF	; 255
    3fda:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    3fdc:	0f 90       	pop	r0
    3fde:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    3fe0:	0f b6       	in	r0, 0x3f	; 63
    3fe2:	f8 94       	cli
    3fe4:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    3fe6:	eb 81       	ldd	r30, Y+3	; 0x03
    3fe8:	fc 81       	ldd	r31, Y+4	; 0x04
    3fea:	85 8d       	ldd	r24, Z+29	; 0x1d
    3fec:	89 83       	std	Y+1, r24	; 0x01
    3fee:	11 c0       	rjmp	.+34     	; 0x4012 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ff4:	80 85       	ldd	r24, Z+8	; 0x08
    3ff6:	88 23       	and	r24, r24
    3ff8:	79 f0       	breq	.+30     	; 0x4018 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3ffa:	8b 81       	ldd	r24, Y+3	; 0x03
    3ffc:	9c 81       	ldd	r25, Y+4	; 0x04
    3ffe:	08 96       	adiw	r24, 0x08	; 8
    4000:	0e 94 96 2a 	call	0x552c	; 0x552c <xTaskRemoveFromEventList>
    4004:	88 23       	and	r24, r24
    4006:	11 f0       	breq	.+4      	; 0x400c <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    4008:	0e 94 86 2d 	call	0x5b0c	; 0x5b0c <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    400c:	89 81       	ldd	r24, Y+1	; 0x01
    400e:	81 50       	subi	r24, 0x01	; 1
    4010:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    4012:	89 81       	ldd	r24, Y+1	; 0x01
    4014:	18 16       	cp	r1, r24
    4016:	64 f3       	brlt	.-40     	; 0x3ff0 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    4018:	eb 81       	ldd	r30, Y+3	; 0x03
    401a:	fc 81       	ldd	r31, Y+4	; 0x04
    401c:	8f ef       	ldi	r24, 0xFF	; 255
    401e:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    4020:	0f 90       	pop	r0
    4022:	0f be       	out	0x3f, r0	; 63
}
    4024:	0f 90       	pop	r0
    4026:	0f 90       	pop	r0
    4028:	0f 90       	pop	r0
    402a:	0f 90       	pop	r0
    402c:	cf 91       	pop	r28
    402e:	df 91       	pop	r29
    4030:	08 95       	ret

00004032 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    4032:	df 93       	push	r29
    4034:	cf 93       	push	r28
    4036:	00 d0       	rcall	.+0      	; 0x4038 <prvIsQueueEmpty+0x6>
    4038:	0f 92       	push	r0
    403a:	cd b7       	in	r28, 0x3d	; 61
    403c:	de b7       	in	r29, 0x3e	; 62
    403e:	9b 83       	std	Y+3, r25	; 0x03
    4040:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    4042:	0f b6       	in	r0, 0x3f	; 63
    4044:	f8 94       	cli
    4046:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    4048:	ea 81       	ldd	r30, Y+2	; 0x02
    404a:	fb 81       	ldd	r31, Y+3	; 0x03
    404c:	82 8d       	ldd	r24, Z+26	; 0x1a
    404e:	88 23       	and	r24, r24
    4050:	19 f4       	brne	.+6      	; 0x4058 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    4052:	81 e0       	ldi	r24, 0x01	; 1
    4054:	89 83       	std	Y+1, r24	; 0x01
    4056:	01 c0       	rjmp	.+2      	; 0x405a <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    4058:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    405a:	0f 90       	pop	r0
    405c:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    405e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4060:	0f 90       	pop	r0
    4062:	0f 90       	pop	r0
    4064:	0f 90       	pop	r0
    4066:	cf 91       	pop	r28
    4068:	df 91       	pop	r29
    406a:	08 95       	ret

0000406c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    406c:	df 93       	push	r29
    406e:	cf 93       	push	r28
    4070:	00 d0       	rcall	.+0      	; 0x4072 <xQueueIsQueueEmptyFromISR+0x6>
    4072:	00 d0       	rcall	.+0      	; 0x4074 <xQueueIsQueueEmptyFromISR+0x8>
    4074:	0f 92       	push	r0
    4076:	cd b7       	in	r28, 0x3d	; 61
    4078:	de b7       	in	r29, 0x3e	; 62
    407a:	9d 83       	std	Y+5, r25	; 0x05
    407c:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    407e:	8c 81       	ldd	r24, Y+4	; 0x04
    4080:	9d 81       	ldd	r25, Y+5	; 0x05
    4082:	9a 83       	std	Y+2, r25	; 0x02
    4084:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    4086:	e9 81       	ldd	r30, Y+1	; 0x01
    4088:	fa 81       	ldd	r31, Y+2	; 0x02
    408a:	82 8d       	ldd	r24, Z+26	; 0x1a
    408c:	88 23       	and	r24, r24
    408e:	19 f4       	brne	.+6      	; 0x4096 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    4090:	81 e0       	ldi	r24, 0x01	; 1
    4092:	8b 83       	std	Y+3, r24	; 0x03
    4094:	01 c0       	rjmp	.+2      	; 0x4098 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    4096:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    4098:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    409a:	0f 90       	pop	r0
    409c:	0f 90       	pop	r0
    409e:	0f 90       	pop	r0
    40a0:	0f 90       	pop	r0
    40a2:	0f 90       	pop	r0
    40a4:	cf 91       	pop	r28
    40a6:	df 91       	pop	r29
    40a8:	08 95       	ret

000040aa <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    40aa:	df 93       	push	r29
    40ac:	cf 93       	push	r28
    40ae:	00 d0       	rcall	.+0      	; 0x40b0 <prvIsQueueFull+0x6>
    40b0:	0f 92       	push	r0
    40b2:	cd b7       	in	r28, 0x3d	; 61
    40b4:	de b7       	in	r29, 0x3e	; 62
    40b6:	9b 83       	std	Y+3, r25	; 0x03
    40b8:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    40ba:	0f b6       	in	r0, 0x3f	; 63
    40bc:	f8 94       	cli
    40be:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    40c0:	ea 81       	ldd	r30, Y+2	; 0x02
    40c2:	fb 81       	ldd	r31, Y+3	; 0x03
    40c4:	92 8d       	ldd	r25, Z+26	; 0x1a
    40c6:	ea 81       	ldd	r30, Y+2	; 0x02
    40c8:	fb 81       	ldd	r31, Y+3	; 0x03
    40ca:	83 8d       	ldd	r24, Z+27	; 0x1b
    40cc:	98 17       	cp	r25, r24
    40ce:	19 f4       	brne	.+6      	; 0x40d6 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    40d0:	81 e0       	ldi	r24, 0x01	; 1
    40d2:	89 83       	std	Y+1, r24	; 0x01
    40d4:	01 c0       	rjmp	.+2      	; 0x40d8 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    40d6:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    40d8:	0f 90       	pop	r0
    40da:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    40dc:	89 81       	ldd	r24, Y+1	; 0x01
}
    40de:	0f 90       	pop	r0
    40e0:	0f 90       	pop	r0
    40e2:	0f 90       	pop	r0
    40e4:	cf 91       	pop	r28
    40e6:	df 91       	pop	r29
    40e8:	08 95       	ret

000040ea <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    40ea:	df 93       	push	r29
    40ec:	cf 93       	push	r28
    40ee:	00 d0       	rcall	.+0      	; 0x40f0 <xQueueIsQueueFullFromISR+0x6>
    40f0:	00 d0       	rcall	.+0      	; 0x40f2 <xQueueIsQueueFullFromISR+0x8>
    40f2:	0f 92       	push	r0
    40f4:	cd b7       	in	r28, 0x3d	; 61
    40f6:	de b7       	in	r29, 0x3e	; 62
    40f8:	9d 83       	std	Y+5, r25	; 0x05
    40fa:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    40fc:	8c 81       	ldd	r24, Y+4	; 0x04
    40fe:	9d 81       	ldd	r25, Y+5	; 0x05
    4100:	9a 83       	std	Y+2, r25	; 0x02
    4102:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4104:	e9 81       	ldd	r30, Y+1	; 0x01
    4106:	fa 81       	ldd	r31, Y+2	; 0x02
    4108:	92 8d       	ldd	r25, Z+26	; 0x1a
    410a:	e9 81       	ldd	r30, Y+1	; 0x01
    410c:	fa 81       	ldd	r31, Y+2	; 0x02
    410e:	83 8d       	ldd	r24, Z+27	; 0x1b
    4110:	98 17       	cp	r25, r24
    4112:	19 f4       	brne	.+6      	; 0x411a <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    4114:	81 e0       	ldi	r24, 0x01	; 1
    4116:	8b 83       	std	Y+3, r24	; 0x03
    4118:	01 c0       	rjmp	.+2      	; 0x411c <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    411a:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    411c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    411e:	0f 90       	pop	r0
    4120:	0f 90       	pop	r0
    4122:	0f 90       	pop	r0
    4124:	0f 90       	pop	r0
    4126:	0f 90       	pop	r0
    4128:	cf 91       	pop	r28
    412a:	df 91       	pop	r29
    412c:	08 95       	ret

0000412e <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    412e:	df 93       	push	r29
    4130:	cf 93       	push	r28
    4132:	cd b7       	in	r28, 0x3d	; 61
    4134:	de b7       	in	r29, 0x3e	; 62
    4136:	2a 97       	sbiw	r28, 0x0a	; 10
    4138:	0f b6       	in	r0, 0x3f	; 63
    413a:	f8 94       	cli
    413c:	de bf       	out	0x3e, r29	; 62
    413e:	0f be       	out	0x3f, r0	; 63
    4140:	cd bf       	out	0x3d, r28	; 61
    4142:	9d 83       	std	Y+5, r25	; 0x05
    4144:	8c 83       	std	Y+4, r24	; 0x04
    4146:	7f 83       	std	Y+7, r23	; 0x07
    4148:	6e 83       	std	Y+6, r22	; 0x06
    414a:	59 87       	std	Y+9, r21	; 0x09
    414c:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    414e:	8c 81       	ldd	r24, Y+4	; 0x04
    4150:	9d 81       	ldd	r25, Y+5	; 0x05
    4152:	9a 83       	std	Y+2, r25	; 0x02
    4154:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    4156:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    4158:	89 81       	ldd	r24, Y+1	; 0x01
    415a:	9a 81       	ldd	r25, Y+2	; 0x02
    415c:	0e 94 55 20 	call	0x40aa	; 0x40aa <prvIsQueueFull>
    4160:	88 23       	and	r24, r24
    4162:	a9 f0       	breq	.+42     	; 0x418e <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    4164:	88 85       	ldd	r24, Y+8	; 0x08
    4166:	99 85       	ldd	r25, Y+9	; 0x09
    4168:	00 97       	sbiw	r24, 0x00	; 0
    416a:	71 f0       	breq	.+28     	; 0x4188 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    416c:	89 81       	ldd	r24, Y+1	; 0x01
    416e:	9a 81       	ldd	r25, Y+2	; 0x02
    4170:	9c 01       	movw	r18, r24
    4172:	28 5f       	subi	r18, 0xF8	; 248
    4174:	3f 4f       	sbci	r19, 0xFF	; 255
    4176:	88 85       	ldd	r24, Y+8	; 0x08
    4178:	99 85       	ldd	r25, Y+9	; 0x09
    417a:	b9 01       	movw	r22, r18
    417c:	0e 94 63 12 	call	0x24c6	; 0x24c6 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    4180:	78 94       	sei
                    return errQUEUE_BLOCKED;
    4182:	8c ef       	ldi	r24, 0xFC	; 252
    4184:	8a 87       	std	Y+10, r24	; 0x0a
    4186:	2a c0       	rjmp	.+84     	; 0x41dc <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    4188:	78 94       	sei
                    return errQUEUE_FULL;
    418a:	1a 86       	std	Y+10, r1	; 0x0a
    418c:	27 c0       	rjmp	.+78     	; 0x41dc <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    418e:	78 94       	sei

        portDISABLE_INTERRUPTS();
    4190:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4192:	e9 81       	ldd	r30, Y+1	; 0x01
    4194:	fa 81       	ldd	r31, Y+2	; 0x02
    4196:	92 8d       	ldd	r25, Z+26	; 0x1a
    4198:	e9 81       	ldd	r30, Y+1	; 0x01
    419a:	fa 81       	ldd	r31, Y+2	; 0x02
    419c:	83 8d       	ldd	r24, Z+27	; 0x1b
    419e:	98 17       	cp	r25, r24
    41a0:	c8 f4       	brcc	.+50     	; 0x41d4 <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    41a2:	89 81       	ldd	r24, Y+1	; 0x01
    41a4:	9a 81       	ldd	r25, Y+2	; 0x02
    41a6:	2e 81       	ldd	r18, Y+6	; 0x06
    41a8:	3f 81       	ldd	r19, Y+7	; 0x07
    41aa:	b9 01       	movw	r22, r18
    41ac:	40 e0       	ldi	r20, 0x00	; 0
    41ae:	0e 94 d9 1e 	call	0x3db2	; 0x3db2 <prvCopyDataToQueue>
                xReturn = pdPASS;
    41b2:	81 e0       	ldi	r24, 0x01	; 1
    41b4:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    41b6:	e9 81       	ldd	r30, Y+1	; 0x01
    41b8:	fa 81       	ldd	r31, Y+2	; 0x02
    41ba:	81 89       	ldd	r24, Z+17	; 0x11
    41bc:	88 23       	and	r24, r24
    41be:	59 f0       	breq	.+22     	; 0x41d6 <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    41c0:	89 81       	ldd	r24, Y+1	; 0x01
    41c2:	9a 81       	ldd	r25, Y+2	; 0x02
    41c4:	41 96       	adiw	r24, 0x11	; 17
    41c6:	0e 94 76 14 	call	0x28ec	; 0x28ec <xCoRoutineRemoveFromEventList>
    41ca:	88 23       	and	r24, r24
    41cc:	21 f0       	breq	.+8      	; 0x41d6 <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    41ce:	8b ef       	ldi	r24, 0xFB	; 251
    41d0:	8b 83       	std	Y+3, r24	; 0x03
    41d2:	01 c0       	rjmp	.+2      	; 0x41d6 <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    41d4:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    41d6:	78 94       	sei

        return xReturn;
    41d8:	8b 81       	ldd	r24, Y+3	; 0x03
    41da:	8a 87       	std	Y+10, r24	; 0x0a
    41dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    41de:	2a 96       	adiw	r28, 0x0a	; 10
    41e0:	0f b6       	in	r0, 0x3f	; 63
    41e2:	f8 94       	cli
    41e4:	de bf       	out	0x3e, r29	; 62
    41e6:	0f be       	out	0x3f, r0	; 63
    41e8:	cd bf       	out	0x3d, r28	; 61
    41ea:	cf 91       	pop	r28
    41ec:	df 91       	pop	r29
    41ee:	08 95       	ret

000041f0 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    41f0:	df 93       	push	r29
    41f2:	cf 93       	push	r28
    41f4:	cd b7       	in	r28, 0x3d	; 61
    41f6:	de b7       	in	r29, 0x3e	; 62
    41f8:	2a 97       	sbiw	r28, 0x0a	; 10
    41fa:	0f b6       	in	r0, 0x3f	; 63
    41fc:	f8 94       	cli
    41fe:	de bf       	out	0x3e, r29	; 62
    4200:	0f be       	out	0x3f, r0	; 63
    4202:	cd bf       	out	0x3d, r28	; 61
    4204:	9d 83       	std	Y+5, r25	; 0x05
    4206:	8c 83       	std	Y+4, r24	; 0x04
    4208:	7f 83       	std	Y+7, r23	; 0x07
    420a:	6e 83       	std	Y+6, r22	; 0x06
    420c:	59 87       	std	Y+9, r21	; 0x09
    420e:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    4210:	8c 81       	ldd	r24, Y+4	; 0x04
    4212:	9d 81       	ldd	r25, Y+5	; 0x05
    4214:	9a 83       	std	Y+2, r25	; 0x02
    4216:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    4218:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    421a:	e9 81       	ldd	r30, Y+1	; 0x01
    421c:	fa 81       	ldd	r31, Y+2	; 0x02
    421e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4220:	88 23       	and	r24, r24
    4222:	a9 f4       	brne	.+42     	; 0x424e <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    4224:	88 85       	ldd	r24, Y+8	; 0x08
    4226:	99 85       	ldd	r25, Y+9	; 0x09
    4228:	00 97       	sbiw	r24, 0x00	; 0
    422a:	71 f0       	breq	.+28     	; 0x4248 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    422c:	89 81       	ldd	r24, Y+1	; 0x01
    422e:	9a 81       	ldd	r25, Y+2	; 0x02
    4230:	9c 01       	movw	r18, r24
    4232:	2f 5e       	subi	r18, 0xEF	; 239
    4234:	3f 4f       	sbci	r19, 0xFF	; 255
    4236:	88 85       	ldd	r24, Y+8	; 0x08
    4238:	99 85       	ldd	r25, Y+9	; 0x09
    423a:	b9 01       	movw	r22, r18
    423c:	0e 94 63 12 	call	0x24c6	; 0x24c6 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    4240:	78 94       	sei
                    return errQUEUE_BLOCKED;
    4242:	8c ef       	ldi	r24, 0xFC	; 252
    4244:	8a 87       	std	Y+10, r24	; 0x0a
    4246:	58 c0       	rjmp	.+176    	; 0x42f8 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    4248:	78 94       	sei
                    return errQUEUE_FULL;
    424a:	1a 86       	std	Y+10, r1	; 0x0a
    424c:	55 c0       	rjmp	.+170    	; 0x42f8 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    424e:	78 94       	sei

        portDISABLE_INTERRUPTS();
    4250:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4252:	e9 81       	ldd	r30, Y+1	; 0x01
    4254:	fa 81       	ldd	r31, Y+2	; 0x02
    4256:	82 8d       	ldd	r24, Z+26	; 0x1a
    4258:	88 23       	and	r24, r24
    425a:	09 f4       	brne	.+2      	; 0x425e <xQueueCRReceive+0x6e>
    425c:	49 c0       	rjmp	.+146    	; 0x42f0 <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    425e:	e9 81       	ldd	r30, Y+1	; 0x01
    4260:	fa 81       	ldd	r31, Y+2	; 0x02
    4262:	26 81       	ldd	r18, Z+6	; 0x06
    4264:	37 81       	ldd	r19, Z+7	; 0x07
    4266:	e9 81       	ldd	r30, Y+1	; 0x01
    4268:	fa 81       	ldd	r31, Y+2	; 0x02
    426a:	84 8d       	ldd	r24, Z+28	; 0x1c
    426c:	88 2f       	mov	r24, r24
    426e:	90 e0       	ldi	r25, 0x00	; 0
    4270:	82 0f       	add	r24, r18
    4272:	93 1f       	adc	r25, r19
    4274:	e9 81       	ldd	r30, Y+1	; 0x01
    4276:	fa 81       	ldd	r31, Y+2	; 0x02
    4278:	97 83       	std	Z+7, r25	; 0x07
    427a:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    427c:	e9 81       	ldd	r30, Y+1	; 0x01
    427e:	fa 81       	ldd	r31, Y+2	; 0x02
    4280:	26 81       	ldd	r18, Z+6	; 0x06
    4282:	37 81       	ldd	r19, Z+7	; 0x07
    4284:	e9 81       	ldd	r30, Y+1	; 0x01
    4286:	fa 81       	ldd	r31, Y+2	; 0x02
    4288:	84 81       	ldd	r24, Z+4	; 0x04
    428a:	95 81       	ldd	r25, Z+5	; 0x05
    428c:	28 17       	cp	r18, r24
    428e:	39 07       	cpc	r19, r25
    4290:	40 f0       	brcs	.+16     	; 0x42a2 <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    4292:	e9 81       	ldd	r30, Y+1	; 0x01
    4294:	fa 81       	ldd	r31, Y+2	; 0x02
    4296:	80 81       	ld	r24, Z
    4298:	91 81       	ldd	r25, Z+1	; 0x01
    429a:	e9 81       	ldd	r30, Y+1	; 0x01
    429c:	fa 81       	ldd	r31, Y+2	; 0x02
    429e:	97 83       	std	Z+7, r25	; 0x07
    42a0:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    42a2:	e9 81       	ldd	r30, Y+1	; 0x01
    42a4:	fa 81       	ldd	r31, Y+2	; 0x02
    42a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    42a8:	81 50       	subi	r24, 0x01	; 1
    42aa:	e9 81       	ldd	r30, Y+1	; 0x01
    42ac:	fa 81       	ldd	r31, Y+2	; 0x02
    42ae:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    42b0:	e9 81       	ldd	r30, Y+1	; 0x01
    42b2:	fa 81       	ldd	r31, Y+2	; 0x02
    42b4:	46 81       	ldd	r20, Z+6	; 0x06
    42b6:	57 81       	ldd	r21, Z+7	; 0x07
    42b8:	e9 81       	ldd	r30, Y+1	; 0x01
    42ba:	fa 81       	ldd	r31, Y+2	; 0x02
    42bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    42be:	28 2f       	mov	r18, r24
    42c0:	30 e0       	ldi	r19, 0x00	; 0
    42c2:	8e 81       	ldd	r24, Y+6	; 0x06
    42c4:	9f 81       	ldd	r25, Y+7	; 0x07
    42c6:	ba 01       	movw	r22, r20
    42c8:	a9 01       	movw	r20, r18
    42ca:	0e 94 16 3c 	call	0x782c	; 0x782c <memcpy>

                xReturn = pdPASS;
    42ce:	81 e0       	ldi	r24, 0x01	; 1
    42d0:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    42d2:	e9 81       	ldd	r30, Y+1	; 0x01
    42d4:	fa 81       	ldd	r31, Y+2	; 0x02
    42d6:	80 85       	ldd	r24, Z+8	; 0x08
    42d8:	88 23       	and	r24, r24
    42da:	59 f0       	breq	.+22     	; 0x42f2 <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    42dc:	89 81       	ldd	r24, Y+1	; 0x01
    42de:	9a 81       	ldd	r25, Y+2	; 0x02
    42e0:	08 96       	adiw	r24, 0x08	; 8
    42e2:	0e 94 76 14 	call	0x28ec	; 0x28ec <xCoRoutineRemoveFromEventList>
    42e6:	88 23       	and	r24, r24
    42e8:	21 f0       	breq	.+8      	; 0x42f2 <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    42ea:	8b ef       	ldi	r24, 0xFB	; 251
    42ec:	8b 83       	std	Y+3, r24	; 0x03
    42ee:	01 c0       	rjmp	.+2      	; 0x42f2 <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    42f0:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    42f2:	78 94       	sei

        return xReturn;
    42f4:	8b 81       	ldd	r24, Y+3	; 0x03
    42f6:	8a 87       	std	Y+10, r24	; 0x0a
    42f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    42fa:	2a 96       	adiw	r28, 0x0a	; 10
    42fc:	0f b6       	in	r0, 0x3f	; 63
    42fe:	f8 94       	cli
    4300:	de bf       	out	0x3e, r29	; 62
    4302:	0f be       	out	0x3f, r0	; 63
    4304:	cd bf       	out	0x3d, r28	; 61
    4306:	cf 91       	pop	r28
    4308:	df 91       	pop	r29
    430a:	08 95       	ret

0000430c <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    430c:	df 93       	push	r29
    430e:	cf 93       	push	r28
    4310:	cd b7       	in	r28, 0x3d	; 61
    4312:	de b7       	in	r29, 0x3e	; 62
    4314:	28 97       	sbiw	r28, 0x08	; 8
    4316:	0f b6       	in	r0, 0x3f	; 63
    4318:	f8 94       	cli
    431a:	de bf       	out	0x3e, r29	; 62
    431c:	0f be       	out	0x3f, r0	; 63
    431e:	cd bf       	out	0x3d, r28	; 61
    4320:	9c 83       	std	Y+4, r25	; 0x04
    4322:	8b 83       	std	Y+3, r24	; 0x03
    4324:	7e 83       	std	Y+6, r23	; 0x06
    4326:	6d 83       	std	Y+5, r22	; 0x05
    4328:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    432a:	8b 81       	ldd	r24, Y+3	; 0x03
    432c:	9c 81       	ldd	r25, Y+4	; 0x04
    432e:	9a 83       	std	Y+2, r25	; 0x02
    4330:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4332:	e9 81       	ldd	r30, Y+1	; 0x01
    4334:	fa 81       	ldd	r31, Y+2	; 0x02
    4336:	92 8d       	ldd	r25, Z+26	; 0x1a
    4338:	e9 81       	ldd	r30, Y+1	; 0x01
    433a:	fa 81       	ldd	r31, Y+2	; 0x02
    433c:	83 8d       	ldd	r24, Z+27	; 0x1b
    433e:	98 17       	cp	r25, r24
    4340:	d0 f4       	brcc	.+52     	; 0x4376 <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    4342:	89 81       	ldd	r24, Y+1	; 0x01
    4344:	9a 81       	ldd	r25, Y+2	; 0x02
    4346:	2d 81       	ldd	r18, Y+5	; 0x05
    4348:	3e 81       	ldd	r19, Y+6	; 0x06
    434a:	b9 01       	movw	r22, r18
    434c:	40 e0       	ldi	r20, 0x00	; 0
    434e:	0e 94 d9 1e 	call	0x3db2	; 0x3db2 <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    4352:	8f 81       	ldd	r24, Y+7	; 0x07
    4354:	88 23       	and	r24, r24
    4356:	79 f4       	brne	.+30     	; 0x4376 <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4358:	e9 81       	ldd	r30, Y+1	; 0x01
    435a:	fa 81       	ldd	r31, Y+2	; 0x02
    435c:	81 89       	ldd	r24, Z+17	; 0x11
    435e:	88 23       	and	r24, r24
    4360:	51 f0       	breq	.+20     	; 0x4376 <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4362:	89 81       	ldd	r24, Y+1	; 0x01
    4364:	9a 81       	ldd	r25, Y+2	; 0x02
    4366:	41 96       	adiw	r24, 0x11	; 17
    4368:	0e 94 76 14 	call	0x28ec	; 0x28ec <xCoRoutineRemoveFromEventList>
    436c:	88 23       	and	r24, r24
    436e:	19 f0       	breq	.+6      	; 0x4376 <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    4370:	81 e0       	ldi	r24, 0x01	; 1
    4372:	88 87       	std	Y+8, r24	; 0x08
    4374:	02 c0       	rjmp	.+4      	; 0x437a <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    4376:	8f 81       	ldd	r24, Y+7	; 0x07
    4378:	88 87       	std	Y+8, r24	; 0x08
    437a:	88 85       	ldd	r24, Y+8	; 0x08
    }
    437c:	28 96       	adiw	r28, 0x08	; 8
    437e:	0f b6       	in	r0, 0x3f	; 63
    4380:	f8 94       	cli
    4382:	de bf       	out	0x3e, r29	; 62
    4384:	0f be       	out	0x3f, r0	; 63
    4386:	cd bf       	out	0x3d, r28	; 61
    4388:	cf 91       	pop	r28
    438a:	df 91       	pop	r29
    438c:	08 95       	ret

0000438e <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    438e:	df 93       	push	r29
    4390:	cf 93       	push	r28
    4392:	cd b7       	in	r28, 0x3d	; 61
    4394:	de b7       	in	r29, 0x3e	; 62
    4396:	29 97       	sbiw	r28, 0x09	; 9
    4398:	0f b6       	in	r0, 0x3f	; 63
    439a:	f8 94       	cli
    439c:	de bf       	out	0x3e, r29	; 62
    439e:	0f be       	out	0x3f, r0	; 63
    43a0:	cd bf       	out	0x3d, r28	; 61
    43a2:	9d 83       	std	Y+5, r25	; 0x05
    43a4:	8c 83       	std	Y+4, r24	; 0x04
    43a6:	7f 83       	std	Y+7, r23	; 0x07
    43a8:	6e 83       	std	Y+6, r22	; 0x06
    43aa:	59 87       	std	Y+9, r21	; 0x09
    43ac:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    43ae:	8c 81       	ldd	r24, Y+4	; 0x04
    43b0:	9d 81       	ldd	r25, Y+5	; 0x05
    43b2:	9a 83       	std	Y+2, r25	; 0x02
    43b4:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    43b6:	e9 81       	ldd	r30, Y+1	; 0x01
    43b8:	fa 81       	ldd	r31, Y+2	; 0x02
    43ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    43bc:	88 23       	and	r24, r24
    43be:	09 f4       	brne	.+2      	; 0x43c2 <xQueueCRReceiveFromISR+0x34>
    43c0:	50 c0       	rjmp	.+160    	; 0x4462 <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    43c2:	e9 81       	ldd	r30, Y+1	; 0x01
    43c4:	fa 81       	ldd	r31, Y+2	; 0x02
    43c6:	26 81       	ldd	r18, Z+6	; 0x06
    43c8:	37 81       	ldd	r19, Z+7	; 0x07
    43ca:	e9 81       	ldd	r30, Y+1	; 0x01
    43cc:	fa 81       	ldd	r31, Y+2	; 0x02
    43ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    43d0:	88 2f       	mov	r24, r24
    43d2:	90 e0       	ldi	r25, 0x00	; 0
    43d4:	82 0f       	add	r24, r18
    43d6:	93 1f       	adc	r25, r19
    43d8:	e9 81       	ldd	r30, Y+1	; 0x01
    43da:	fa 81       	ldd	r31, Y+2	; 0x02
    43dc:	97 83       	std	Z+7, r25	; 0x07
    43de:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    43e0:	e9 81       	ldd	r30, Y+1	; 0x01
    43e2:	fa 81       	ldd	r31, Y+2	; 0x02
    43e4:	26 81       	ldd	r18, Z+6	; 0x06
    43e6:	37 81       	ldd	r19, Z+7	; 0x07
    43e8:	e9 81       	ldd	r30, Y+1	; 0x01
    43ea:	fa 81       	ldd	r31, Y+2	; 0x02
    43ec:	84 81       	ldd	r24, Z+4	; 0x04
    43ee:	95 81       	ldd	r25, Z+5	; 0x05
    43f0:	28 17       	cp	r18, r24
    43f2:	39 07       	cpc	r19, r25
    43f4:	40 f0       	brcs	.+16     	; 0x4406 <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    43f6:	e9 81       	ldd	r30, Y+1	; 0x01
    43f8:	fa 81       	ldd	r31, Y+2	; 0x02
    43fa:	80 81       	ld	r24, Z
    43fc:	91 81       	ldd	r25, Z+1	; 0x01
    43fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4400:	fa 81       	ldd	r31, Y+2	; 0x02
    4402:	97 83       	std	Z+7, r25	; 0x07
    4404:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    4406:	e9 81       	ldd	r30, Y+1	; 0x01
    4408:	fa 81       	ldd	r31, Y+2	; 0x02
    440a:	82 8d       	ldd	r24, Z+26	; 0x1a
    440c:	81 50       	subi	r24, 0x01	; 1
    440e:	e9 81       	ldd	r30, Y+1	; 0x01
    4410:	fa 81       	ldd	r31, Y+2	; 0x02
    4412:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    4414:	e9 81       	ldd	r30, Y+1	; 0x01
    4416:	fa 81       	ldd	r31, Y+2	; 0x02
    4418:	46 81       	ldd	r20, Z+6	; 0x06
    441a:	57 81       	ldd	r21, Z+7	; 0x07
    441c:	e9 81       	ldd	r30, Y+1	; 0x01
    441e:	fa 81       	ldd	r31, Y+2	; 0x02
    4420:	84 8d       	ldd	r24, Z+28	; 0x1c
    4422:	28 2f       	mov	r18, r24
    4424:	30 e0       	ldi	r19, 0x00	; 0
    4426:	8e 81       	ldd	r24, Y+6	; 0x06
    4428:	9f 81       	ldd	r25, Y+7	; 0x07
    442a:	ba 01       	movw	r22, r20
    442c:	a9 01       	movw	r20, r18
    442e:	0e 94 16 3c 	call	0x782c	; 0x782c <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    4432:	e8 85       	ldd	r30, Y+8	; 0x08
    4434:	f9 85       	ldd	r31, Y+9	; 0x09
    4436:	80 81       	ld	r24, Z
    4438:	88 23       	and	r24, r24
    443a:	81 f4       	brne	.+32     	; 0x445c <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    443c:	e9 81       	ldd	r30, Y+1	; 0x01
    443e:	fa 81       	ldd	r31, Y+2	; 0x02
    4440:	80 85       	ldd	r24, Z+8	; 0x08
    4442:	88 23       	and	r24, r24
    4444:	59 f0       	breq	.+22     	; 0x445c <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4446:	89 81       	ldd	r24, Y+1	; 0x01
    4448:	9a 81       	ldd	r25, Y+2	; 0x02
    444a:	08 96       	adiw	r24, 0x08	; 8
    444c:	0e 94 76 14 	call	0x28ec	; 0x28ec <xCoRoutineRemoveFromEventList>
    4450:	88 23       	and	r24, r24
    4452:	21 f0       	breq	.+8      	; 0x445c <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    4454:	e8 85       	ldd	r30, Y+8	; 0x08
    4456:	f9 85       	ldd	r31, Y+9	; 0x09
    4458:	81 e0       	ldi	r24, 0x01	; 1
    445a:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    445c:	81 e0       	ldi	r24, 0x01	; 1
    445e:	8b 83       	std	Y+3, r24	; 0x03
    4460:	01 c0       	rjmp	.+2      	; 0x4464 <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    4462:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    4464:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    4466:	29 96       	adiw	r28, 0x09	; 9
    4468:	0f b6       	in	r0, 0x3f	; 63
    446a:	f8 94       	cli
    446c:	de bf       	out	0x3e, r29	; 62
    446e:	0f be       	out	0x3f, r0	; 63
    4470:	cd bf       	out	0x3d, r28	; 61
    4472:	cf 91       	pop	r28
    4474:	df 91       	pop	r29
    4476:	08 95       	ret

00004478 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    4478:	df 93       	push	r29
    447a:	cf 93       	push	r28
    447c:	cd b7       	in	r28, 0x3d	; 61
    447e:	de b7       	in	r29, 0x3e	; 62
    4480:	27 97       	sbiw	r28, 0x07	; 7
    4482:	0f b6       	in	r0, 0x3f	; 63
    4484:	f8 94       	cli
    4486:	de bf       	out	0x3e, r29	; 62
    4488:	0f be       	out	0x3f, r0	; 63
    448a:	cd bf       	out	0x3d, r28	; 61
    448c:	9c 83       	std	Y+4, r25	; 0x04
    448e:	8b 83       	std	Y+3, r24	; 0x03
    4490:	7e 83       	std	Y+6, r23	; 0x06
    4492:	6d 83       	std	Y+5, r22	; 0x05
    4494:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    4496:	8b 81       	ldd	r24, Y+3	; 0x03
    4498:	9c 81       	ldd	r25, Y+4	; 0x04
    449a:	9a 83       	std	Y+2, r25	; 0x02
    449c:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    449e:	0f b6       	in	r0, 0x3f	; 63
    44a0:	f8 94       	cli
    44a2:	0f 92       	push	r0
    44a4:	e9 81       	ldd	r30, Y+1	; 0x01
    44a6:	fa 81       	ldd	r31, Y+2	; 0x02
    44a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    44aa:	8f 3f       	cpi	r24, 0xFF	; 255
    44ac:	19 f4       	brne	.+6      	; 0x44b4 <vQueueWaitForMessageRestricted+0x3c>
    44ae:	e9 81       	ldd	r30, Y+1	; 0x01
    44b0:	fa 81       	ldd	r31, Y+2	; 0x02
    44b2:	15 8e       	std	Z+29, r1	; 0x1d
    44b4:	e9 81       	ldd	r30, Y+1	; 0x01
    44b6:	fa 81       	ldd	r31, Y+2	; 0x02
    44b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    44ba:	8f 3f       	cpi	r24, 0xFF	; 255
    44bc:	19 f4       	brne	.+6      	; 0x44c4 <vQueueWaitForMessageRestricted+0x4c>
    44be:	e9 81       	ldd	r30, Y+1	; 0x01
    44c0:	fa 81       	ldd	r31, Y+2	; 0x02
    44c2:	16 8e       	std	Z+30, r1	; 0x1e
    44c4:	0f 90       	pop	r0
    44c6:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    44c8:	e9 81       	ldd	r30, Y+1	; 0x01
    44ca:	fa 81       	ldd	r31, Y+2	; 0x02
    44cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    44ce:	88 23       	and	r24, r24
    44d0:	49 f4       	brne	.+18     	; 0x44e4 <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    44d2:	89 81       	ldd	r24, Y+1	; 0x01
    44d4:	9a 81       	ldd	r25, Y+2	; 0x02
    44d6:	41 96       	adiw	r24, 0x11	; 17
    44d8:	2d 81       	ldd	r18, Y+5	; 0x05
    44da:	3e 81       	ldd	r19, Y+6	; 0x06
    44dc:	b9 01       	movw	r22, r18
    44de:	4f 81       	ldd	r20, Y+7	; 0x07
    44e0:	0e 94 34 2a 	call	0x5468	; 0x5468 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    44e4:	89 81       	ldd	r24, Y+1	; 0x01
    44e6:	9a 81       	ldd	r25, Y+2	; 0x02
    44e8:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <prvUnlockQueue>
    }
    44ec:	27 96       	adiw	r28, 0x07	; 7
    44ee:	0f b6       	in	r0, 0x3f	; 63
    44f0:	f8 94       	cli
    44f2:	de bf       	out	0x3e, r29	; 62
    44f4:	0f be       	out	0x3f, r0	; 63
    44f6:	cd bf       	out	0x3d, r28	; 61
    44f8:	cf 91       	pop	r28
    44fa:	df 91       	pop	r29
    44fc:	08 95       	ret

000044fe <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    44fe:	8f 92       	push	r8
    4500:	9f 92       	push	r9
    4502:	af 92       	push	r10
    4504:	bf 92       	push	r11
    4506:	cf 92       	push	r12
    4508:	df 92       	push	r13
    450a:	ef 92       	push	r14
    450c:	ff 92       	push	r15
    450e:	0f 93       	push	r16
    4510:	1f 93       	push	r17
    4512:	df 93       	push	r29
    4514:	cf 93       	push	r28
    4516:	cd b7       	in	r28, 0x3d	; 61
    4518:	de b7       	in	r29, 0x3e	; 62
    451a:	60 97       	sbiw	r28, 0x10	; 16
    451c:	0f b6       	in	r0, 0x3f	; 63
    451e:	f8 94       	cli
    4520:	de bf       	out	0x3e, r29	; 62
    4522:	0f be       	out	0x3f, r0	; 63
    4524:	cd bf       	out	0x3d, r28	; 61
    4526:	9f 83       	std	Y+7, r25	; 0x07
    4528:	8e 83       	std	Y+6, r24	; 0x06
    452a:	79 87       	std	Y+9, r23	; 0x09
    452c:	68 87       	std	Y+8, r22	; 0x08
    452e:	5b 87       	std	Y+11, r21	; 0x0b
    4530:	4a 87       	std	Y+10, r20	; 0x0a
    4532:	3d 87       	std	Y+13, r19	; 0x0d
    4534:	2c 87       	std	Y+12, r18	; 0x0c
    4536:	0e 87       	std	Y+14, r16	; 0x0e
    4538:	f8 8a       	std	Y+16, r15	; 0x10
    453a:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    453c:	8a 85       	ldd	r24, Y+10	; 0x0a
    453e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4540:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <pvPortMalloc>
    4544:	9a 83       	std	Y+2, r25	; 0x02
    4546:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    4548:	89 81       	ldd	r24, Y+1	; 0x01
    454a:	9a 81       	ldd	r25, Y+2	; 0x02
    454c:	00 97       	sbiw	r24, 0x00	; 0
    454e:	b1 f0       	breq	.+44     	; 0x457c <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    4550:	86 e2       	ldi	r24, 0x26	; 38
    4552:	90 e0       	ldi	r25, 0x00	; 0
    4554:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <pvPortMalloc>
    4558:	9d 83       	std	Y+5, r25	; 0x05
    455a:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    455c:	8c 81       	ldd	r24, Y+4	; 0x04
    455e:	9d 81       	ldd	r25, Y+5	; 0x05
    4560:	00 97       	sbiw	r24, 0x00	; 0
    4562:	39 f0       	breq	.+14     	; 0x4572 <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    4564:	ec 81       	ldd	r30, Y+4	; 0x04
    4566:	fd 81       	ldd	r31, Y+5	; 0x05
    4568:	89 81       	ldd	r24, Y+1	; 0x01
    456a:	9a 81       	ldd	r25, Y+2	; 0x02
    456c:	90 8f       	std	Z+24, r25	; 0x18
    456e:	87 8b       	std	Z+23, r24	; 0x17
    4570:	07 c0       	rjmp	.+14     	; 0x4580 <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    4572:	89 81       	ldd	r24, Y+1	; 0x01
    4574:	9a 81       	ldd	r25, Y+2	; 0x02
    4576:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <vPortFree>
    457a:	02 c0       	rjmp	.+4      	; 0x4580 <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    457c:	1d 82       	std	Y+5, r1	; 0x05
    457e:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    4580:	8c 81       	ldd	r24, Y+4	; 0x04
    4582:	9d 81       	ldd	r25, Y+5	; 0x05
    4584:	00 97       	sbiw	r24, 0x00	; 0
    4586:	e9 f0       	breq	.+58     	; 0x45c2 <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    4588:	8a 85       	ldd	r24, Y+10	; 0x0a
    458a:	9b 85       	ldd	r25, Y+11	; 0x0b
    458c:	9c 01       	movw	r18, r24
    458e:	40 e0       	ldi	r20, 0x00	; 0
    4590:	50 e0       	ldi	r21, 0x00	; 0
    4592:	8e 81       	ldd	r24, Y+6	; 0x06
    4594:	9f 81       	ldd	r25, Y+7	; 0x07
    4596:	68 85       	ldd	r22, Y+8	; 0x08
    4598:	79 85       	ldd	r23, Y+9	; 0x09
    459a:	ec 85       	ldd	r30, Y+12	; 0x0c
    459c:	fd 85       	ldd	r31, Y+13	; 0x0d
    459e:	af 85       	ldd	r26, Y+15	; 0x0f
    45a0:	b8 89       	ldd	r27, Y+16	; 0x10
    45a2:	ac 80       	ldd	r10, Y+4	; 0x04
    45a4:	bd 80       	ldd	r11, Y+5	; 0x05
    45a6:	8f 01       	movw	r16, r30
    45a8:	ee 84       	ldd	r14, Y+14	; 0x0e
    45aa:	6d 01       	movw	r12, r26
    45ac:	88 24       	eor	r8, r8
    45ae:	99 24       	eor	r9, r9
    45b0:	0e 94 f7 22 	call	0x45ee	; 0x45ee <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    45b4:	8c 81       	ldd	r24, Y+4	; 0x04
    45b6:	9d 81       	ldd	r25, Y+5	; 0x05
    45b8:	0e 94 bc 23 	call	0x4778	; 0x4778 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    45bc:	81 e0       	ldi	r24, 0x01	; 1
    45be:	8b 83       	std	Y+3, r24	; 0x03
    45c0:	02 c0       	rjmp	.+4      	; 0x45c6 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    45c2:	8f ef       	ldi	r24, 0xFF	; 255
    45c4:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    45c6:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    45c8:	60 96       	adiw	r28, 0x10	; 16
    45ca:	0f b6       	in	r0, 0x3f	; 63
    45cc:	f8 94       	cli
    45ce:	de bf       	out	0x3e, r29	; 62
    45d0:	0f be       	out	0x3f, r0	; 63
    45d2:	cd bf       	out	0x3d, r28	; 61
    45d4:	cf 91       	pop	r28
    45d6:	df 91       	pop	r29
    45d8:	1f 91       	pop	r17
    45da:	0f 91       	pop	r16
    45dc:	ff 90       	pop	r15
    45de:	ef 90       	pop	r14
    45e0:	df 90       	pop	r13
    45e2:	cf 90       	pop	r12
    45e4:	bf 90       	pop	r11
    45e6:	af 90       	pop	r10
    45e8:	9f 90       	pop	r9
    45ea:	8f 90       	pop	r8
    45ec:	08 95       	ret

000045ee <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    45ee:	8f 92       	push	r8
    45f0:	9f 92       	push	r9
    45f2:	af 92       	push	r10
    45f4:	bf 92       	push	r11
    45f6:	cf 92       	push	r12
    45f8:	df 92       	push	r13
    45fa:	ef 92       	push	r14
    45fc:	0f 93       	push	r16
    45fe:	1f 93       	push	r17
    4600:	df 93       	push	r29
    4602:	cf 93       	push	r28
    4604:	cd b7       	in	r28, 0x3d	; 61
    4606:	de b7       	in	r29, 0x3e	; 62
    4608:	64 97       	sbiw	r28, 0x14	; 20
    460a:	0f b6       	in	r0, 0x3f	; 63
    460c:	f8 94       	cli
    460e:	de bf       	out	0x3e, r29	; 62
    4610:	0f be       	out	0x3f, r0	; 63
    4612:	cd bf       	out	0x3d, r28	; 61
    4614:	9d 83       	std	Y+5, r25	; 0x05
    4616:	8c 83       	std	Y+4, r24	; 0x04
    4618:	7f 83       	std	Y+7, r23	; 0x07
    461a:	6e 83       	std	Y+6, r22	; 0x06
    461c:	28 87       	std	Y+8, r18	; 0x08
    461e:	39 87       	std	Y+9, r19	; 0x09
    4620:	4a 87       	std	Y+10, r20	; 0x0a
    4622:	5b 87       	std	Y+11, r21	; 0x0b
    4624:	1d 87       	std	Y+13, r17	; 0x0d
    4626:	0c 87       	std	Y+12, r16	; 0x0c
    4628:	ee 86       	std	Y+14, r14	; 0x0e
    462a:	d8 8a       	std	Y+16, r13	; 0x10
    462c:	cf 86       	std	Y+15, r12	; 0x0f
    462e:	ba 8a       	std	Y+18, r11	; 0x12
    4630:	a9 8a       	std	Y+17, r10	; 0x11
    4632:	9c 8a       	std	Y+20, r9	; 0x14
    4634:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    4636:	e9 89       	ldd	r30, Y+17	; 0x11
    4638:	fa 89       	ldd	r31, Y+18	; 0x12
    463a:	27 89       	ldd	r18, Z+23	; 0x17
    463c:	30 8d       	ldd	r19, Z+24	; 0x18
    463e:	88 85       	ldd	r24, Y+8	; 0x08
    4640:	99 85       	ldd	r25, Y+9	; 0x09
    4642:	01 97       	sbiw	r24, 0x01	; 1
    4644:	82 0f       	add	r24, r18
    4646:	93 1f       	adc	r25, r19
    4648:	9b 83       	std	Y+3, r25	; 0x03
    464a:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    464c:	8e 81       	ldd	r24, Y+6	; 0x06
    464e:	9f 81       	ldd	r25, Y+7	; 0x07
    4650:	00 97       	sbiw	r24, 0x00	; 0
    4652:	51 f1       	breq	.+84     	; 0x46a8 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4654:	19 82       	std	Y+1, r1	; 0x01
    4656:	21 c0       	rjmp	.+66     	; 0x469a <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4658:	89 81       	ldd	r24, Y+1	; 0x01
    465a:	48 2f       	mov	r20, r24
    465c:	50 e0       	ldi	r21, 0x00	; 0
    465e:	89 81       	ldd	r24, Y+1	; 0x01
    4660:	28 2f       	mov	r18, r24
    4662:	30 e0       	ldi	r19, 0x00	; 0
    4664:	8e 81       	ldd	r24, Y+6	; 0x06
    4666:	9f 81       	ldd	r25, Y+7	; 0x07
    4668:	fc 01       	movw	r30, r24
    466a:	e2 0f       	add	r30, r18
    466c:	f3 1f       	adc	r31, r19
    466e:	20 81       	ld	r18, Z
    4670:	89 89       	ldd	r24, Y+17	; 0x11
    4672:	9a 89       	ldd	r25, Y+18	; 0x12
    4674:	84 0f       	add	r24, r20
    4676:	95 1f       	adc	r25, r21
    4678:	fc 01       	movw	r30, r24
    467a:	79 96       	adiw	r30, 0x19	; 25
    467c:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    467e:	89 81       	ldd	r24, Y+1	; 0x01
    4680:	28 2f       	mov	r18, r24
    4682:	30 e0       	ldi	r19, 0x00	; 0
    4684:	8e 81       	ldd	r24, Y+6	; 0x06
    4686:	9f 81       	ldd	r25, Y+7	; 0x07
    4688:	fc 01       	movw	r30, r24
    468a:	e2 0f       	add	r30, r18
    468c:	f3 1f       	adc	r31, r19
    468e:	80 81       	ld	r24, Z
    4690:	88 23       	and	r24, r24
    4692:	31 f0       	breq	.+12     	; 0x46a0 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4694:	89 81       	ldd	r24, Y+1	; 0x01
    4696:	8f 5f       	subi	r24, 0xFF	; 255
    4698:	89 83       	std	Y+1, r24	; 0x01
    469a:	89 81       	ldd	r24, Y+1	; 0x01
    469c:	88 30       	cpi	r24, 0x08	; 8
    469e:	e0 f2       	brcs	.-72     	; 0x4658 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    46a0:	e9 89       	ldd	r30, Y+17	; 0x11
    46a2:	fa 89       	ldd	r31, Y+18	; 0x12
    46a4:	10 a2       	std	Z+32, r1	; 0x20
    46a6:	03 c0       	rjmp	.+6      	; 0x46ae <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    46a8:	e9 89       	ldd	r30, Y+17	; 0x11
    46aa:	fa 89       	ldd	r31, Y+18	; 0x12
    46ac:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    46ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    46b0:	84 30       	cpi	r24, 0x04	; 4
    46b2:	10 f0       	brcs	.+4      	; 0x46b8 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    46b4:	83 e0       	ldi	r24, 0x03	; 3
    46b6:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    46b8:	e9 89       	ldd	r30, Y+17	; 0x11
    46ba:	fa 89       	ldd	r31, Y+18	; 0x12
    46bc:	8e 85       	ldd	r24, Y+14	; 0x0e
    46be:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    46c0:	89 89       	ldd	r24, Y+17	; 0x11
    46c2:	9a 89       	ldd	r25, Y+18	; 0x12
    46c4:	02 96       	adiw	r24, 0x02	; 2
    46c6:	0e 94 1d 18 	call	0x303a	; 0x303a <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    46ca:	89 89       	ldd	r24, Y+17	; 0x11
    46cc:	9a 89       	ldd	r25, Y+18	; 0x12
    46ce:	0c 96       	adiw	r24, 0x0c	; 12
    46d0:	0e 94 1d 18 	call	0x303a	; 0x303a <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    46d4:	e9 89       	ldd	r30, Y+17	; 0x11
    46d6:	fa 89       	ldd	r31, Y+18	; 0x12
    46d8:	89 89       	ldd	r24, Y+17	; 0x11
    46da:	9a 89       	ldd	r25, Y+18	; 0x12
    46dc:	91 87       	std	Z+9, r25	; 0x09
    46de:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    46e0:	8e 85       	ldd	r24, Y+14	; 0x0e
    46e2:	28 2f       	mov	r18, r24
    46e4:	30 e0       	ldi	r19, 0x00	; 0
    46e6:	84 e0       	ldi	r24, 0x04	; 4
    46e8:	90 e0       	ldi	r25, 0x00	; 0
    46ea:	82 1b       	sub	r24, r18
    46ec:	93 0b       	sbc	r25, r19
    46ee:	e9 89       	ldd	r30, Y+17	; 0x11
    46f0:	fa 89       	ldd	r31, Y+18	; 0x12
    46f2:	95 87       	std	Z+13, r25	; 0x0d
    46f4:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    46f6:	e9 89       	ldd	r30, Y+17	; 0x11
    46f8:	fa 89       	ldd	r31, Y+18	; 0x12
    46fa:	89 89       	ldd	r24, Y+17	; 0x11
    46fc:	9a 89       	ldd	r25, Y+18	; 0x12
    46fe:	93 8b       	std	Z+19, r25	; 0x13
    4700:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    4702:	89 89       	ldd	r24, Y+17	; 0x11
    4704:	9a 89       	ldd	r25, Y+18	; 0x12
    4706:	81 96       	adiw	r24, 0x21	; 33
    4708:	60 e0       	ldi	r22, 0x00	; 0
    470a:	70 e0       	ldi	r23, 0x00	; 0
    470c:	44 e0       	ldi	r20, 0x04	; 4
    470e:	50 e0       	ldi	r21, 0x00	; 0
    4710:	0e 94 1f 3c 	call	0x783e	; 0x783e <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    4714:	89 89       	ldd	r24, Y+17	; 0x11
    4716:	9a 89       	ldd	r25, Y+18	; 0x12
    4718:	85 96       	adiw	r24, 0x25	; 37
    471a:	60 e0       	ldi	r22, 0x00	; 0
    471c:	70 e0       	ldi	r23, 0x00	; 0
    471e:	41 e0       	ldi	r20, 0x01	; 1
    4720:	50 e0       	ldi	r21, 0x00	; 0
    4722:	0e 94 1f 3c 	call	0x783e	; 0x783e <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4726:	8a 81       	ldd	r24, Y+2	; 0x02
    4728:	9b 81       	ldd	r25, Y+3	; 0x03
    472a:	2c 81       	ldd	r18, Y+4	; 0x04
    472c:	3d 81       	ldd	r19, Y+5	; 0x05
    472e:	4c 85       	ldd	r20, Y+12	; 0x0c
    4730:	5d 85       	ldd	r21, Y+13	; 0x0d
    4732:	b9 01       	movw	r22, r18
    4734:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <pxPortInitialiseStack>
    4738:	e9 89       	ldd	r30, Y+17	; 0x11
    473a:	fa 89       	ldd	r31, Y+18	; 0x12
    473c:	91 83       	std	Z+1, r25	; 0x01
    473e:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    4740:	8f 85       	ldd	r24, Y+15	; 0x0f
    4742:	98 89       	ldd	r25, Y+16	; 0x10
    4744:	00 97       	sbiw	r24, 0x00	; 0
    4746:	31 f0       	breq	.+12     	; 0x4754 <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4748:	ef 85       	ldd	r30, Y+15	; 0x0f
    474a:	f8 89       	ldd	r31, Y+16	; 0x10
    474c:	89 89       	ldd	r24, Y+17	; 0x11
    474e:	9a 89       	ldd	r25, Y+18	; 0x12
    4750:	91 83       	std	Z+1, r25	; 0x01
    4752:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    4754:	64 96       	adiw	r28, 0x14	; 20
    4756:	0f b6       	in	r0, 0x3f	; 63
    4758:	f8 94       	cli
    475a:	de bf       	out	0x3e, r29	; 62
    475c:	0f be       	out	0x3f, r0	; 63
    475e:	cd bf       	out	0x3d, r28	; 61
    4760:	cf 91       	pop	r28
    4762:	df 91       	pop	r29
    4764:	1f 91       	pop	r17
    4766:	0f 91       	pop	r16
    4768:	ef 90       	pop	r14
    476a:	df 90       	pop	r13
    476c:	cf 90       	pop	r12
    476e:	bf 90       	pop	r11
    4770:	af 90       	pop	r10
    4772:	9f 90       	pop	r9
    4774:	8f 90       	pop	r8
    4776:	08 95       	ret

00004778 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    4778:	df 93       	push	r29
    477a:	cf 93       	push	r28
    477c:	00 d0       	rcall	.+0      	; 0x477e <prvAddNewTaskToReadyList+0x6>
    477e:	00 d0       	rcall	.+0      	; 0x4780 <prvAddNewTaskToReadyList+0x8>
    4780:	cd b7       	in	r28, 0x3d	; 61
    4782:	de b7       	in	r29, 0x3e	; 62
    4784:	9c 83       	std	Y+4, r25	; 0x04
    4786:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    4788:	0f b6       	in	r0, 0x3f	; 63
    478a:	f8 94       	cli
    478c:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    478e:	80 91 4b 07 	lds	r24, 0x074B
    4792:	8f 5f       	subi	r24, 0xFF	; 255
    4794:	80 93 4b 07 	sts	0x074B, r24

        if( pxCurrentTCB == NULL )
    4798:	80 91 48 07 	lds	r24, 0x0748
    479c:	90 91 49 07 	lds	r25, 0x0749
    47a0:	00 97       	sbiw	r24, 0x00	; 0
    47a2:	69 f4       	brne	.+26     	; 0x47be <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    47a4:	8b 81       	ldd	r24, Y+3	; 0x03
    47a6:	9c 81       	ldd	r25, Y+4	; 0x04
    47a8:	90 93 49 07 	sts	0x0749, r25
    47ac:	80 93 48 07 	sts	0x0748, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    47b0:	80 91 4b 07 	lds	r24, 0x074B
    47b4:	81 30       	cpi	r24, 0x01	; 1
    47b6:	b9 f4       	brne	.+46     	; 0x47e6 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    47b8:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <prvInitialiseTaskLists>
    47bc:	14 c0       	rjmp	.+40     	; 0x47e6 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    47be:	80 91 4f 07 	lds	r24, 0x074F
    47c2:	88 23       	and	r24, r24
    47c4:	81 f4       	brne	.+32     	; 0x47e6 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    47c6:	e0 91 48 07 	lds	r30, 0x0748
    47ca:	f0 91 49 07 	lds	r31, 0x0749
    47ce:	96 89       	ldd	r25, Z+22	; 0x16
    47d0:	eb 81       	ldd	r30, Y+3	; 0x03
    47d2:	fc 81       	ldd	r31, Y+4	; 0x04
    47d4:	86 89       	ldd	r24, Z+22	; 0x16
    47d6:	89 17       	cp	r24, r25
    47d8:	30 f0       	brcs	.+12     	; 0x47e6 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    47da:	8b 81       	ldd	r24, Y+3	; 0x03
    47dc:	9c 81       	ldd	r25, Y+4	; 0x04
    47de:	90 93 49 07 	sts	0x0749, r25
    47e2:	80 93 48 07 	sts	0x0748, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    47e6:	80 91 54 07 	lds	r24, 0x0754
    47ea:	8f 5f       	subi	r24, 0xFF	; 255
    47ec:	80 93 54 07 	sts	0x0754, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    47f0:	eb 81       	ldd	r30, Y+3	; 0x03
    47f2:	fc 81       	ldd	r31, Y+4	; 0x04
    47f4:	96 89       	ldd	r25, Z+22	; 0x16
    47f6:	80 91 4e 07 	lds	r24, 0x074E
    47fa:	89 17       	cp	r24, r25
    47fc:	28 f4       	brcc	.+10     	; 0x4808 <prvAddNewTaskToReadyList+0x90>
    47fe:	eb 81       	ldd	r30, Y+3	; 0x03
    4800:	fc 81       	ldd	r31, Y+4	; 0x04
    4802:	86 89       	ldd	r24, Z+22	; 0x16
    4804:	80 93 4e 07 	sts	0x074E, r24
    4808:	eb 81       	ldd	r30, Y+3	; 0x03
    480a:	fc 81       	ldd	r31, Y+4	; 0x04
    480c:	86 89       	ldd	r24, Z+22	; 0x16
    480e:	28 2f       	mov	r18, r24
    4810:	30 e0       	ldi	r19, 0x00	; 0
    4812:	c9 01       	movw	r24, r18
    4814:	88 0f       	add	r24, r24
    4816:	99 1f       	adc	r25, r25
    4818:	88 0f       	add	r24, r24
    481a:	99 1f       	adc	r25, r25
    481c:	88 0f       	add	r24, r24
    481e:	99 1f       	adc	r25, r25
    4820:	82 0f       	add	r24, r18
    4822:	93 1f       	adc	r25, r19
    4824:	fc 01       	movw	r30, r24
    4826:	e6 5a       	subi	r30, 0xA6	; 166
    4828:	f8 4f       	sbci	r31, 0xF8	; 248
    482a:	81 81       	ldd	r24, Z+1	; 0x01
    482c:	92 81       	ldd	r25, Z+2	; 0x02
    482e:	9a 83       	std	Y+2, r25	; 0x02
    4830:	89 83       	std	Y+1, r24	; 0x01
    4832:	eb 81       	ldd	r30, Y+3	; 0x03
    4834:	fc 81       	ldd	r31, Y+4	; 0x04
    4836:	89 81       	ldd	r24, Y+1	; 0x01
    4838:	9a 81       	ldd	r25, Y+2	; 0x02
    483a:	95 83       	std	Z+5, r25	; 0x05
    483c:	84 83       	std	Z+4, r24	; 0x04
    483e:	e9 81       	ldd	r30, Y+1	; 0x01
    4840:	fa 81       	ldd	r31, Y+2	; 0x02
    4842:	84 81       	ldd	r24, Z+4	; 0x04
    4844:	95 81       	ldd	r25, Z+5	; 0x05
    4846:	eb 81       	ldd	r30, Y+3	; 0x03
    4848:	fc 81       	ldd	r31, Y+4	; 0x04
    484a:	97 83       	std	Z+7, r25	; 0x07
    484c:	86 83       	std	Z+6, r24	; 0x06
    484e:	e9 81       	ldd	r30, Y+1	; 0x01
    4850:	fa 81       	ldd	r31, Y+2	; 0x02
    4852:	04 80       	ldd	r0, Z+4	; 0x04
    4854:	f5 81       	ldd	r31, Z+5	; 0x05
    4856:	e0 2d       	mov	r30, r0
    4858:	8b 81       	ldd	r24, Y+3	; 0x03
    485a:	9c 81       	ldd	r25, Y+4	; 0x04
    485c:	02 96       	adiw	r24, 0x02	; 2
    485e:	93 83       	std	Z+3, r25	; 0x03
    4860:	82 83       	std	Z+2, r24	; 0x02
    4862:	8b 81       	ldd	r24, Y+3	; 0x03
    4864:	9c 81       	ldd	r25, Y+4	; 0x04
    4866:	02 96       	adiw	r24, 0x02	; 2
    4868:	e9 81       	ldd	r30, Y+1	; 0x01
    486a:	fa 81       	ldd	r31, Y+2	; 0x02
    486c:	95 83       	std	Z+5, r25	; 0x05
    486e:	84 83       	std	Z+4, r24	; 0x04
    4870:	eb 81       	ldd	r30, Y+3	; 0x03
    4872:	fc 81       	ldd	r31, Y+4	; 0x04
    4874:	86 89       	ldd	r24, Z+22	; 0x16
    4876:	28 2f       	mov	r18, r24
    4878:	30 e0       	ldi	r19, 0x00	; 0
    487a:	c9 01       	movw	r24, r18
    487c:	88 0f       	add	r24, r24
    487e:	99 1f       	adc	r25, r25
    4880:	88 0f       	add	r24, r24
    4882:	99 1f       	adc	r25, r25
    4884:	88 0f       	add	r24, r24
    4886:	99 1f       	adc	r25, r25
    4888:	82 0f       	add	r24, r18
    488a:	93 1f       	adc	r25, r19
    488c:	86 5a       	subi	r24, 0xA6	; 166
    488e:	98 4f       	sbci	r25, 0xF8	; 248
    4890:	eb 81       	ldd	r30, Y+3	; 0x03
    4892:	fc 81       	ldd	r31, Y+4	; 0x04
    4894:	93 87       	std	Z+11, r25	; 0x0b
    4896:	82 87       	std	Z+10, r24	; 0x0a
    4898:	eb 81       	ldd	r30, Y+3	; 0x03
    489a:	fc 81       	ldd	r31, Y+4	; 0x04
    489c:	86 89       	ldd	r24, Z+22	; 0x16
    489e:	28 2f       	mov	r18, r24
    48a0:	30 e0       	ldi	r19, 0x00	; 0
    48a2:	c9 01       	movw	r24, r18
    48a4:	88 0f       	add	r24, r24
    48a6:	99 1f       	adc	r25, r25
    48a8:	88 0f       	add	r24, r24
    48aa:	99 1f       	adc	r25, r25
    48ac:	88 0f       	add	r24, r24
    48ae:	99 1f       	adc	r25, r25
    48b0:	82 0f       	add	r24, r18
    48b2:	93 1f       	adc	r25, r19
    48b4:	fc 01       	movw	r30, r24
    48b6:	e6 5a       	subi	r30, 0xA6	; 166
    48b8:	f8 4f       	sbci	r31, 0xF8	; 248
    48ba:	80 81       	ld	r24, Z
    48bc:	8f 5f       	subi	r24, 0xFF	; 255
    48be:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    48c0:	0f 90       	pop	r0
    48c2:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    48c4:	80 91 4f 07 	lds	r24, 0x074F
    48c8:	88 23       	and	r24, r24
    48ca:	61 f0       	breq	.+24     	; 0x48e4 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    48cc:	e0 91 48 07 	lds	r30, 0x0748
    48d0:	f0 91 49 07 	lds	r31, 0x0749
    48d4:	96 89       	ldd	r25, Z+22	; 0x16
    48d6:	eb 81       	ldd	r30, Y+3	; 0x03
    48d8:	fc 81       	ldd	r31, Y+4	; 0x04
    48da:	86 89       	ldd	r24, Z+22	; 0x16
    48dc:	98 17       	cp	r25, r24
    48de:	10 f4       	brcc	.+4      	; 0x48e4 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    48e0:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    48e4:	0f 90       	pop	r0
    48e6:	0f 90       	pop	r0
    48e8:	0f 90       	pop	r0
    48ea:	0f 90       	pop	r0
    48ec:	cf 91       	pop	r28
    48ee:	df 91       	pop	r29
    48f0:	08 95       	ret

000048f2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    48f2:	df 93       	push	r29
    48f4:	cf 93       	push	r28
    48f6:	00 d0       	rcall	.+0      	; 0x48f8 <vTaskDelete+0x6>
    48f8:	00 d0       	rcall	.+0      	; 0x48fa <vTaskDelete+0x8>
    48fa:	00 d0       	rcall	.+0      	; 0x48fc <vTaskDelete+0xa>
    48fc:	cd b7       	in	r28, 0x3d	; 61
    48fe:	de b7       	in	r29, 0x3e	; 62
    4900:	9c 83       	std	Y+4, r25	; 0x04
    4902:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    4904:	0f b6       	in	r0, 0x3f	; 63
    4906:	f8 94       	cli
    4908:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    490a:	8b 81       	ldd	r24, Y+3	; 0x03
    490c:	9c 81       	ldd	r25, Y+4	; 0x04
    490e:	00 97       	sbiw	r24, 0x00	; 0
    4910:	39 f4       	brne	.+14     	; 0x4920 <vTaskDelete+0x2e>
    4912:	80 91 48 07 	lds	r24, 0x0748
    4916:	90 91 49 07 	lds	r25, 0x0749
    491a:	9e 83       	std	Y+6, r25	; 0x06
    491c:	8d 83       	std	Y+5, r24	; 0x05
    491e:	04 c0       	rjmp	.+8      	; 0x4928 <vTaskDelete+0x36>
    4920:	8b 81       	ldd	r24, Y+3	; 0x03
    4922:	9c 81       	ldd	r25, Y+4	; 0x04
    4924:	9e 83       	std	Y+6, r25	; 0x06
    4926:	8d 83       	std	Y+5, r24	; 0x05
    4928:	8d 81       	ldd	r24, Y+5	; 0x05
    492a:	9e 81       	ldd	r25, Y+6	; 0x06
    492c:	9a 83       	std	Y+2, r25	; 0x02
    492e:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4930:	89 81       	ldd	r24, Y+1	; 0x01
    4932:	9a 81       	ldd	r25, Y+2	; 0x02
    4934:	02 96       	adiw	r24, 0x02	; 2
    4936:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    493a:	e9 81       	ldd	r30, Y+1	; 0x01
    493c:	fa 81       	ldd	r31, Y+2	; 0x02
    493e:	84 89       	ldd	r24, Z+20	; 0x14
    4940:	95 89       	ldd	r25, Z+21	; 0x15
    4942:	00 97       	sbiw	r24, 0x00	; 0
    4944:	29 f0       	breq	.+10     	; 0x4950 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4946:	89 81       	ldd	r24, Y+1	; 0x01
    4948:	9a 81       	ldd	r25, Y+2	; 0x02
    494a:	0c 96       	adiw	r24, 0x0c	; 12
    494c:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    4950:	80 91 54 07 	lds	r24, 0x0754
    4954:	8f 5f       	subi	r24, 0xFF	; 255
    4956:	80 93 54 07 	sts	0x0754, r24

            if( pxTCB == pxCurrentTCB )
    495a:	20 91 48 07 	lds	r18, 0x0748
    495e:	30 91 49 07 	lds	r19, 0x0749
    4962:	89 81       	ldd	r24, Y+1	; 0x01
    4964:	9a 81       	ldd	r25, Y+2	; 0x02
    4966:	82 17       	cp	r24, r18
    4968:	93 07       	cpc	r25, r19
    496a:	81 f4       	brne	.+32     	; 0x498c <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    496c:	89 81       	ldd	r24, Y+1	; 0x01
    496e:	9a 81       	ldd	r25, Y+2	; 0x02
    4970:	9c 01       	movw	r18, r24
    4972:	2e 5f       	subi	r18, 0xFE	; 254
    4974:	3f 4f       	sbci	r19, 0xFF	; 255
    4976:	8d e9       	ldi	r24, 0x9D	; 157
    4978:	97 e0       	ldi	r25, 0x07	; 7
    497a:	b9 01       	movw	r22, r18
    497c:	0e 94 2d 18 	call	0x305a	; 0x305a <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    4980:	80 91 4a 07 	lds	r24, 0x074A
    4984:	8f 5f       	subi	r24, 0xFF	; 255
    4986:	80 93 4a 07 	sts	0x074A, r24
    498a:	07 c0       	rjmp	.+14     	; 0x499a <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    498c:	80 91 4b 07 	lds	r24, 0x074B
    4990:	81 50       	subi	r24, 0x01	; 1
    4992:	80 93 4b 07 	sts	0x074B, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    4996:	0e 94 22 2e 	call	0x5c44	; 0x5c44 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    499a:	0f 90       	pop	r0
    499c:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    499e:	20 91 48 07 	lds	r18, 0x0748
    49a2:	30 91 49 07 	lds	r19, 0x0749
    49a6:	89 81       	ldd	r24, Y+1	; 0x01
    49a8:	9a 81       	ldd	r25, Y+2	; 0x02
    49aa:	82 17       	cp	r24, r18
    49ac:	93 07       	cpc	r25, r19
    49ae:	21 f0       	breq	.+8      	; 0x49b8 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    49b0:	89 81       	ldd	r24, Y+1	; 0x01
    49b2:	9a 81       	ldd	r25, Y+2	; 0x02
    49b4:	0e 94 0c 2e 	call	0x5c18	; 0x5c18 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    49b8:	80 91 4f 07 	lds	r24, 0x074F
    49bc:	88 23       	and	r24, r24
    49be:	59 f0       	breq	.+22     	; 0x49d6 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    49c0:	20 91 48 07 	lds	r18, 0x0748
    49c4:	30 91 49 07 	lds	r19, 0x0749
    49c8:	89 81       	ldd	r24, Y+1	; 0x01
    49ca:	9a 81       	ldd	r25, Y+2	; 0x02
    49cc:	82 17       	cp	r24, r18
    49ce:	93 07       	cpc	r25, r19
    49d0:	11 f4       	brne	.+4      	; 0x49d6 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    49d2:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    49d6:	26 96       	adiw	r28, 0x06	; 6
    49d8:	0f b6       	in	r0, 0x3f	; 63
    49da:	f8 94       	cli
    49dc:	de bf       	out	0x3e, r29	; 62
    49de:	0f be       	out	0x3f, r0	; 63
    49e0:	cd bf       	out	0x3d, r28	; 61
    49e2:	cf 91       	pop	r28
    49e4:	df 91       	pop	r29
    49e6:	08 95       	ret

000049e8 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    49e8:	df 93       	push	r29
    49ea:	cf 93       	push	r28
    49ec:	cd b7       	in	r28, 0x3d	; 61
    49ee:	de b7       	in	r29, 0x3e	; 62
    49f0:	2a 97       	sbiw	r28, 0x0a	; 10
    49f2:	0f b6       	in	r0, 0x3f	; 63
    49f4:	f8 94       	cli
    49f6:	de bf       	out	0x3e, r29	; 62
    49f8:	0f be       	out	0x3f, r0	; 63
    49fa:	cd bf       	out	0x3d, r28	; 61
    49fc:	98 87       	std	Y+8, r25	; 0x08
    49fe:	8f 83       	std	Y+7, r24	; 0x07
    4a00:	7a 87       	std	Y+10, r23	; 0x0a
    4a02:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    4a04:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    4a06:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    4a0a:	80 91 4c 07 	lds	r24, 0x074C
    4a0e:	90 91 4d 07 	lds	r25, 0x074D
    4a12:	9a 83       	std	Y+2, r25	; 0x02
    4a14:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4a16:	ef 81       	ldd	r30, Y+7	; 0x07
    4a18:	f8 85       	ldd	r31, Y+8	; 0x08
    4a1a:	20 81       	ld	r18, Z
    4a1c:	31 81       	ldd	r19, Z+1	; 0x01
    4a1e:	89 85       	ldd	r24, Y+9	; 0x09
    4a20:	9a 85       	ldd	r25, Y+10	; 0x0a
    4a22:	82 0f       	add	r24, r18
    4a24:	93 1f       	adc	r25, r19
    4a26:	9e 83       	std	Y+6, r25	; 0x06
    4a28:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    4a2a:	ef 81       	ldd	r30, Y+7	; 0x07
    4a2c:	f8 85       	ldd	r31, Y+8	; 0x08
    4a2e:	20 81       	ld	r18, Z
    4a30:	31 81       	ldd	r19, Z+1	; 0x01
    4a32:	89 81       	ldd	r24, Y+1	; 0x01
    4a34:	9a 81       	ldd	r25, Y+2	; 0x02
    4a36:	82 17       	cp	r24, r18
    4a38:	93 07       	cpc	r25, r19
    4a3a:	98 f4       	brcc	.+38     	; 0x4a62 <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    4a3c:	ef 81       	ldd	r30, Y+7	; 0x07
    4a3e:	f8 85       	ldd	r31, Y+8	; 0x08
    4a40:	20 81       	ld	r18, Z
    4a42:	31 81       	ldd	r19, Z+1	; 0x01
    4a44:	8d 81       	ldd	r24, Y+5	; 0x05
    4a46:	9e 81       	ldd	r25, Y+6	; 0x06
    4a48:	82 17       	cp	r24, r18
    4a4a:	93 07       	cpc	r25, r19
    4a4c:	e0 f4       	brcc	.+56     	; 0x4a86 <xTaskDelayUntil+0x9e>
    4a4e:	2d 81       	ldd	r18, Y+5	; 0x05
    4a50:	3e 81       	ldd	r19, Y+6	; 0x06
    4a52:	89 81       	ldd	r24, Y+1	; 0x01
    4a54:	9a 81       	ldd	r25, Y+2	; 0x02
    4a56:	82 17       	cp	r24, r18
    4a58:	93 07       	cpc	r25, r19
    4a5a:	a8 f4       	brcc	.+42     	; 0x4a86 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    4a5c:	81 e0       	ldi	r24, 0x01	; 1
    4a5e:	8b 83       	std	Y+3, r24	; 0x03
    4a60:	12 c0       	rjmp	.+36     	; 0x4a86 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    4a62:	ef 81       	ldd	r30, Y+7	; 0x07
    4a64:	f8 85       	ldd	r31, Y+8	; 0x08
    4a66:	20 81       	ld	r18, Z
    4a68:	31 81       	ldd	r19, Z+1	; 0x01
    4a6a:	8d 81       	ldd	r24, Y+5	; 0x05
    4a6c:	9e 81       	ldd	r25, Y+6	; 0x06
    4a6e:	82 17       	cp	r24, r18
    4a70:	93 07       	cpc	r25, r19
    4a72:	38 f0       	brcs	.+14     	; 0x4a82 <xTaskDelayUntil+0x9a>
    4a74:	2d 81       	ldd	r18, Y+5	; 0x05
    4a76:	3e 81       	ldd	r19, Y+6	; 0x06
    4a78:	89 81       	ldd	r24, Y+1	; 0x01
    4a7a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a7c:	82 17       	cp	r24, r18
    4a7e:	93 07       	cpc	r25, r19
    4a80:	10 f4       	brcc	.+4      	; 0x4a86 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    4a82:	81 e0       	ldi	r24, 0x01	; 1
    4a84:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    4a86:	ef 81       	ldd	r30, Y+7	; 0x07
    4a88:	f8 85       	ldd	r31, Y+8	; 0x08
    4a8a:	8d 81       	ldd	r24, Y+5	; 0x05
    4a8c:	9e 81       	ldd	r25, Y+6	; 0x06
    4a8e:	91 83       	std	Z+1, r25	; 0x01
    4a90:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    4a92:	8b 81       	ldd	r24, Y+3	; 0x03
    4a94:	88 23       	and	r24, r24
    4a96:	49 f0       	breq	.+18     	; 0x4aaa <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    4a98:	8d 81       	ldd	r24, Y+5	; 0x05
    4a9a:	9e 81       	ldd	r25, Y+6	; 0x06
    4a9c:	29 81       	ldd	r18, Y+1	; 0x01
    4a9e:	3a 81       	ldd	r19, Y+2	; 0x02
    4aa0:	82 1b       	sub	r24, r18
    4aa2:	93 0b       	sbc	r25, r19
    4aa4:	60 e0       	ldi	r22, 0x00	; 0
    4aa6:	0e 94 09 36 	call	0x6c12	; 0x6c12 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    4aaa:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    4aae:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    4ab0:	8c 81       	ldd	r24, Y+4	; 0x04
    4ab2:	88 23       	and	r24, r24
    4ab4:	11 f4       	brne	.+4      	; 0x4aba <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    4ab6:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    4aba:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    4abc:	2a 96       	adiw	r28, 0x0a	; 10
    4abe:	0f b6       	in	r0, 0x3f	; 63
    4ac0:	f8 94       	cli
    4ac2:	de bf       	out	0x3e, r29	; 62
    4ac4:	0f be       	out	0x3f, r0	; 63
    4ac6:	cd bf       	out	0x3d, r28	; 61
    4ac8:	cf 91       	pop	r28
    4aca:	df 91       	pop	r29
    4acc:	08 95       	ret

00004ace <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    4ace:	df 93       	push	r29
    4ad0:	cf 93       	push	r28
    4ad2:	00 d0       	rcall	.+0      	; 0x4ad4 <vTaskDelay+0x6>
    4ad4:	0f 92       	push	r0
    4ad6:	cd b7       	in	r28, 0x3d	; 61
    4ad8:	de b7       	in	r29, 0x3e	; 62
    4ada:	9b 83       	std	Y+3, r25	; 0x03
    4adc:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    4ade:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    4ae0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ae2:	9b 81       	ldd	r25, Y+3	; 0x03
    4ae4:	00 97       	sbiw	r24, 0x00	; 0
    4ae6:	51 f0       	breq	.+20     	; 0x4afc <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    4ae8:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4aec:	8a 81       	ldd	r24, Y+2	; 0x02
    4aee:	9b 81       	ldd	r25, Y+3	; 0x03
    4af0:	60 e0       	ldi	r22, 0x00	; 0
    4af2:	0e 94 09 36 	call	0x6c12	; 0x6c12 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    4af6:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    4afa:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    4afc:	89 81       	ldd	r24, Y+1	; 0x01
    4afe:	88 23       	and	r24, r24
    4b00:	11 f4       	brne	.+4      	; 0x4b06 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    4b02:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    4b06:	0f 90       	pop	r0
    4b08:	0f 90       	pop	r0
    4b0a:	0f 90       	pop	r0
    4b0c:	cf 91       	pop	r28
    4b0e:	df 91       	pop	r29
    4b10:	08 95       	ret

00004b12 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4b12:	ef 92       	push	r14
    4b14:	ff 92       	push	r15
    4b16:	0f 93       	push	r16
    4b18:	df 93       	push	r29
    4b1a:	cf 93       	push	r28
    4b1c:	00 d0       	rcall	.+0      	; 0x4b1e <vTaskStartScheduler+0xc>
    4b1e:	cd b7       	in	r28, 0x3d	; 61
    4b20:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    4b22:	80 e9       	ldi	r24, 0x90	; 144
    4b24:	9d e2       	ldi	r25, 0x2D	; 45
    4b26:	25 e7       	ldi	r18, 0x75	; 117
    4b28:	30 e0       	ldi	r19, 0x00	; 0
    4b2a:	e7 e5       	ldi	r30, 0x57	; 87
    4b2c:	f7 e0       	ldi	r31, 0x07	; 7
    4b2e:	b9 01       	movw	r22, r18
    4b30:	45 e5       	ldi	r20, 0x55	; 85
    4b32:	50 e0       	ldi	r21, 0x00	; 0
    4b34:	20 e0       	ldi	r18, 0x00	; 0
    4b36:	30 e0       	ldi	r19, 0x00	; 0
    4b38:	00 e0       	ldi	r16, 0x00	; 0
    4b3a:	7f 01       	movw	r14, r30
    4b3c:	0e 94 7f 22 	call	0x44fe	; 0x44fe <xTaskCreate>
    4b40:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    4b42:	89 81       	ldd	r24, Y+1	; 0x01
    4b44:	81 30       	cpi	r24, 0x01	; 1
    4b46:	19 f4       	brne	.+6      	; 0x4b4e <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    4b48:	0e 94 6f 36 	call	0x6cde	; 0x6cde <xTimerCreateTimerTask>
    4b4c:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    4b4e:	89 81       	ldd	r24, Y+1	; 0x01
    4b50:	81 30       	cpi	r24, 0x01	; 1
    4b52:	81 f4       	brne	.+32     	; 0x4b74 <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    4b54:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    4b56:	8f ef       	ldi	r24, 0xFF	; 255
    4b58:	9f ef       	ldi	r25, 0xFF	; 255
    4b5a:	90 93 56 07 	sts	0x0756, r25
    4b5e:	80 93 55 07 	sts	0x0755, r24
        xSchedulerRunning = pdTRUE;
    4b62:	81 e0       	ldi	r24, 0x01	; 1
    4b64:	80 93 4f 07 	sts	0x074F, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4b68:	10 92 4d 07 	sts	0x074D, r1
    4b6c:	10 92 4c 07 	sts	0x074C, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    4b70:	0e 94 7e 10 	call	0x20fc	; 0x20fc <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    4b74:	80 91 8a 00 	lds	r24, 0x008A
}
    4b78:	0f 90       	pop	r0
    4b7a:	0f 90       	pop	r0
    4b7c:	cf 91       	pop	r28
    4b7e:	df 91       	pop	r29
    4b80:	0f 91       	pop	r16
    4b82:	ff 90       	pop	r15
    4b84:	ef 90       	pop	r14
    4b86:	08 95       	ret

00004b88 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4b88:	df 93       	push	r29
    4b8a:	cf 93       	push	r28
    4b8c:	cd b7       	in	r28, 0x3d	; 61
    4b8e:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    4b90:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    4b92:	10 92 4f 07 	sts	0x074F, r1
    vPortEndScheduler();
    4b96:	0e 94 b3 10 	call	0x2166	; 0x2166 <vPortEndScheduler>
}
    4b9a:	cf 91       	pop	r28
    4b9c:	df 91       	pop	r29
    4b9e:	08 95       	ret

00004ba0 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4ba0:	df 93       	push	r29
    4ba2:	cf 93       	push	r28
    4ba4:	cd b7       	in	r28, 0x3d	; 61
    4ba6:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    4ba8:	80 91 59 07 	lds	r24, 0x0759
    4bac:	8f 5f       	subi	r24, 0xFF	; 255
    4bae:	80 93 59 07 	sts	0x0759, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    4bb2:	cf 91       	pop	r28
    4bb4:	df 91       	pop	r29
    4bb6:	08 95       	ret

00004bb8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4bb8:	df 93       	push	r29
    4bba:	cf 93       	push	r28
    4bbc:	cd b7       	in	r28, 0x3d	; 61
    4bbe:	de b7       	in	r29, 0x3e	; 62
    4bc0:	2b 97       	sbiw	r28, 0x0b	; 11
    4bc2:	0f b6       	in	r0, 0x3f	; 63
    4bc4:	f8 94       	cli
    4bc6:	de bf       	out	0x3e, r29	; 62
    4bc8:	0f be       	out	0x3f, r0	; 63
    4bca:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    4bcc:	1b 86       	std	Y+11, r1	; 0x0b
    4bce:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    4bd0:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    4bd2:	0f b6       	in	r0, 0x3f	; 63
    4bd4:	f8 94       	cli
    4bd6:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    4bd8:	80 91 59 07 	lds	r24, 0x0759
    4bdc:	81 50       	subi	r24, 0x01	; 1
    4bde:	80 93 59 07 	sts	0x0759, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4be2:	80 91 59 07 	lds	r24, 0x0759
    4be6:	88 23       	and	r24, r24
    4be8:	09 f0       	breq	.+2      	; 0x4bec <xTaskResumeAll+0x34>
    4bea:	2a c1       	rjmp	.+596    	; 0x4e40 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4bec:	80 91 4b 07 	lds	r24, 0x074B
    4bf0:	88 23       	and	r24, r24
    4bf2:	09 f4       	brne	.+2      	; 0x4bf6 <xTaskResumeAll+0x3e>
    4bf4:	25 c1       	rjmp	.+586    	; 0x4e40 <xTaskResumeAll+0x288>
    4bf6:	f3 c0       	rjmp	.+486    	; 0x4dde <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4bf8:	e0 91 99 07 	lds	r30, 0x0799
    4bfc:	f0 91 9a 07 	lds	r31, 0x079A
    4c00:	86 81       	ldd	r24, Z+6	; 0x06
    4c02:	97 81       	ldd	r25, Z+7	; 0x07
    4c04:	9b 87       	std	Y+11, r25	; 0x0b
    4c06:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    4c08:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c0a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c0c:	84 89       	ldd	r24, Z+20	; 0x14
    4c0e:	95 89       	ldd	r25, Z+21	; 0x15
    4c10:	98 87       	std	Y+8, r25	; 0x08
    4c12:	8f 83       	std	Y+7, r24	; 0x07
    4c14:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c16:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c18:	a6 85       	ldd	r26, Z+14	; 0x0e
    4c1a:	b7 85       	ldd	r27, Z+15	; 0x0f
    4c1c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c1e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c20:	80 89       	ldd	r24, Z+16	; 0x10
    4c22:	91 89       	ldd	r25, Z+17	; 0x11
    4c24:	15 96       	adiw	r26, 0x05	; 5
    4c26:	9c 93       	st	X, r25
    4c28:	8e 93       	st	-X, r24
    4c2a:	14 97       	sbiw	r26, 0x04	; 4
    4c2c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c2e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c30:	a0 89       	ldd	r26, Z+16	; 0x10
    4c32:	b1 89       	ldd	r27, Z+17	; 0x11
    4c34:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c36:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c38:	86 85       	ldd	r24, Z+14	; 0x0e
    4c3a:	97 85       	ldd	r25, Z+15	; 0x0f
    4c3c:	13 96       	adiw	r26, 0x03	; 3
    4c3e:	9c 93       	st	X, r25
    4c40:	8e 93       	st	-X, r24
    4c42:	12 97       	sbiw	r26, 0x02	; 2
    4c44:	ef 81       	ldd	r30, Y+7	; 0x07
    4c46:	f8 85       	ldd	r31, Y+8	; 0x08
    4c48:	21 81       	ldd	r18, Z+1	; 0x01
    4c4a:	32 81       	ldd	r19, Z+2	; 0x02
    4c4c:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c4e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4c50:	0c 96       	adiw	r24, 0x0c	; 12
    4c52:	28 17       	cp	r18, r24
    4c54:	39 07       	cpc	r19, r25
    4c56:	41 f4       	brne	.+16     	; 0x4c68 <xTaskResumeAll+0xb0>
    4c58:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c5a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c5c:	80 89       	ldd	r24, Z+16	; 0x10
    4c5e:	91 89       	ldd	r25, Z+17	; 0x11
    4c60:	ef 81       	ldd	r30, Y+7	; 0x07
    4c62:	f8 85       	ldd	r31, Y+8	; 0x08
    4c64:	92 83       	std	Z+2, r25	; 0x02
    4c66:	81 83       	std	Z+1, r24	; 0x01
    4c68:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c6a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c6c:	15 8a       	std	Z+21, r1	; 0x15
    4c6e:	14 8a       	std	Z+20, r1	; 0x14
    4c70:	ef 81       	ldd	r30, Y+7	; 0x07
    4c72:	f8 85       	ldd	r31, Y+8	; 0x08
    4c74:	80 81       	ld	r24, Z
    4c76:	81 50       	subi	r24, 0x01	; 1
    4c78:	ef 81       	ldd	r30, Y+7	; 0x07
    4c7a:	f8 85       	ldd	r31, Y+8	; 0x08
    4c7c:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4c7e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c80:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c82:	82 85       	ldd	r24, Z+10	; 0x0a
    4c84:	93 85       	ldd	r25, Z+11	; 0x0b
    4c86:	9e 83       	std	Y+6, r25	; 0x06
    4c88:	8d 83       	std	Y+5, r24	; 0x05
    4c8a:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c8c:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c8e:	a4 81       	ldd	r26, Z+4	; 0x04
    4c90:	b5 81       	ldd	r27, Z+5	; 0x05
    4c92:	ea 85       	ldd	r30, Y+10	; 0x0a
    4c94:	fb 85       	ldd	r31, Y+11	; 0x0b
    4c96:	86 81       	ldd	r24, Z+6	; 0x06
    4c98:	97 81       	ldd	r25, Z+7	; 0x07
    4c9a:	15 96       	adiw	r26, 0x05	; 5
    4c9c:	9c 93       	st	X, r25
    4c9e:	8e 93       	st	-X, r24
    4ca0:	14 97       	sbiw	r26, 0x04	; 4
    4ca2:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ca4:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ca6:	a6 81       	ldd	r26, Z+6	; 0x06
    4ca8:	b7 81       	ldd	r27, Z+7	; 0x07
    4caa:	ea 85       	ldd	r30, Y+10	; 0x0a
    4cac:	fb 85       	ldd	r31, Y+11	; 0x0b
    4cae:	84 81       	ldd	r24, Z+4	; 0x04
    4cb0:	95 81       	ldd	r25, Z+5	; 0x05
    4cb2:	13 96       	adiw	r26, 0x03	; 3
    4cb4:	9c 93       	st	X, r25
    4cb6:	8e 93       	st	-X, r24
    4cb8:	12 97       	sbiw	r26, 0x02	; 2
    4cba:	ed 81       	ldd	r30, Y+5	; 0x05
    4cbc:	fe 81       	ldd	r31, Y+6	; 0x06
    4cbe:	21 81       	ldd	r18, Z+1	; 0x01
    4cc0:	32 81       	ldd	r19, Z+2	; 0x02
    4cc2:	8a 85       	ldd	r24, Y+10	; 0x0a
    4cc4:	9b 85       	ldd	r25, Y+11	; 0x0b
    4cc6:	02 96       	adiw	r24, 0x02	; 2
    4cc8:	28 17       	cp	r18, r24
    4cca:	39 07       	cpc	r19, r25
    4ccc:	41 f4       	brne	.+16     	; 0x4cde <xTaskResumeAll+0x126>
    4cce:	ea 85       	ldd	r30, Y+10	; 0x0a
    4cd0:	fb 85       	ldd	r31, Y+11	; 0x0b
    4cd2:	86 81       	ldd	r24, Z+6	; 0x06
    4cd4:	97 81       	ldd	r25, Z+7	; 0x07
    4cd6:	ed 81       	ldd	r30, Y+5	; 0x05
    4cd8:	fe 81       	ldd	r31, Y+6	; 0x06
    4cda:	92 83       	std	Z+2, r25	; 0x02
    4cdc:	81 83       	std	Z+1, r24	; 0x01
    4cde:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ce0:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ce2:	13 86       	std	Z+11, r1	; 0x0b
    4ce4:	12 86       	std	Z+10, r1	; 0x0a
    4ce6:	ed 81       	ldd	r30, Y+5	; 0x05
    4ce8:	fe 81       	ldd	r31, Y+6	; 0x06
    4cea:	80 81       	ld	r24, Z
    4cec:	81 50       	subi	r24, 0x01	; 1
    4cee:	ed 81       	ldd	r30, Y+5	; 0x05
    4cf0:	fe 81       	ldd	r31, Y+6	; 0x06
    4cf2:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    4cf4:	ea 85       	ldd	r30, Y+10	; 0x0a
    4cf6:	fb 85       	ldd	r31, Y+11	; 0x0b
    4cf8:	96 89       	ldd	r25, Z+22	; 0x16
    4cfa:	80 91 4e 07 	lds	r24, 0x074E
    4cfe:	89 17       	cp	r24, r25
    4d00:	28 f4       	brcc	.+10     	; 0x4d0c <xTaskResumeAll+0x154>
    4d02:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d04:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d06:	86 89       	ldd	r24, Z+22	; 0x16
    4d08:	80 93 4e 07 	sts	0x074E, r24
    4d0c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d0e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d10:	86 89       	ldd	r24, Z+22	; 0x16
    4d12:	28 2f       	mov	r18, r24
    4d14:	30 e0       	ldi	r19, 0x00	; 0
    4d16:	c9 01       	movw	r24, r18
    4d18:	88 0f       	add	r24, r24
    4d1a:	99 1f       	adc	r25, r25
    4d1c:	88 0f       	add	r24, r24
    4d1e:	99 1f       	adc	r25, r25
    4d20:	88 0f       	add	r24, r24
    4d22:	99 1f       	adc	r25, r25
    4d24:	82 0f       	add	r24, r18
    4d26:	93 1f       	adc	r25, r19
    4d28:	fc 01       	movw	r30, r24
    4d2a:	e6 5a       	subi	r30, 0xA6	; 166
    4d2c:	f8 4f       	sbci	r31, 0xF8	; 248
    4d2e:	81 81       	ldd	r24, Z+1	; 0x01
    4d30:	92 81       	ldd	r25, Z+2	; 0x02
    4d32:	9c 83       	std	Y+4, r25	; 0x04
    4d34:	8b 83       	std	Y+3, r24	; 0x03
    4d36:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d38:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d3a:	8b 81       	ldd	r24, Y+3	; 0x03
    4d3c:	9c 81       	ldd	r25, Y+4	; 0x04
    4d3e:	95 83       	std	Z+5, r25	; 0x05
    4d40:	84 83       	std	Z+4, r24	; 0x04
    4d42:	eb 81       	ldd	r30, Y+3	; 0x03
    4d44:	fc 81       	ldd	r31, Y+4	; 0x04
    4d46:	84 81       	ldd	r24, Z+4	; 0x04
    4d48:	95 81       	ldd	r25, Z+5	; 0x05
    4d4a:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d4c:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d4e:	97 83       	std	Z+7, r25	; 0x07
    4d50:	86 83       	std	Z+6, r24	; 0x06
    4d52:	eb 81       	ldd	r30, Y+3	; 0x03
    4d54:	fc 81       	ldd	r31, Y+4	; 0x04
    4d56:	04 80       	ldd	r0, Z+4	; 0x04
    4d58:	f5 81       	ldd	r31, Z+5	; 0x05
    4d5a:	e0 2d       	mov	r30, r0
    4d5c:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d5e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d60:	02 96       	adiw	r24, 0x02	; 2
    4d62:	93 83       	std	Z+3, r25	; 0x03
    4d64:	82 83       	std	Z+2, r24	; 0x02
    4d66:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d68:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d6a:	02 96       	adiw	r24, 0x02	; 2
    4d6c:	eb 81       	ldd	r30, Y+3	; 0x03
    4d6e:	fc 81       	ldd	r31, Y+4	; 0x04
    4d70:	95 83       	std	Z+5, r25	; 0x05
    4d72:	84 83       	std	Z+4, r24	; 0x04
    4d74:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d76:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d78:	86 89       	ldd	r24, Z+22	; 0x16
    4d7a:	28 2f       	mov	r18, r24
    4d7c:	30 e0       	ldi	r19, 0x00	; 0
    4d7e:	c9 01       	movw	r24, r18
    4d80:	88 0f       	add	r24, r24
    4d82:	99 1f       	adc	r25, r25
    4d84:	88 0f       	add	r24, r24
    4d86:	99 1f       	adc	r25, r25
    4d88:	88 0f       	add	r24, r24
    4d8a:	99 1f       	adc	r25, r25
    4d8c:	82 0f       	add	r24, r18
    4d8e:	93 1f       	adc	r25, r19
    4d90:	86 5a       	subi	r24, 0xA6	; 166
    4d92:	98 4f       	sbci	r25, 0xF8	; 248
    4d94:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d96:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d98:	93 87       	std	Z+11, r25	; 0x0b
    4d9a:	82 87       	std	Z+10, r24	; 0x0a
    4d9c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d9e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4da0:	86 89       	ldd	r24, Z+22	; 0x16
    4da2:	28 2f       	mov	r18, r24
    4da4:	30 e0       	ldi	r19, 0x00	; 0
    4da6:	c9 01       	movw	r24, r18
    4da8:	88 0f       	add	r24, r24
    4daa:	99 1f       	adc	r25, r25
    4dac:	88 0f       	add	r24, r24
    4dae:	99 1f       	adc	r25, r25
    4db0:	88 0f       	add	r24, r24
    4db2:	99 1f       	adc	r25, r25
    4db4:	82 0f       	add	r24, r18
    4db6:	93 1f       	adc	r25, r19
    4db8:	fc 01       	movw	r30, r24
    4dba:	e6 5a       	subi	r30, 0xA6	; 166
    4dbc:	f8 4f       	sbci	r31, 0xF8	; 248
    4dbe:	80 81       	ld	r24, Z
    4dc0:	8f 5f       	subi	r24, 0xFF	; 255
    4dc2:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4dc4:	ea 85       	ldd	r30, Y+10	; 0x0a
    4dc6:	fb 85       	ldd	r31, Y+11	; 0x0b
    4dc8:	96 89       	ldd	r25, Z+22	; 0x16
    4dca:	e0 91 48 07 	lds	r30, 0x0748
    4dce:	f0 91 49 07 	lds	r31, 0x0749
    4dd2:	86 89       	ldd	r24, Z+22	; 0x16
    4dd4:	98 17       	cp	r25, r24
    4dd6:	18 f0       	brcs	.+6      	; 0x4dde <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    4dd8:	81 e0       	ldi	r24, 0x01	; 1
    4dda:	80 93 52 07 	sts	0x0752, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4dde:	80 91 94 07 	lds	r24, 0x0794
    4de2:	88 23       	and	r24, r24
    4de4:	09 f0       	breq	.+2      	; 0x4de8 <xTaskResumeAll+0x230>
    4de6:	08 cf       	rjmp	.-496    	; 0x4bf8 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    4de8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4dea:	9b 85       	ldd	r25, Y+11	; 0x0b
    4dec:	00 97       	sbiw	r24, 0x00	; 0
    4dee:	11 f0       	breq	.+4      	; 0x4df4 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    4df0:	0e 94 22 2e 	call	0x5c44	; 0x5c44 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    4df4:	80 91 50 07 	lds	r24, 0x0750
    4df8:	90 91 51 07 	lds	r25, 0x0751
    4dfc:	9a 83       	std	Y+2, r25	; 0x02
    4dfe:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    4e00:	89 81       	ldd	r24, Y+1	; 0x01
    4e02:	9a 81       	ldd	r25, Y+2	; 0x02
    4e04:	00 97       	sbiw	r24, 0x00	; 0
    4e06:	a1 f0       	breq	.+40     	; 0x4e30 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    4e08:	0e 94 a9 27 	call	0x4f52	; 0x4f52 <xTaskIncrementTick>
    4e0c:	88 23       	and	r24, r24
    4e0e:	19 f0       	breq	.+6      	; 0x4e16 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    4e10:	81 e0       	ldi	r24, 0x01	; 1
    4e12:	80 93 52 07 	sts	0x0752, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    4e16:	89 81       	ldd	r24, Y+1	; 0x01
    4e18:	9a 81       	ldd	r25, Y+2	; 0x02
    4e1a:	01 97       	sbiw	r24, 0x01	; 1
    4e1c:	9a 83       	std	Y+2, r25	; 0x02
    4e1e:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    4e20:	89 81       	ldd	r24, Y+1	; 0x01
    4e22:	9a 81       	ldd	r25, Y+2	; 0x02
    4e24:	00 97       	sbiw	r24, 0x00	; 0
    4e26:	81 f7       	brne	.-32     	; 0x4e08 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    4e28:	10 92 51 07 	sts	0x0751, r1
    4e2c:	10 92 50 07 	sts	0x0750, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    4e30:	80 91 52 07 	lds	r24, 0x0752
    4e34:	88 23       	and	r24, r24
    4e36:	21 f0       	breq	.+8      	; 0x4e40 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    4e38:	81 e0       	ldi	r24, 0x01	; 1
    4e3a:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    4e3c:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    4e40:	0f 90       	pop	r0
    4e42:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    4e44:	89 85       	ldd	r24, Y+9	; 0x09
}
    4e46:	2b 96       	adiw	r28, 0x0b	; 11
    4e48:	0f b6       	in	r0, 0x3f	; 63
    4e4a:	f8 94       	cli
    4e4c:	de bf       	out	0x3e, r29	; 62
    4e4e:	0f be       	out	0x3f, r0	; 63
    4e50:	cd bf       	out	0x3d, r28	; 61
    4e52:	cf 91       	pop	r28
    4e54:	df 91       	pop	r29
    4e56:	08 95       	ret

00004e58 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4e58:	df 93       	push	r29
    4e5a:	cf 93       	push	r28
    4e5c:	00 d0       	rcall	.+0      	; 0x4e5e <xTaskGetTickCount+0x6>
    4e5e:	cd b7       	in	r28, 0x3d	; 61
    4e60:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    4e62:	0f b6       	in	r0, 0x3f	; 63
    4e64:	f8 94       	cli
    4e66:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    4e68:	80 91 4c 07 	lds	r24, 0x074C
    4e6c:	90 91 4d 07 	lds	r25, 0x074D
    4e70:	9a 83       	std	Y+2, r25	; 0x02
    4e72:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    4e74:	0f 90       	pop	r0
    4e76:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    4e78:	89 81       	ldd	r24, Y+1	; 0x01
    4e7a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4e7c:	0f 90       	pop	r0
    4e7e:	0f 90       	pop	r0
    4e80:	cf 91       	pop	r28
    4e82:	df 91       	pop	r29
    4e84:	08 95       	ret

00004e86 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4e86:	df 93       	push	r29
    4e88:	cf 93       	push	r28
    4e8a:	00 d0       	rcall	.+0      	; 0x4e8c <xTaskGetTickCountFromISR+0x6>
    4e8c:	0f 92       	push	r0
    4e8e:	cd b7       	in	r28, 0x3d	; 61
    4e90:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4e92:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    4e94:	80 91 4c 07 	lds	r24, 0x074C
    4e98:	90 91 4d 07 	lds	r25, 0x074D
    4e9c:	9b 83       	std	Y+3, r25	; 0x03
    4e9e:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    4ea0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ea2:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4ea4:	0f 90       	pop	r0
    4ea6:	0f 90       	pop	r0
    4ea8:	0f 90       	pop	r0
    4eaa:	cf 91       	pop	r28
    4eac:	df 91       	pop	r29
    4eae:	08 95       	ret

00004eb0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4eb0:	df 93       	push	r29
    4eb2:	cf 93       	push	r28
    4eb4:	cd b7       	in	r28, 0x3d	; 61
    4eb6:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    4eb8:	80 91 4b 07 	lds	r24, 0x074B
}
    4ebc:	cf 91       	pop	r28
    4ebe:	df 91       	pop	r29
    4ec0:	08 95       	ret

00004ec2 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4ec2:	df 93       	push	r29
    4ec4:	cf 93       	push	r28
    4ec6:	00 d0       	rcall	.+0      	; 0x4ec8 <pcTaskGetName+0x6>
    4ec8:	00 d0       	rcall	.+0      	; 0x4eca <pcTaskGetName+0x8>
    4eca:	00 d0       	rcall	.+0      	; 0x4ecc <pcTaskGetName+0xa>
    4ecc:	cd b7       	in	r28, 0x3d	; 61
    4ece:	de b7       	in	r29, 0x3e	; 62
    4ed0:	9c 83       	std	Y+4, r25	; 0x04
    4ed2:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4ed4:	8b 81       	ldd	r24, Y+3	; 0x03
    4ed6:	9c 81       	ldd	r25, Y+4	; 0x04
    4ed8:	00 97       	sbiw	r24, 0x00	; 0
    4eda:	39 f4       	brne	.+14     	; 0x4eea <pcTaskGetName+0x28>
    4edc:	80 91 48 07 	lds	r24, 0x0748
    4ee0:	90 91 49 07 	lds	r25, 0x0749
    4ee4:	9e 83       	std	Y+6, r25	; 0x06
    4ee6:	8d 83       	std	Y+5, r24	; 0x05
    4ee8:	04 c0       	rjmp	.+8      	; 0x4ef2 <pcTaskGetName+0x30>
    4eea:	8b 81       	ldd	r24, Y+3	; 0x03
    4eec:	9c 81       	ldd	r25, Y+4	; 0x04
    4eee:	9e 83       	std	Y+6, r25	; 0x06
    4ef0:	8d 83       	std	Y+5, r24	; 0x05
    4ef2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ef4:	9e 81       	ldd	r25, Y+6	; 0x06
    4ef6:	9a 83       	std	Y+2, r25	; 0x02
    4ef8:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    4efa:	89 81       	ldd	r24, Y+1	; 0x01
    4efc:	9a 81       	ldd	r25, Y+2	; 0x02
    4efe:	49 96       	adiw	r24, 0x19	; 25
}
    4f00:	26 96       	adiw	r28, 0x06	; 6
    4f02:	0f b6       	in	r0, 0x3f	; 63
    4f04:	f8 94       	cli
    4f06:	de bf       	out	0x3e, r29	; 62
    4f08:	0f be       	out	0x3f, r0	; 63
    4f0a:	cd bf       	out	0x3d, r28	; 61
    4f0c:	cf 91       	pop	r28
    4f0e:	df 91       	pop	r29
    4f10:	08 95       	ret

00004f12 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    4f12:	df 93       	push	r29
    4f14:	cf 93       	push	r28
    4f16:	00 d0       	rcall	.+0      	; 0x4f18 <xTaskCatchUpTicks+0x6>
    4f18:	0f 92       	push	r0
    4f1a:	cd b7       	in	r28, 0x3d	; 61
    4f1c:	de b7       	in	r29, 0x3e	; 62
    4f1e:	9b 83       	std	Y+3, r25	; 0x03
    4f20:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    4f22:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    4f26:	20 91 50 07 	lds	r18, 0x0750
    4f2a:	30 91 51 07 	lds	r19, 0x0751
    4f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    4f30:	9b 81       	ldd	r25, Y+3	; 0x03
    4f32:	82 0f       	add	r24, r18
    4f34:	93 1f       	adc	r25, r19
    4f36:	90 93 51 07 	sts	0x0751, r25
    4f3a:	80 93 50 07 	sts	0x0750, r24
    xYieldOccurred = xTaskResumeAll();
    4f3e:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    4f42:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    4f44:	89 81       	ldd	r24, Y+1	; 0x01
}
    4f46:	0f 90       	pop	r0
    4f48:	0f 90       	pop	r0
    4f4a:	0f 90       	pop	r0
    4f4c:	cf 91       	pop	r28
    4f4e:	df 91       	pop	r29
    4f50:	08 95       	ret

00004f52 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4f52:	df 93       	push	r29
    4f54:	cf 93       	push	r28
    4f56:	cd b7       	in	r28, 0x3d	; 61
    4f58:	de b7       	in	r29, 0x3e	; 62
    4f5a:	2f 97       	sbiw	r28, 0x0f	; 15
    4f5c:	0f b6       	in	r0, 0x3f	; 63
    4f5e:	f8 94       	cli
    4f60:	de bf       	out	0x3e, r29	; 62
    4f62:	0f be       	out	0x3f, r0	; 63
    4f64:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    4f66:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4f68:	80 91 59 07 	lds	r24, 0x0759
    4f6c:	88 23       	and	r24, r24
    4f6e:	09 f0       	breq	.+2      	; 0x4f72 <xTaskIncrementTick+0x20>
    4f70:	74 c1       	rjmp	.+744    	; 0x525a <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4f72:	80 91 4c 07 	lds	r24, 0x074C
    4f76:	90 91 4d 07 	lds	r25, 0x074D
    4f7a:	01 96       	adiw	r24, 0x01	; 1
    4f7c:	9a 87       	std	Y+10, r25	; 0x0a
    4f7e:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    4f80:	89 85       	ldd	r24, Y+9	; 0x09
    4f82:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f84:	90 93 4d 07 	sts	0x074D, r25
    4f88:	80 93 4c 07 	sts	0x074C, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4f8c:	89 85       	ldd	r24, Y+9	; 0x09
    4f8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f90:	00 97       	sbiw	r24, 0x00	; 0
    4f92:	d9 f4       	brne	.+54     	; 0x4fca <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    4f94:	80 91 90 07 	lds	r24, 0x0790
    4f98:	90 91 91 07 	lds	r25, 0x0791
    4f9c:	98 87       	std	Y+8, r25	; 0x08
    4f9e:	8f 83       	std	Y+7, r24	; 0x07
    4fa0:	80 91 92 07 	lds	r24, 0x0792
    4fa4:	90 91 93 07 	lds	r25, 0x0793
    4fa8:	90 93 91 07 	sts	0x0791, r25
    4fac:	80 93 90 07 	sts	0x0790, r24
    4fb0:	8f 81       	ldd	r24, Y+7	; 0x07
    4fb2:	98 85       	ldd	r25, Y+8	; 0x08
    4fb4:	90 93 93 07 	sts	0x0793, r25
    4fb8:	80 93 92 07 	sts	0x0792, r24
    4fbc:	80 91 53 07 	lds	r24, 0x0753
    4fc0:	8f 5f       	subi	r24, 0xFF	; 255
    4fc2:	80 93 53 07 	sts	0x0753, r24
    4fc6:	0e 94 22 2e 	call	0x5c44	; 0x5c44 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    4fca:	20 91 55 07 	lds	r18, 0x0755
    4fce:	30 91 56 07 	lds	r19, 0x0756
    4fd2:	89 85       	ldd	r24, Y+9	; 0x09
    4fd4:	9a 85       	ldd	r25, Y+10	; 0x0a
    4fd6:	82 17       	cp	r24, r18
    4fd8:	93 07       	cpc	r25, r19
    4fda:	08 f4       	brcc	.+2      	; 0x4fde <xTaskIncrementTick+0x8c>
    4fdc:	1f c1       	rjmp	.+574    	; 0x521c <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4fde:	e0 91 90 07 	lds	r30, 0x0790
    4fe2:	f0 91 91 07 	lds	r31, 0x0791
    4fe6:	80 81       	ld	r24, Z
    4fe8:	88 23       	and	r24, r24
    4fea:	39 f4       	brne	.+14     	; 0x4ffa <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4fec:	8f ef       	ldi	r24, 0xFF	; 255
    4fee:	9f ef       	ldi	r25, 0xFF	; 255
    4ff0:	90 93 56 07 	sts	0x0756, r25
    4ff4:	80 93 55 07 	sts	0x0755, r24
    4ff8:	11 c1       	rjmp	.+546    	; 0x521c <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4ffa:	e0 91 90 07 	lds	r30, 0x0790
    4ffe:	f0 91 91 07 	lds	r31, 0x0791
    5002:	05 80       	ldd	r0, Z+5	; 0x05
    5004:	f6 81       	ldd	r31, Z+6	; 0x06
    5006:	e0 2d       	mov	r30, r0
    5008:	86 81       	ldd	r24, Z+6	; 0x06
    500a:	97 81       	ldd	r25, Z+7	; 0x07
    500c:	9f 87       	std	Y+15, r25	; 0x0f
    500e:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    5010:	ee 85       	ldd	r30, Y+14	; 0x0e
    5012:	ff 85       	ldd	r31, Y+15	; 0x0f
    5014:	82 81       	ldd	r24, Z+2	; 0x02
    5016:	93 81       	ldd	r25, Z+3	; 0x03
    5018:	9d 87       	std	Y+13, r25	; 0x0d
    501a:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    501c:	29 85       	ldd	r18, Y+9	; 0x09
    501e:	3a 85       	ldd	r19, Y+10	; 0x0a
    5020:	8c 85       	ldd	r24, Y+12	; 0x0c
    5022:	9d 85       	ldd	r25, Y+13	; 0x0d
    5024:	28 17       	cp	r18, r24
    5026:	39 07       	cpc	r19, r25
    5028:	38 f4       	brcc	.+14     	; 0x5038 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    502a:	8c 85       	ldd	r24, Y+12	; 0x0c
    502c:	9d 85       	ldd	r25, Y+13	; 0x0d
    502e:	90 93 56 07 	sts	0x0756, r25
    5032:	80 93 55 07 	sts	0x0755, r24
    5036:	f2 c0       	rjmp	.+484    	; 0x521c <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5038:	ee 85       	ldd	r30, Y+14	; 0x0e
    503a:	ff 85       	ldd	r31, Y+15	; 0x0f
    503c:	82 85       	ldd	r24, Z+10	; 0x0a
    503e:	93 85       	ldd	r25, Z+11	; 0x0b
    5040:	9e 83       	std	Y+6, r25	; 0x06
    5042:	8d 83       	std	Y+5, r24	; 0x05
    5044:	ee 85       	ldd	r30, Y+14	; 0x0e
    5046:	ff 85       	ldd	r31, Y+15	; 0x0f
    5048:	a4 81       	ldd	r26, Z+4	; 0x04
    504a:	b5 81       	ldd	r27, Z+5	; 0x05
    504c:	ee 85       	ldd	r30, Y+14	; 0x0e
    504e:	ff 85       	ldd	r31, Y+15	; 0x0f
    5050:	86 81       	ldd	r24, Z+6	; 0x06
    5052:	97 81       	ldd	r25, Z+7	; 0x07
    5054:	15 96       	adiw	r26, 0x05	; 5
    5056:	9c 93       	st	X, r25
    5058:	8e 93       	st	-X, r24
    505a:	14 97       	sbiw	r26, 0x04	; 4
    505c:	ee 85       	ldd	r30, Y+14	; 0x0e
    505e:	ff 85       	ldd	r31, Y+15	; 0x0f
    5060:	a6 81       	ldd	r26, Z+6	; 0x06
    5062:	b7 81       	ldd	r27, Z+7	; 0x07
    5064:	ee 85       	ldd	r30, Y+14	; 0x0e
    5066:	ff 85       	ldd	r31, Y+15	; 0x0f
    5068:	84 81       	ldd	r24, Z+4	; 0x04
    506a:	95 81       	ldd	r25, Z+5	; 0x05
    506c:	13 96       	adiw	r26, 0x03	; 3
    506e:	9c 93       	st	X, r25
    5070:	8e 93       	st	-X, r24
    5072:	12 97       	sbiw	r26, 0x02	; 2
    5074:	ed 81       	ldd	r30, Y+5	; 0x05
    5076:	fe 81       	ldd	r31, Y+6	; 0x06
    5078:	21 81       	ldd	r18, Z+1	; 0x01
    507a:	32 81       	ldd	r19, Z+2	; 0x02
    507c:	8e 85       	ldd	r24, Y+14	; 0x0e
    507e:	9f 85       	ldd	r25, Y+15	; 0x0f
    5080:	02 96       	adiw	r24, 0x02	; 2
    5082:	28 17       	cp	r18, r24
    5084:	39 07       	cpc	r19, r25
    5086:	41 f4       	brne	.+16     	; 0x5098 <xTaskIncrementTick+0x146>
    5088:	ee 85       	ldd	r30, Y+14	; 0x0e
    508a:	ff 85       	ldd	r31, Y+15	; 0x0f
    508c:	86 81       	ldd	r24, Z+6	; 0x06
    508e:	97 81       	ldd	r25, Z+7	; 0x07
    5090:	ed 81       	ldd	r30, Y+5	; 0x05
    5092:	fe 81       	ldd	r31, Y+6	; 0x06
    5094:	92 83       	std	Z+2, r25	; 0x02
    5096:	81 83       	std	Z+1, r24	; 0x01
    5098:	ee 85       	ldd	r30, Y+14	; 0x0e
    509a:	ff 85       	ldd	r31, Y+15	; 0x0f
    509c:	13 86       	std	Z+11, r1	; 0x0b
    509e:	12 86       	std	Z+10, r1	; 0x0a
    50a0:	ed 81       	ldd	r30, Y+5	; 0x05
    50a2:	fe 81       	ldd	r31, Y+6	; 0x06
    50a4:	80 81       	ld	r24, Z
    50a6:	81 50       	subi	r24, 0x01	; 1
    50a8:	ed 81       	ldd	r30, Y+5	; 0x05
    50aa:	fe 81       	ldd	r31, Y+6	; 0x06
    50ac:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    50ae:	ee 85       	ldd	r30, Y+14	; 0x0e
    50b0:	ff 85       	ldd	r31, Y+15	; 0x0f
    50b2:	84 89       	ldd	r24, Z+20	; 0x14
    50b4:	95 89       	ldd	r25, Z+21	; 0x15
    50b6:	00 97       	sbiw	r24, 0x00	; 0
    50b8:	d9 f1       	breq	.+118    	; 0x5130 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    50ba:	ee 85       	ldd	r30, Y+14	; 0x0e
    50bc:	ff 85       	ldd	r31, Y+15	; 0x0f
    50be:	84 89       	ldd	r24, Z+20	; 0x14
    50c0:	95 89       	ldd	r25, Z+21	; 0x15
    50c2:	9c 83       	std	Y+4, r25	; 0x04
    50c4:	8b 83       	std	Y+3, r24	; 0x03
    50c6:	ee 85       	ldd	r30, Y+14	; 0x0e
    50c8:	ff 85       	ldd	r31, Y+15	; 0x0f
    50ca:	a6 85       	ldd	r26, Z+14	; 0x0e
    50cc:	b7 85       	ldd	r27, Z+15	; 0x0f
    50ce:	ee 85       	ldd	r30, Y+14	; 0x0e
    50d0:	ff 85       	ldd	r31, Y+15	; 0x0f
    50d2:	80 89       	ldd	r24, Z+16	; 0x10
    50d4:	91 89       	ldd	r25, Z+17	; 0x11
    50d6:	15 96       	adiw	r26, 0x05	; 5
    50d8:	9c 93       	st	X, r25
    50da:	8e 93       	st	-X, r24
    50dc:	14 97       	sbiw	r26, 0x04	; 4
    50de:	ee 85       	ldd	r30, Y+14	; 0x0e
    50e0:	ff 85       	ldd	r31, Y+15	; 0x0f
    50e2:	a0 89       	ldd	r26, Z+16	; 0x10
    50e4:	b1 89       	ldd	r27, Z+17	; 0x11
    50e6:	ee 85       	ldd	r30, Y+14	; 0x0e
    50e8:	ff 85       	ldd	r31, Y+15	; 0x0f
    50ea:	86 85       	ldd	r24, Z+14	; 0x0e
    50ec:	97 85       	ldd	r25, Z+15	; 0x0f
    50ee:	13 96       	adiw	r26, 0x03	; 3
    50f0:	9c 93       	st	X, r25
    50f2:	8e 93       	st	-X, r24
    50f4:	12 97       	sbiw	r26, 0x02	; 2
    50f6:	eb 81       	ldd	r30, Y+3	; 0x03
    50f8:	fc 81       	ldd	r31, Y+4	; 0x04
    50fa:	21 81       	ldd	r18, Z+1	; 0x01
    50fc:	32 81       	ldd	r19, Z+2	; 0x02
    50fe:	8e 85       	ldd	r24, Y+14	; 0x0e
    5100:	9f 85       	ldd	r25, Y+15	; 0x0f
    5102:	0c 96       	adiw	r24, 0x0c	; 12
    5104:	28 17       	cp	r18, r24
    5106:	39 07       	cpc	r19, r25
    5108:	41 f4       	brne	.+16     	; 0x511a <xTaskIncrementTick+0x1c8>
    510a:	ee 85       	ldd	r30, Y+14	; 0x0e
    510c:	ff 85       	ldd	r31, Y+15	; 0x0f
    510e:	80 89       	ldd	r24, Z+16	; 0x10
    5110:	91 89       	ldd	r25, Z+17	; 0x11
    5112:	eb 81       	ldd	r30, Y+3	; 0x03
    5114:	fc 81       	ldd	r31, Y+4	; 0x04
    5116:	92 83       	std	Z+2, r25	; 0x02
    5118:	81 83       	std	Z+1, r24	; 0x01
    511a:	ee 85       	ldd	r30, Y+14	; 0x0e
    511c:	ff 85       	ldd	r31, Y+15	; 0x0f
    511e:	15 8a       	std	Z+21, r1	; 0x15
    5120:	14 8a       	std	Z+20, r1	; 0x14
    5122:	eb 81       	ldd	r30, Y+3	; 0x03
    5124:	fc 81       	ldd	r31, Y+4	; 0x04
    5126:	80 81       	ld	r24, Z
    5128:	81 50       	subi	r24, 0x01	; 1
    512a:	eb 81       	ldd	r30, Y+3	; 0x03
    512c:	fc 81       	ldd	r31, Y+4	; 0x04
    512e:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    5130:	ee 85       	ldd	r30, Y+14	; 0x0e
    5132:	ff 85       	ldd	r31, Y+15	; 0x0f
    5134:	96 89       	ldd	r25, Z+22	; 0x16
    5136:	80 91 4e 07 	lds	r24, 0x074E
    513a:	89 17       	cp	r24, r25
    513c:	28 f4       	brcc	.+10     	; 0x5148 <xTaskIncrementTick+0x1f6>
    513e:	ee 85       	ldd	r30, Y+14	; 0x0e
    5140:	ff 85       	ldd	r31, Y+15	; 0x0f
    5142:	86 89       	ldd	r24, Z+22	; 0x16
    5144:	80 93 4e 07 	sts	0x074E, r24
    5148:	ee 85       	ldd	r30, Y+14	; 0x0e
    514a:	ff 85       	ldd	r31, Y+15	; 0x0f
    514c:	86 89       	ldd	r24, Z+22	; 0x16
    514e:	28 2f       	mov	r18, r24
    5150:	30 e0       	ldi	r19, 0x00	; 0
    5152:	c9 01       	movw	r24, r18
    5154:	88 0f       	add	r24, r24
    5156:	99 1f       	adc	r25, r25
    5158:	88 0f       	add	r24, r24
    515a:	99 1f       	adc	r25, r25
    515c:	88 0f       	add	r24, r24
    515e:	99 1f       	adc	r25, r25
    5160:	82 0f       	add	r24, r18
    5162:	93 1f       	adc	r25, r19
    5164:	fc 01       	movw	r30, r24
    5166:	e6 5a       	subi	r30, 0xA6	; 166
    5168:	f8 4f       	sbci	r31, 0xF8	; 248
    516a:	81 81       	ldd	r24, Z+1	; 0x01
    516c:	92 81       	ldd	r25, Z+2	; 0x02
    516e:	9a 83       	std	Y+2, r25	; 0x02
    5170:	89 83       	std	Y+1, r24	; 0x01
    5172:	ee 85       	ldd	r30, Y+14	; 0x0e
    5174:	ff 85       	ldd	r31, Y+15	; 0x0f
    5176:	89 81       	ldd	r24, Y+1	; 0x01
    5178:	9a 81       	ldd	r25, Y+2	; 0x02
    517a:	95 83       	std	Z+5, r25	; 0x05
    517c:	84 83       	std	Z+4, r24	; 0x04
    517e:	e9 81       	ldd	r30, Y+1	; 0x01
    5180:	fa 81       	ldd	r31, Y+2	; 0x02
    5182:	84 81       	ldd	r24, Z+4	; 0x04
    5184:	95 81       	ldd	r25, Z+5	; 0x05
    5186:	ee 85       	ldd	r30, Y+14	; 0x0e
    5188:	ff 85       	ldd	r31, Y+15	; 0x0f
    518a:	97 83       	std	Z+7, r25	; 0x07
    518c:	86 83       	std	Z+6, r24	; 0x06
    518e:	e9 81       	ldd	r30, Y+1	; 0x01
    5190:	fa 81       	ldd	r31, Y+2	; 0x02
    5192:	04 80       	ldd	r0, Z+4	; 0x04
    5194:	f5 81       	ldd	r31, Z+5	; 0x05
    5196:	e0 2d       	mov	r30, r0
    5198:	8e 85       	ldd	r24, Y+14	; 0x0e
    519a:	9f 85       	ldd	r25, Y+15	; 0x0f
    519c:	02 96       	adiw	r24, 0x02	; 2
    519e:	93 83       	std	Z+3, r25	; 0x03
    51a0:	82 83       	std	Z+2, r24	; 0x02
    51a2:	8e 85       	ldd	r24, Y+14	; 0x0e
    51a4:	9f 85       	ldd	r25, Y+15	; 0x0f
    51a6:	02 96       	adiw	r24, 0x02	; 2
    51a8:	e9 81       	ldd	r30, Y+1	; 0x01
    51aa:	fa 81       	ldd	r31, Y+2	; 0x02
    51ac:	95 83       	std	Z+5, r25	; 0x05
    51ae:	84 83       	std	Z+4, r24	; 0x04
    51b0:	ee 85       	ldd	r30, Y+14	; 0x0e
    51b2:	ff 85       	ldd	r31, Y+15	; 0x0f
    51b4:	86 89       	ldd	r24, Z+22	; 0x16
    51b6:	28 2f       	mov	r18, r24
    51b8:	30 e0       	ldi	r19, 0x00	; 0
    51ba:	c9 01       	movw	r24, r18
    51bc:	88 0f       	add	r24, r24
    51be:	99 1f       	adc	r25, r25
    51c0:	88 0f       	add	r24, r24
    51c2:	99 1f       	adc	r25, r25
    51c4:	88 0f       	add	r24, r24
    51c6:	99 1f       	adc	r25, r25
    51c8:	82 0f       	add	r24, r18
    51ca:	93 1f       	adc	r25, r19
    51cc:	86 5a       	subi	r24, 0xA6	; 166
    51ce:	98 4f       	sbci	r25, 0xF8	; 248
    51d0:	ee 85       	ldd	r30, Y+14	; 0x0e
    51d2:	ff 85       	ldd	r31, Y+15	; 0x0f
    51d4:	93 87       	std	Z+11, r25	; 0x0b
    51d6:	82 87       	std	Z+10, r24	; 0x0a
    51d8:	ee 85       	ldd	r30, Y+14	; 0x0e
    51da:	ff 85       	ldd	r31, Y+15	; 0x0f
    51dc:	86 89       	ldd	r24, Z+22	; 0x16
    51de:	28 2f       	mov	r18, r24
    51e0:	30 e0       	ldi	r19, 0x00	; 0
    51e2:	c9 01       	movw	r24, r18
    51e4:	88 0f       	add	r24, r24
    51e6:	99 1f       	adc	r25, r25
    51e8:	88 0f       	add	r24, r24
    51ea:	99 1f       	adc	r25, r25
    51ec:	88 0f       	add	r24, r24
    51ee:	99 1f       	adc	r25, r25
    51f0:	82 0f       	add	r24, r18
    51f2:	93 1f       	adc	r25, r19
    51f4:	fc 01       	movw	r30, r24
    51f6:	e6 5a       	subi	r30, 0xA6	; 166
    51f8:	f8 4f       	sbci	r31, 0xF8	; 248
    51fa:	80 81       	ld	r24, Z
    51fc:	8f 5f       	subi	r24, 0xFF	; 255
    51fe:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5200:	ee 85       	ldd	r30, Y+14	; 0x0e
    5202:	ff 85       	ldd	r31, Y+15	; 0x0f
    5204:	96 89       	ldd	r25, Z+22	; 0x16
    5206:	e0 91 48 07 	lds	r30, 0x0748
    520a:	f0 91 49 07 	lds	r31, 0x0749
    520e:	86 89       	ldd	r24, Z+22	; 0x16
    5210:	98 17       	cp	r25, r24
    5212:	08 f4       	brcc	.+2      	; 0x5216 <xTaskIncrementTick+0x2c4>
    5214:	e4 ce       	rjmp	.-568    	; 0x4fde <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    5216:	81 e0       	ldi	r24, 0x01	; 1
    5218:	8b 87       	std	Y+11, r24	; 0x0b
    521a:	e1 ce       	rjmp	.-574    	; 0x4fde <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    521c:	e0 91 48 07 	lds	r30, 0x0748
    5220:	f0 91 49 07 	lds	r31, 0x0749
    5224:	86 89       	ldd	r24, Z+22	; 0x16
    5226:	28 2f       	mov	r18, r24
    5228:	30 e0       	ldi	r19, 0x00	; 0
    522a:	c9 01       	movw	r24, r18
    522c:	88 0f       	add	r24, r24
    522e:	99 1f       	adc	r25, r25
    5230:	88 0f       	add	r24, r24
    5232:	99 1f       	adc	r25, r25
    5234:	88 0f       	add	r24, r24
    5236:	99 1f       	adc	r25, r25
    5238:	82 0f       	add	r24, r18
    523a:	93 1f       	adc	r25, r19
    523c:	fc 01       	movw	r30, r24
    523e:	e6 5a       	subi	r30, 0xA6	; 166
    5240:	f8 4f       	sbci	r31, 0xF8	; 248
    5242:	80 81       	ld	r24, Z
    5244:	82 30       	cpi	r24, 0x02	; 2
    5246:	10 f0       	brcs	.+4      	; 0x524c <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    5248:	81 e0       	ldi	r24, 0x01	; 1
    524a:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    524c:	80 91 52 07 	lds	r24, 0x0752
    5250:	88 23       	and	r24, r24
    5252:	61 f0       	breq	.+24     	; 0x526c <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    5254:	81 e0       	ldi	r24, 0x01	; 1
    5256:	8b 87       	std	Y+11, r24	; 0x0b
    5258:	09 c0       	rjmp	.+18     	; 0x526c <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    525a:	80 91 50 07 	lds	r24, 0x0750
    525e:	90 91 51 07 	lds	r25, 0x0751
    5262:	01 96       	adiw	r24, 0x01	; 1
    5264:	90 93 51 07 	sts	0x0751, r25
    5268:	80 93 50 07 	sts	0x0750, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    526c:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    526e:	2f 96       	adiw	r28, 0x0f	; 15
    5270:	0f b6       	in	r0, 0x3f	; 63
    5272:	f8 94       	cli
    5274:	de bf       	out	0x3e, r29	; 62
    5276:	0f be       	out	0x3f, r0	; 63
    5278:	cd bf       	out	0x3d, r28	; 61
    527a:	cf 91       	pop	r28
    527c:	df 91       	pop	r29
    527e:	08 95       	ret

00005280 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5280:	df 93       	push	r29
    5282:	cf 93       	push	r28
    5284:	00 d0       	rcall	.+0      	; 0x5286 <vTaskSwitchContext+0x6>
    5286:	0f 92       	push	r0
    5288:	cd b7       	in	r28, 0x3d	; 61
    528a:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    528c:	80 91 59 07 	lds	r24, 0x0759
    5290:	88 23       	and	r24, r24
    5292:	21 f0       	breq	.+8      	; 0x529c <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    5294:	81 e0       	ldi	r24, 0x01	; 1
    5296:	80 93 52 07 	sts	0x0752, r24
    529a:	59 c0       	rjmp	.+178    	; 0x534e <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    529c:	10 92 52 07 	sts	0x0752, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    52a0:	80 91 4e 07 	lds	r24, 0x074E
    52a4:	8b 83       	std	Y+3, r24	; 0x03
    52a6:	03 c0       	rjmp	.+6      	; 0x52ae <vTaskSwitchContext+0x2e>
    52a8:	8b 81       	ldd	r24, Y+3	; 0x03
    52aa:	81 50       	subi	r24, 0x01	; 1
    52ac:	8b 83       	std	Y+3, r24	; 0x03
    52ae:	8b 81       	ldd	r24, Y+3	; 0x03
    52b0:	28 2f       	mov	r18, r24
    52b2:	30 e0       	ldi	r19, 0x00	; 0
    52b4:	c9 01       	movw	r24, r18
    52b6:	88 0f       	add	r24, r24
    52b8:	99 1f       	adc	r25, r25
    52ba:	88 0f       	add	r24, r24
    52bc:	99 1f       	adc	r25, r25
    52be:	88 0f       	add	r24, r24
    52c0:	99 1f       	adc	r25, r25
    52c2:	82 0f       	add	r24, r18
    52c4:	93 1f       	adc	r25, r19
    52c6:	fc 01       	movw	r30, r24
    52c8:	e6 5a       	subi	r30, 0xA6	; 166
    52ca:	f8 4f       	sbci	r31, 0xF8	; 248
    52cc:	80 81       	ld	r24, Z
    52ce:	88 23       	and	r24, r24
    52d0:	59 f3       	breq	.-42     	; 0x52a8 <vTaskSwitchContext+0x28>
    52d2:	8b 81       	ldd	r24, Y+3	; 0x03
    52d4:	28 2f       	mov	r18, r24
    52d6:	30 e0       	ldi	r19, 0x00	; 0
    52d8:	c9 01       	movw	r24, r18
    52da:	88 0f       	add	r24, r24
    52dc:	99 1f       	adc	r25, r25
    52de:	88 0f       	add	r24, r24
    52e0:	99 1f       	adc	r25, r25
    52e2:	88 0f       	add	r24, r24
    52e4:	99 1f       	adc	r25, r25
    52e6:	82 0f       	add	r24, r18
    52e8:	93 1f       	adc	r25, r19
    52ea:	86 5a       	subi	r24, 0xA6	; 166
    52ec:	98 4f       	sbci	r25, 0xF8	; 248
    52ee:	9a 83       	std	Y+2, r25	; 0x02
    52f0:	89 83       	std	Y+1, r24	; 0x01
    52f2:	e9 81       	ldd	r30, Y+1	; 0x01
    52f4:	fa 81       	ldd	r31, Y+2	; 0x02
    52f6:	01 80       	ldd	r0, Z+1	; 0x01
    52f8:	f2 81       	ldd	r31, Z+2	; 0x02
    52fa:	e0 2d       	mov	r30, r0
    52fc:	82 81       	ldd	r24, Z+2	; 0x02
    52fe:	93 81       	ldd	r25, Z+3	; 0x03
    5300:	e9 81       	ldd	r30, Y+1	; 0x01
    5302:	fa 81       	ldd	r31, Y+2	; 0x02
    5304:	92 83       	std	Z+2, r25	; 0x02
    5306:	81 83       	std	Z+1, r24	; 0x01
    5308:	e9 81       	ldd	r30, Y+1	; 0x01
    530a:	fa 81       	ldd	r31, Y+2	; 0x02
    530c:	21 81       	ldd	r18, Z+1	; 0x01
    530e:	32 81       	ldd	r19, Z+2	; 0x02
    5310:	89 81       	ldd	r24, Y+1	; 0x01
    5312:	9a 81       	ldd	r25, Y+2	; 0x02
    5314:	03 96       	adiw	r24, 0x03	; 3
    5316:	28 17       	cp	r18, r24
    5318:	39 07       	cpc	r19, r25
    531a:	59 f4       	brne	.+22     	; 0x5332 <vTaskSwitchContext+0xb2>
    531c:	e9 81       	ldd	r30, Y+1	; 0x01
    531e:	fa 81       	ldd	r31, Y+2	; 0x02
    5320:	01 80       	ldd	r0, Z+1	; 0x01
    5322:	f2 81       	ldd	r31, Z+2	; 0x02
    5324:	e0 2d       	mov	r30, r0
    5326:	82 81       	ldd	r24, Z+2	; 0x02
    5328:	93 81       	ldd	r25, Z+3	; 0x03
    532a:	e9 81       	ldd	r30, Y+1	; 0x01
    532c:	fa 81       	ldd	r31, Y+2	; 0x02
    532e:	92 83       	std	Z+2, r25	; 0x02
    5330:	81 83       	std	Z+1, r24	; 0x01
    5332:	e9 81       	ldd	r30, Y+1	; 0x01
    5334:	fa 81       	ldd	r31, Y+2	; 0x02
    5336:	01 80       	ldd	r0, Z+1	; 0x01
    5338:	f2 81       	ldd	r31, Z+2	; 0x02
    533a:	e0 2d       	mov	r30, r0
    533c:	86 81       	ldd	r24, Z+6	; 0x06
    533e:	97 81       	ldd	r25, Z+7	; 0x07
    5340:	90 93 49 07 	sts	0x0749, r25
    5344:	80 93 48 07 	sts	0x0748, r24
    5348:	8b 81       	ldd	r24, Y+3	; 0x03
    534a:	80 93 4e 07 	sts	0x074E, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    534e:	0f 90       	pop	r0
    5350:	0f 90       	pop	r0
    5352:	0f 90       	pop	r0
    5354:	cf 91       	pop	r28
    5356:	df 91       	pop	r29
    5358:	08 95       	ret

0000535a <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    535a:	df 93       	push	r29
    535c:	cf 93       	push	r28
    535e:	00 d0       	rcall	.+0      	; 0x5360 <vTaskPlaceOnEventList+0x6>
    5360:	00 d0       	rcall	.+0      	; 0x5362 <vTaskPlaceOnEventList+0x8>
    5362:	cd b7       	in	r28, 0x3d	; 61
    5364:	de b7       	in	r29, 0x3e	; 62
    5366:	9a 83       	std	Y+2, r25	; 0x02
    5368:	89 83       	std	Y+1, r24	; 0x01
    536a:	7c 83       	std	Y+4, r23	; 0x04
    536c:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    536e:	80 91 48 07 	lds	r24, 0x0748
    5372:	90 91 49 07 	lds	r25, 0x0749
    5376:	9c 01       	movw	r18, r24
    5378:	24 5f       	subi	r18, 0xF4	; 244
    537a:	3f 4f       	sbci	r19, 0xFF	; 255
    537c:	89 81       	ldd	r24, Y+1	; 0x01
    537e:	9a 81       	ldd	r25, Y+2	; 0x02
    5380:	b9 01       	movw	r22, r18
    5382:	0e 94 71 18 	call	0x30e2	; 0x30e2 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5386:	8b 81       	ldd	r24, Y+3	; 0x03
    5388:	9c 81       	ldd	r25, Y+4	; 0x04
    538a:	61 e0       	ldi	r22, 0x01	; 1
    538c:	0e 94 09 36 	call	0x6c12	; 0x6c12 <prvAddCurrentTaskToDelayedList>
}
    5390:	0f 90       	pop	r0
    5392:	0f 90       	pop	r0
    5394:	0f 90       	pop	r0
    5396:	0f 90       	pop	r0
    5398:	cf 91       	pop	r28
    539a:	df 91       	pop	r29
    539c:	08 95       	ret

0000539e <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    539e:	df 93       	push	r29
    53a0:	cf 93       	push	r28
    53a2:	cd b7       	in	r28, 0x3d	; 61
    53a4:	de b7       	in	r29, 0x3e	; 62
    53a6:	28 97       	sbiw	r28, 0x08	; 8
    53a8:	0f b6       	in	r0, 0x3f	; 63
    53aa:	f8 94       	cli
    53ac:	de bf       	out	0x3e, r29	; 62
    53ae:	0f be       	out	0x3f, r0	; 63
    53b0:	cd bf       	out	0x3d, r28	; 61
    53b2:	9c 83       	std	Y+4, r25	; 0x04
    53b4:	8b 83       	std	Y+3, r24	; 0x03
    53b6:	7e 83       	std	Y+6, r23	; 0x06
    53b8:	6d 83       	std	Y+5, r22	; 0x05
    53ba:	58 87       	std	Y+8, r21	; 0x08
    53bc:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    53be:	e0 91 48 07 	lds	r30, 0x0748
    53c2:	f0 91 49 07 	lds	r31, 0x0749
    53c6:	8d 81       	ldd	r24, Y+5	; 0x05
    53c8:	9e 81       	ldd	r25, Y+6	; 0x06
    53ca:	90 68       	ori	r25, 0x80	; 128
    53cc:	95 87       	std	Z+13, r25	; 0x0d
    53ce:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    53d0:	eb 81       	ldd	r30, Y+3	; 0x03
    53d2:	fc 81       	ldd	r31, Y+4	; 0x04
    53d4:	81 81       	ldd	r24, Z+1	; 0x01
    53d6:	92 81       	ldd	r25, Z+2	; 0x02
    53d8:	9a 83       	std	Y+2, r25	; 0x02
    53da:	89 83       	std	Y+1, r24	; 0x01
    53dc:	e0 91 48 07 	lds	r30, 0x0748
    53e0:	f0 91 49 07 	lds	r31, 0x0749
    53e4:	89 81       	ldd	r24, Y+1	; 0x01
    53e6:	9a 81       	ldd	r25, Y+2	; 0x02
    53e8:	97 87       	std	Z+15, r25	; 0x0f
    53ea:	86 87       	std	Z+14, r24	; 0x0e
    53ec:	a0 91 48 07 	lds	r26, 0x0748
    53f0:	b0 91 49 07 	lds	r27, 0x0749
    53f4:	e9 81       	ldd	r30, Y+1	; 0x01
    53f6:	fa 81       	ldd	r31, Y+2	; 0x02
    53f8:	84 81       	ldd	r24, Z+4	; 0x04
    53fa:	95 81       	ldd	r25, Z+5	; 0x05
    53fc:	51 96       	adiw	r26, 0x11	; 17
    53fe:	9c 93       	st	X, r25
    5400:	8e 93       	st	-X, r24
    5402:	50 97       	sbiw	r26, 0x10	; 16
    5404:	e9 81       	ldd	r30, Y+1	; 0x01
    5406:	fa 81       	ldd	r31, Y+2	; 0x02
    5408:	04 80       	ldd	r0, Z+4	; 0x04
    540a:	f5 81       	ldd	r31, Z+5	; 0x05
    540c:	e0 2d       	mov	r30, r0
    540e:	80 91 48 07 	lds	r24, 0x0748
    5412:	90 91 49 07 	lds	r25, 0x0749
    5416:	0c 96       	adiw	r24, 0x0c	; 12
    5418:	93 83       	std	Z+3, r25	; 0x03
    541a:	82 83       	std	Z+2, r24	; 0x02
    541c:	80 91 48 07 	lds	r24, 0x0748
    5420:	90 91 49 07 	lds	r25, 0x0749
    5424:	0c 96       	adiw	r24, 0x0c	; 12
    5426:	e9 81       	ldd	r30, Y+1	; 0x01
    5428:	fa 81       	ldd	r31, Y+2	; 0x02
    542a:	95 83       	std	Z+5, r25	; 0x05
    542c:	84 83       	std	Z+4, r24	; 0x04
    542e:	e0 91 48 07 	lds	r30, 0x0748
    5432:	f0 91 49 07 	lds	r31, 0x0749
    5436:	8b 81       	ldd	r24, Y+3	; 0x03
    5438:	9c 81       	ldd	r25, Y+4	; 0x04
    543a:	95 8b       	std	Z+21, r25	; 0x15
    543c:	84 8b       	std	Z+20, r24	; 0x14
    543e:	eb 81       	ldd	r30, Y+3	; 0x03
    5440:	fc 81       	ldd	r31, Y+4	; 0x04
    5442:	80 81       	ld	r24, Z
    5444:	8f 5f       	subi	r24, 0xFF	; 255
    5446:	eb 81       	ldd	r30, Y+3	; 0x03
    5448:	fc 81       	ldd	r31, Y+4	; 0x04
    544a:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    544c:	8f 81       	ldd	r24, Y+7	; 0x07
    544e:	98 85       	ldd	r25, Y+8	; 0x08
    5450:	61 e0       	ldi	r22, 0x01	; 1
    5452:	0e 94 09 36 	call	0x6c12	; 0x6c12 <prvAddCurrentTaskToDelayedList>
}
    5456:	28 96       	adiw	r28, 0x08	; 8
    5458:	0f b6       	in	r0, 0x3f	; 63
    545a:	f8 94       	cli
    545c:	de bf       	out	0x3e, r29	; 62
    545e:	0f be       	out	0x3f, r0	; 63
    5460:	cd bf       	out	0x3d, r28	; 61
    5462:	cf 91       	pop	r28
    5464:	df 91       	pop	r29
    5466:	08 95       	ret

00005468 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    5468:	df 93       	push	r29
    546a:	cf 93       	push	r28
    546c:	cd b7       	in	r28, 0x3d	; 61
    546e:	de b7       	in	r29, 0x3e	; 62
    5470:	27 97       	sbiw	r28, 0x07	; 7
    5472:	0f b6       	in	r0, 0x3f	; 63
    5474:	f8 94       	cli
    5476:	de bf       	out	0x3e, r29	; 62
    5478:	0f be       	out	0x3f, r0	; 63
    547a:	cd bf       	out	0x3d, r28	; 61
    547c:	9c 83       	std	Y+4, r25	; 0x04
    547e:	8b 83       	std	Y+3, r24	; 0x03
    5480:	7e 83       	std	Y+6, r23	; 0x06
    5482:	6d 83       	std	Y+5, r22	; 0x05
    5484:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5486:	eb 81       	ldd	r30, Y+3	; 0x03
    5488:	fc 81       	ldd	r31, Y+4	; 0x04
    548a:	81 81       	ldd	r24, Z+1	; 0x01
    548c:	92 81       	ldd	r25, Z+2	; 0x02
    548e:	9a 83       	std	Y+2, r25	; 0x02
    5490:	89 83       	std	Y+1, r24	; 0x01
    5492:	e0 91 48 07 	lds	r30, 0x0748
    5496:	f0 91 49 07 	lds	r31, 0x0749
    549a:	89 81       	ldd	r24, Y+1	; 0x01
    549c:	9a 81       	ldd	r25, Y+2	; 0x02
    549e:	97 87       	std	Z+15, r25	; 0x0f
    54a0:	86 87       	std	Z+14, r24	; 0x0e
    54a2:	a0 91 48 07 	lds	r26, 0x0748
    54a6:	b0 91 49 07 	lds	r27, 0x0749
    54aa:	e9 81       	ldd	r30, Y+1	; 0x01
    54ac:	fa 81       	ldd	r31, Y+2	; 0x02
    54ae:	84 81       	ldd	r24, Z+4	; 0x04
    54b0:	95 81       	ldd	r25, Z+5	; 0x05
    54b2:	51 96       	adiw	r26, 0x11	; 17
    54b4:	9c 93       	st	X, r25
    54b6:	8e 93       	st	-X, r24
    54b8:	50 97       	sbiw	r26, 0x10	; 16
    54ba:	e9 81       	ldd	r30, Y+1	; 0x01
    54bc:	fa 81       	ldd	r31, Y+2	; 0x02
    54be:	04 80       	ldd	r0, Z+4	; 0x04
    54c0:	f5 81       	ldd	r31, Z+5	; 0x05
    54c2:	e0 2d       	mov	r30, r0
    54c4:	80 91 48 07 	lds	r24, 0x0748
    54c8:	90 91 49 07 	lds	r25, 0x0749
    54cc:	0c 96       	adiw	r24, 0x0c	; 12
    54ce:	93 83       	std	Z+3, r25	; 0x03
    54d0:	82 83       	std	Z+2, r24	; 0x02
    54d2:	80 91 48 07 	lds	r24, 0x0748
    54d6:	90 91 49 07 	lds	r25, 0x0749
    54da:	0c 96       	adiw	r24, 0x0c	; 12
    54dc:	e9 81       	ldd	r30, Y+1	; 0x01
    54de:	fa 81       	ldd	r31, Y+2	; 0x02
    54e0:	95 83       	std	Z+5, r25	; 0x05
    54e2:	84 83       	std	Z+4, r24	; 0x04
    54e4:	e0 91 48 07 	lds	r30, 0x0748
    54e8:	f0 91 49 07 	lds	r31, 0x0749
    54ec:	8b 81       	ldd	r24, Y+3	; 0x03
    54ee:	9c 81       	ldd	r25, Y+4	; 0x04
    54f0:	95 8b       	std	Z+21, r25	; 0x15
    54f2:	84 8b       	std	Z+20, r24	; 0x14
    54f4:	eb 81       	ldd	r30, Y+3	; 0x03
    54f6:	fc 81       	ldd	r31, Y+4	; 0x04
    54f8:	80 81       	ld	r24, Z
    54fa:	8f 5f       	subi	r24, 0xFF	; 255
    54fc:	eb 81       	ldd	r30, Y+3	; 0x03
    54fe:	fc 81       	ldd	r31, Y+4	; 0x04
    5500:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    5502:	8f 81       	ldd	r24, Y+7	; 0x07
    5504:	88 23       	and	r24, r24
    5506:	21 f0       	breq	.+8      	; 0x5510 <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    5508:	8f ef       	ldi	r24, 0xFF	; 255
    550a:	9f ef       	ldi	r25, 0xFF	; 255
    550c:	9e 83       	std	Y+6, r25	; 0x06
    550e:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    5510:	8d 81       	ldd	r24, Y+5	; 0x05
    5512:	9e 81       	ldd	r25, Y+6	; 0x06
    5514:	6f 81       	ldd	r22, Y+7	; 0x07
    5516:	0e 94 09 36 	call	0x6c12	; 0x6c12 <prvAddCurrentTaskToDelayedList>
    }
    551a:	27 96       	adiw	r28, 0x07	; 7
    551c:	0f b6       	in	r0, 0x3f	; 63
    551e:	f8 94       	cli
    5520:	de bf       	out	0x3e, r29	; 62
    5522:	0f be       	out	0x3f, r0	; 63
    5524:	cd bf       	out	0x3d, r28	; 61
    5526:	cf 91       	pop	r28
    5528:	df 91       	pop	r29
    552a:	08 95       	ret

0000552c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    552c:	df 93       	push	r29
    552e:	cf 93       	push	r28
    5530:	cd b7       	in	r28, 0x3d	; 61
    5532:	de b7       	in	r29, 0x3e	; 62
    5534:	2d 97       	sbiw	r28, 0x0d	; 13
    5536:	0f b6       	in	r0, 0x3f	; 63
    5538:	f8 94       	cli
    553a:	de bf       	out	0x3e, r29	; 62
    553c:	0f be       	out	0x3f, r0	; 63
    553e:	cd bf       	out	0x3d, r28	; 61
    5540:	9d 87       	std	Y+13, r25	; 0x0d
    5542:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5544:	ec 85       	ldd	r30, Y+12	; 0x0c
    5546:	fd 85       	ldd	r31, Y+13	; 0x0d
    5548:	05 80       	ldd	r0, Z+5	; 0x05
    554a:	f6 81       	ldd	r31, Z+6	; 0x06
    554c:	e0 2d       	mov	r30, r0
    554e:	86 81       	ldd	r24, Z+6	; 0x06
    5550:	97 81       	ldd	r25, Z+7	; 0x07
    5552:	9b 87       	std	Y+11, r25	; 0x0b
    5554:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    5556:	ea 85       	ldd	r30, Y+10	; 0x0a
    5558:	fb 85       	ldd	r31, Y+11	; 0x0b
    555a:	84 89       	ldd	r24, Z+20	; 0x14
    555c:	95 89       	ldd	r25, Z+21	; 0x15
    555e:	98 87       	std	Y+8, r25	; 0x08
    5560:	8f 83       	std	Y+7, r24	; 0x07
    5562:	ea 85       	ldd	r30, Y+10	; 0x0a
    5564:	fb 85       	ldd	r31, Y+11	; 0x0b
    5566:	a6 85       	ldd	r26, Z+14	; 0x0e
    5568:	b7 85       	ldd	r27, Z+15	; 0x0f
    556a:	ea 85       	ldd	r30, Y+10	; 0x0a
    556c:	fb 85       	ldd	r31, Y+11	; 0x0b
    556e:	80 89       	ldd	r24, Z+16	; 0x10
    5570:	91 89       	ldd	r25, Z+17	; 0x11
    5572:	15 96       	adiw	r26, 0x05	; 5
    5574:	9c 93       	st	X, r25
    5576:	8e 93       	st	-X, r24
    5578:	14 97       	sbiw	r26, 0x04	; 4
    557a:	ea 85       	ldd	r30, Y+10	; 0x0a
    557c:	fb 85       	ldd	r31, Y+11	; 0x0b
    557e:	a0 89       	ldd	r26, Z+16	; 0x10
    5580:	b1 89       	ldd	r27, Z+17	; 0x11
    5582:	ea 85       	ldd	r30, Y+10	; 0x0a
    5584:	fb 85       	ldd	r31, Y+11	; 0x0b
    5586:	86 85       	ldd	r24, Z+14	; 0x0e
    5588:	97 85       	ldd	r25, Z+15	; 0x0f
    558a:	13 96       	adiw	r26, 0x03	; 3
    558c:	9c 93       	st	X, r25
    558e:	8e 93       	st	-X, r24
    5590:	12 97       	sbiw	r26, 0x02	; 2
    5592:	ef 81       	ldd	r30, Y+7	; 0x07
    5594:	f8 85       	ldd	r31, Y+8	; 0x08
    5596:	21 81       	ldd	r18, Z+1	; 0x01
    5598:	32 81       	ldd	r19, Z+2	; 0x02
    559a:	8a 85       	ldd	r24, Y+10	; 0x0a
    559c:	9b 85       	ldd	r25, Y+11	; 0x0b
    559e:	0c 96       	adiw	r24, 0x0c	; 12
    55a0:	28 17       	cp	r18, r24
    55a2:	39 07       	cpc	r19, r25
    55a4:	41 f4       	brne	.+16     	; 0x55b6 <xTaskRemoveFromEventList+0x8a>
    55a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    55a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    55aa:	80 89       	ldd	r24, Z+16	; 0x10
    55ac:	91 89       	ldd	r25, Z+17	; 0x11
    55ae:	ef 81       	ldd	r30, Y+7	; 0x07
    55b0:	f8 85       	ldd	r31, Y+8	; 0x08
    55b2:	92 83       	std	Z+2, r25	; 0x02
    55b4:	81 83       	std	Z+1, r24	; 0x01
    55b6:	ea 85       	ldd	r30, Y+10	; 0x0a
    55b8:	fb 85       	ldd	r31, Y+11	; 0x0b
    55ba:	15 8a       	std	Z+21, r1	; 0x15
    55bc:	14 8a       	std	Z+20, r1	; 0x14
    55be:	ef 81       	ldd	r30, Y+7	; 0x07
    55c0:	f8 85       	ldd	r31, Y+8	; 0x08
    55c2:	80 81       	ld	r24, Z
    55c4:	81 50       	subi	r24, 0x01	; 1
    55c6:	ef 81       	ldd	r30, Y+7	; 0x07
    55c8:	f8 85       	ldd	r31, Y+8	; 0x08
    55ca:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    55cc:	80 91 59 07 	lds	r24, 0x0759
    55d0:	88 23       	and	r24, r24
    55d2:	09 f0       	breq	.+2      	; 0x55d6 <xTaskRemoveFromEventList+0xaa>
    55d4:	a4 c0       	rjmp	.+328    	; 0x571e <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    55d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    55d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    55da:	82 85       	ldd	r24, Z+10	; 0x0a
    55dc:	93 85       	ldd	r25, Z+11	; 0x0b
    55de:	9e 83       	std	Y+6, r25	; 0x06
    55e0:	8d 83       	std	Y+5, r24	; 0x05
    55e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    55e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    55e6:	a4 81       	ldd	r26, Z+4	; 0x04
    55e8:	b5 81       	ldd	r27, Z+5	; 0x05
    55ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    55ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    55ee:	86 81       	ldd	r24, Z+6	; 0x06
    55f0:	97 81       	ldd	r25, Z+7	; 0x07
    55f2:	15 96       	adiw	r26, 0x05	; 5
    55f4:	9c 93       	st	X, r25
    55f6:	8e 93       	st	-X, r24
    55f8:	14 97       	sbiw	r26, 0x04	; 4
    55fa:	ea 85       	ldd	r30, Y+10	; 0x0a
    55fc:	fb 85       	ldd	r31, Y+11	; 0x0b
    55fe:	a6 81       	ldd	r26, Z+6	; 0x06
    5600:	b7 81       	ldd	r27, Z+7	; 0x07
    5602:	ea 85       	ldd	r30, Y+10	; 0x0a
    5604:	fb 85       	ldd	r31, Y+11	; 0x0b
    5606:	84 81       	ldd	r24, Z+4	; 0x04
    5608:	95 81       	ldd	r25, Z+5	; 0x05
    560a:	13 96       	adiw	r26, 0x03	; 3
    560c:	9c 93       	st	X, r25
    560e:	8e 93       	st	-X, r24
    5610:	12 97       	sbiw	r26, 0x02	; 2
    5612:	ed 81       	ldd	r30, Y+5	; 0x05
    5614:	fe 81       	ldd	r31, Y+6	; 0x06
    5616:	21 81       	ldd	r18, Z+1	; 0x01
    5618:	32 81       	ldd	r19, Z+2	; 0x02
    561a:	8a 85       	ldd	r24, Y+10	; 0x0a
    561c:	9b 85       	ldd	r25, Y+11	; 0x0b
    561e:	02 96       	adiw	r24, 0x02	; 2
    5620:	28 17       	cp	r18, r24
    5622:	39 07       	cpc	r19, r25
    5624:	41 f4       	brne	.+16     	; 0x5636 <xTaskRemoveFromEventList+0x10a>
    5626:	ea 85       	ldd	r30, Y+10	; 0x0a
    5628:	fb 85       	ldd	r31, Y+11	; 0x0b
    562a:	86 81       	ldd	r24, Z+6	; 0x06
    562c:	97 81       	ldd	r25, Z+7	; 0x07
    562e:	ed 81       	ldd	r30, Y+5	; 0x05
    5630:	fe 81       	ldd	r31, Y+6	; 0x06
    5632:	92 83       	std	Z+2, r25	; 0x02
    5634:	81 83       	std	Z+1, r24	; 0x01
    5636:	ea 85       	ldd	r30, Y+10	; 0x0a
    5638:	fb 85       	ldd	r31, Y+11	; 0x0b
    563a:	13 86       	std	Z+11, r1	; 0x0b
    563c:	12 86       	std	Z+10, r1	; 0x0a
    563e:	ed 81       	ldd	r30, Y+5	; 0x05
    5640:	fe 81       	ldd	r31, Y+6	; 0x06
    5642:	80 81       	ld	r24, Z
    5644:	81 50       	subi	r24, 0x01	; 1
    5646:	ed 81       	ldd	r30, Y+5	; 0x05
    5648:	fe 81       	ldd	r31, Y+6	; 0x06
    564a:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    564c:	ea 85       	ldd	r30, Y+10	; 0x0a
    564e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5650:	96 89       	ldd	r25, Z+22	; 0x16
    5652:	80 91 4e 07 	lds	r24, 0x074E
    5656:	89 17       	cp	r24, r25
    5658:	28 f4       	brcc	.+10     	; 0x5664 <xTaskRemoveFromEventList+0x138>
    565a:	ea 85       	ldd	r30, Y+10	; 0x0a
    565c:	fb 85       	ldd	r31, Y+11	; 0x0b
    565e:	86 89       	ldd	r24, Z+22	; 0x16
    5660:	80 93 4e 07 	sts	0x074E, r24
    5664:	ea 85       	ldd	r30, Y+10	; 0x0a
    5666:	fb 85       	ldd	r31, Y+11	; 0x0b
    5668:	86 89       	ldd	r24, Z+22	; 0x16
    566a:	28 2f       	mov	r18, r24
    566c:	30 e0       	ldi	r19, 0x00	; 0
    566e:	c9 01       	movw	r24, r18
    5670:	88 0f       	add	r24, r24
    5672:	99 1f       	adc	r25, r25
    5674:	88 0f       	add	r24, r24
    5676:	99 1f       	adc	r25, r25
    5678:	88 0f       	add	r24, r24
    567a:	99 1f       	adc	r25, r25
    567c:	82 0f       	add	r24, r18
    567e:	93 1f       	adc	r25, r19
    5680:	fc 01       	movw	r30, r24
    5682:	e6 5a       	subi	r30, 0xA6	; 166
    5684:	f8 4f       	sbci	r31, 0xF8	; 248
    5686:	81 81       	ldd	r24, Z+1	; 0x01
    5688:	92 81       	ldd	r25, Z+2	; 0x02
    568a:	9c 83       	std	Y+4, r25	; 0x04
    568c:	8b 83       	std	Y+3, r24	; 0x03
    568e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5690:	fb 85       	ldd	r31, Y+11	; 0x0b
    5692:	8b 81       	ldd	r24, Y+3	; 0x03
    5694:	9c 81       	ldd	r25, Y+4	; 0x04
    5696:	95 83       	std	Z+5, r25	; 0x05
    5698:	84 83       	std	Z+4, r24	; 0x04
    569a:	eb 81       	ldd	r30, Y+3	; 0x03
    569c:	fc 81       	ldd	r31, Y+4	; 0x04
    569e:	84 81       	ldd	r24, Z+4	; 0x04
    56a0:	95 81       	ldd	r25, Z+5	; 0x05
    56a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    56a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    56a6:	97 83       	std	Z+7, r25	; 0x07
    56a8:	86 83       	std	Z+6, r24	; 0x06
    56aa:	eb 81       	ldd	r30, Y+3	; 0x03
    56ac:	fc 81       	ldd	r31, Y+4	; 0x04
    56ae:	04 80       	ldd	r0, Z+4	; 0x04
    56b0:	f5 81       	ldd	r31, Z+5	; 0x05
    56b2:	e0 2d       	mov	r30, r0
    56b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    56b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    56b8:	02 96       	adiw	r24, 0x02	; 2
    56ba:	93 83       	std	Z+3, r25	; 0x03
    56bc:	82 83       	std	Z+2, r24	; 0x02
    56be:	8a 85       	ldd	r24, Y+10	; 0x0a
    56c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    56c2:	02 96       	adiw	r24, 0x02	; 2
    56c4:	eb 81       	ldd	r30, Y+3	; 0x03
    56c6:	fc 81       	ldd	r31, Y+4	; 0x04
    56c8:	95 83       	std	Z+5, r25	; 0x05
    56ca:	84 83       	std	Z+4, r24	; 0x04
    56cc:	ea 85       	ldd	r30, Y+10	; 0x0a
    56ce:	fb 85       	ldd	r31, Y+11	; 0x0b
    56d0:	86 89       	ldd	r24, Z+22	; 0x16
    56d2:	28 2f       	mov	r18, r24
    56d4:	30 e0       	ldi	r19, 0x00	; 0
    56d6:	c9 01       	movw	r24, r18
    56d8:	88 0f       	add	r24, r24
    56da:	99 1f       	adc	r25, r25
    56dc:	88 0f       	add	r24, r24
    56de:	99 1f       	adc	r25, r25
    56e0:	88 0f       	add	r24, r24
    56e2:	99 1f       	adc	r25, r25
    56e4:	82 0f       	add	r24, r18
    56e6:	93 1f       	adc	r25, r19
    56e8:	86 5a       	subi	r24, 0xA6	; 166
    56ea:	98 4f       	sbci	r25, 0xF8	; 248
    56ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    56ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    56f0:	93 87       	std	Z+11, r25	; 0x0b
    56f2:	82 87       	std	Z+10, r24	; 0x0a
    56f4:	ea 85       	ldd	r30, Y+10	; 0x0a
    56f6:	fb 85       	ldd	r31, Y+11	; 0x0b
    56f8:	86 89       	ldd	r24, Z+22	; 0x16
    56fa:	28 2f       	mov	r18, r24
    56fc:	30 e0       	ldi	r19, 0x00	; 0
    56fe:	c9 01       	movw	r24, r18
    5700:	88 0f       	add	r24, r24
    5702:	99 1f       	adc	r25, r25
    5704:	88 0f       	add	r24, r24
    5706:	99 1f       	adc	r25, r25
    5708:	88 0f       	add	r24, r24
    570a:	99 1f       	adc	r25, r25
    570c:	82 0f       	add	r24, r18
    570e:	93 1f       	adc	r25, r19
    5710:	fc 01       	movw	r30, r24
    5712:	e6 5a       	subi	r30, 0xA6	; 166
    5714:	f8 4f       	sbci	r31, 0xF8	; 248
    5716:	80 81       	ld	r24, Z
    5718:	8f 5f       	subi	r24, 0xFF	; 255
    571a:	80 83       	st	Z, r24
    571c:	30 c0       	rjmp	.+96     	; 0x577e <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    571e:	80 91 95 07 	lds	r24, 0x0795
    5722:	90 91 96 07 	lds	r25, 0x0796
    5726:	9a 83       	std	Y+2, r25	; 0x02
    5728:	89 83       	std	Y+1, r24	; 0x01
    572a:	ea 85       	ldd	r30, Y+10	; 0x0a
    572c:	fb 85       	ldd	r31, Y+11	; 0x0b
    572e:	89 81       	ldd	r24, Y+1	; 0x01
    5730:	9a 81       	ldd	r25, Y+2	; 0x02
    5732:	97 87       	std	Z+15, r25	; 0x0f
    5734:	86 87       	std	Z+14, r24	; 0x0e
    5736:	e9 81       	ldd	r30, Y+1	; 0x01
    5738:	fa 81       	ldd	r31, Y+2	; 0x02
    573a:	84 81       	ldd	r24, Z+4	; 0x04
    573c:	95 81       	ldd	r25, Z+5	; 0x05
    573e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5740:	fb 85       	ldd	r31, Y+11	; 0x0b
    5742:	91 8b       	std	Z+17, r25	; 0x11
    5744:	80 8b       	std	Z+16, r24	; 0x10
    5746:	e9 81       	ldd	r30, Y+1	; 0x01
    5748:	fa 81       	ldd	r31, Y+2	; 0x02
    574a:	04 80       	ldd	r0, Z+4	; 0x04
    574c:	f5 81       	ldd	r31, Z+5	; 0x05
    574e:	e0 2d       	mov	r30, r0
    5750:	8a 85       	ldd	r24, Y+10	; 0x0a
    5752:	9b 85       	ldd	r25, Y+11	; 0x0b
    5754:	0c 96       	adiw	r24, 0x0c	; 12
    5756:	93 83       	std	Z+3, r25	; 0x03
    5758:	82 83       	std	Z+2, r24	; 0x02
    575a:	8a 85       	ldd	r24, Y+10	; 0x0a
    575c:	9b 85       	ldd	r25, Y+11	; 0x0b
    575e:	0c 96       	adiw	r24, 0x0c	; 12
    5760:	e9 81       	ldd	r30, Y+1	; 0x01
    5762:	fa 81       	ldd	r31, Y+2	; 0x02
    5764:	95 83       	std	Z+5, r25	; 0x05
    5766:	84 83       	std	Z+4, r24	; 0x04
    5768:	ea 85       	ldd	r30, Y+10	; 0x0a
    576a:	fb 85       	ldd	r31, Y+11	; 0x0b
    576c:	84 e9       	ldi	r24, 0x94	; 148
    576e:	97 e0       	ldi	r25, 0x07	; 7
    5770:	95 8b       	std	Z+21, r25	; 0x15
    5772:	84 8b       	std	Z+20, r24	; 0x14
    5774:	80 91 94 07 	lds	r24, 0x0794
    5778:	8f 5f       	subi	r24, 0xFF	; 255
    577a:	80 93 94 07 	sts	0x0794, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    577e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5780:	fb 85       	ldd	r31, Y+11	; 0x0b
    5782:	96 89       	ldd	r25, Z+22	; 0x16
    5784:	e0 91 48 07 	lds	r30, 0x0748
    5788:	f0 91 49 07 	lds	r31, 0x0749
    578c:	86 89       	ldd	r24, Z+22	; 0x16
    578e:	89 17       	cp	r24, r25
    5790:	30 f4       	brcc	.+12     	; 0x579e <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    5792:	81 e0       	ldi	r24, 0x01	; 1
    5794:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    5796:	81 e0       	ldi	r24, 0x01	; 1
    5798:	80 93 52 07 	sts	0x0752, r24
    579c:	01 c0       	rjmp	.+2      	; 0x57a0 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    579e:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    57a0:	89 85       	ldd	r24, Y+9	; 0x09
}
    57a2:	2d 96       	adiw	r28, 0x0d	; 13
    57a4:	0f b6       	in	r0, 0x3f	; 63
    57a6:	f8 94       	cli
    57a8:	de bf       	out	0x3e, r29	; 62
    57aa:	0f be       	out	0x3f, r0	; 63
    57ac:	cd bf       	out	0x3d, r28	; 61
    57ae:	cf 91       	pop	r28
    57b0:	df 91       	pop	r29
    57b2:	08 95       	ret

000057b4 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    57b4:	df 93       	push	r29
    57b6:	cf 93       	push	r28
    57b8:	cd b7       	in	r28, 0x3d	; 61
    57ba:	de b7       	in	r29, 0x3e	; 62
    57bc:	2c 97       	sbiw	r28, 0x0c	; 12
    57be:	0f b6       	in	r0, 0x3f	; 63
    57c0:	f8 94       	cli
    57c2:	de bf       	out	0x3e, r29	; 62
    57c4:	0f be       	out	0x3f, r0	; 63
    57c6:	cd bf       	out	0x3d, r28	; 61
    57c8:	9a 87       	std	Y+10, r25	; 0x0a
    57ca:	89 87       	std	Y+9, r24	; 0x09
    57cc:	7c 87       	std	Y+12, r23	; 0x0c
    57ce:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    57d0:	8b 85       	ldd	r24, Y+11	; 0x0b
    57d2:	9c 85       	ldd	r25, Y+12	; 0x0c
    57d4:	90 68       	ori	r25, 0x80	; 128
    57d6:	e9 85       	ldd	r30, Y+9	; 0x09
    57d8:	fa 85       	ldd	r31, Y+10	; 0x0a
    57da:	91 83       	std	Z+1, r25	; 0x01
    57dc:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    57de:	e9 85       	ldd	r30, Y+9	; 0x09
    57e0:	fa 85       	ldd	r31, Y+10	; 0x0a
    57e2:	86 81       	ldd	r24, Z+6	; 0x06
    57e4:	97 81       	ldd	r25, Z+7	; 0x07
    57e6:	98 87       	std	Y+8, r25	; 0x08
    57e8:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    57ea:	e9 85       	ldd	r30, Y+9	; 0x09
    57ec:	fa 85       	ldd	r31, Y+10	; 0x0a
    57ee:	80 85       	ldd	r24, Z+8	; 0x08
    57f0:	91 85       	ldd	r25, Z+9	; 0x09
    57f2:	9e 83       	std	Y+6, r25	; 0x06
    57f4:	8d 83       	std	Y+5, r24	; 0x05
    57f6:	e9 85       	ldd	r30, Y+9	; 0x09
    57f8:	fa 85       	ldd	r31, Y+10	; 0x0a
    57fa:	a2 81       	ldd	r26, Z+2	; 0x02
    57fc:	b3 81       	ldd	r27, Z+3	; 0x03
    57fe:	e9 85       	ldd	r30, Y+9	; 0x09
    5800:	fa 85       	ldd	r31, Y+10	; 0x0a
    5802:	84 81       	ldd	r24, Z+4	; 0x04
    5804:	95 81       	ldd	r25, Z+5	; 0x05
    5806:	15 96       	adiw	r26, 0x05	; 5
    5808:	9c 93       	st	X, r25
    580a:	8e 93       	st	-X, r24
    580c:	14 97       	sbiw	r26, 0x04	; 4
    580e:	e9 85       	ldd	r30, Y+9	; 0x09
    5810:	fa 85       	ldd	r31, Y+10	; 0x0a
    5812:	a4 81       	ldd	r26, Z+4	; 0x04
    5814:	b5 81       	ldd	r27, Z+5	; 0x05
    5816:	e9 85       	ldd	r30, Y+9	; 0x09
    5818:	fa 85       	ldd	r31, Y+10	; 0x0a
    581a:	82 81       	ldd	r24, Z+2	; 0x02
    581c:	93 81       	ldd	r25, Z+3	; 0x03
    581e:	13 96       	adiw	r26, 0x03	; 3
    5820:	9c 93       	st	X, r25
    5822:	8e 93       	st	-X, r24
    5824:	12 97       	sbiw	r26, 0x02	; 2
    5826:	ed 81       	ldd	r30, Y+5	; 0x05
    5828:	fe 81       	ldd	r31, Y+6	; 0x06
    582a:	21 81       	ldd	r18, Z+1	; 0x01
    582c:	32 81       	ldd	r19, Z+2	; 0x02
    582e:	89 85       	ldd	r24, Y+9	; 0x09
    5830:	9a 85       	ldd	r25, Y+10	; 0x0a
    5832:	28 17       	cp	r18, r24
    5834:	39 07       	cpc	r19, r25
    5836:	41 f4       	brne	.+16     	; 0x5848 <vTaskRemoveFromUnorderedEventList+0x94>
    5838:	e9 85       	ldd	r30, Y+9	; 0x09
    583a:	fa 85       	ldd	r31, Y+10	; 0x0a
    583c:	84 81       	ldd	r24, Z+4	; 0x04
    583e:	95 81       	ldd	r25, Z+5	; 0x05
    5840:	ed 81       	ldd	r30, Y+5	; 0x05
    5842:	fe 81       	ldd	r31, Y+6	; 0x06
    5844:	92 83       	std	Z+2, r25	; 0x02
    5846:	81 83       	std	Z+1, r24	; 0x01
    5848:	e9 85       	ldd	r30, Y+9	; 0x09
    584a:	fa 85       	ldd	r31, Y+10	; 0x0a
    584c:	11 86       	std	Z+9, r1	; 0x09
    584e:	10 86       	std	Z+8, r1	; 0x08
    5850:	ed 81       	ldd	r30, Y+5	; 0x05
    5852:	fe 81       	ldd	r31, Y+6	; 0x06
    5854:	80 81       	ld	r24, Z
    5856:	81 50       	subi	r24, 0x01	; 1
    5858:	ed 81       	ldd	r30, Y+5	; 0x05
    585a:	fe 81       	ldd	r31, Y+6	; 0x06
    585c:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    585e:	ef 81       	ldd	r30, Y+7	; 0x07
    5860:	f8 85       	ldd	r31, Y+8	; 0x08
    5862:	82 85       	ldd	r24, Z+10	; 0x0a
    5864:	93 85       	ldd	r25, Z+11	; 0x0b
    5866:	9c 83       	std	Y+4, r25	; 0x04
    5868:	8b 83       	std	Y+3, r24	; 0x03
    586a:	ef 81       	ldd	r30, Y+7	; 0x07
    586c:	f8 85       	ldd	r31, Y+8	; 0x08
    586e:	a4 81       	ldd	r26, Z+4	; 0x04
    5870:	b5 81       	ldd	r27, Z+5	; 0x05
    5872:	ef 81       	ldd	r30, Y+7	; 0x07
    5874:	f8 85       	ldd	r31, Y+8	; 0x08
    5876:	86 81       	ldd	r24, Z+6	; 0x06
    5878:	97 81       	ldd	r25, Z+7	; 0x07
    587a:	15 96       	adiw	r26, 0x05	; 5
    587c:	9c 93       	st	X, r25
    587e:	8e 93       	st	-X, r24
    5880:	14 97       	sbiw	r26, 0x04	; 4
    5882:	ef 81       	ldd	r30, Y+7	; 0x07
    5884:	f8 85       	ldd	r31, Y+8	; 0x08
    5886:	a6 81       	ldd	r26, Z+6	; 0x06
    5888:	b7 81       	ldd	r27, Z+7	; 0x07
    588a:	ef 81       	ldd	r30, Y+7	; 0x07
    588c:	f8 85       	ldd	r31, Y+8	; 0x08
    588e:	84 81       	ldd	r24, Z+4	; 0x04
    5890:	95 81       	ldd	r25, Z+5	; 0x05
    5892:	13 96       	adiw	r26, 0x03	; 3
    5894:	9c 93       	st	X, r25
    5896:	8e 93       	st	-X, r24
    5898:	12 97       	sbiw	r26, 0x02	; 2
    589a:	eb 81       	ldd	r30, Y+3	; 0x03
    589c:	fc 81       	ldd	r31, Y+4	; 0x04
    589e:	21 81       	ldd	r18, Z+1	; 0x01
    58a0:	32 81       	ldd	r19, Z+2	; 0x02
    58a2:	8f 81       	ldd	r24, Y+7	; 0x07
    58a4:	98 85       	ldd	r25, Y+8	; 0x08
    58a6:	02 96       	adiw	r24, 0x02	; 2
    58a8:	28 17       	cp	r18, r24
    58aa:	39 07       	cpc	r19, r25
    58ac:	41 f4       	brne	.+16     	; 0x58be <vTaskRemoveFromUnorderedEventList+0x10a>
    58ae:	ef 81       	ldd	r30, Y+7	; 0x07
    58b0:	f8 85       	ldd	r31, Y+8	; 0x08
    58b2:	86 81       	ldd	r24, Z+6	; 0x06
    58b4:	97 81       	ldd	r25, Z+7	; 0x07
    58b6:	eb 81       	ldd	r30, Y+3	; 0x03
    58b8:	fc 81       	ldd	r31, Y+4	; 0x04
    58ba:	92 83       	std	Z+2, r25	; 0x02
    58bc:	81 83       	std	Z+1, r24	; 0x01
    58be:	ef 81       	ldd	r30, Y+7	; 0x07
    58c0:	f8 85       	ldd	r31, Y+8	; 0x08
    58c2:	13 86       	std	Z+11, r1	; 0x0b
    58c4:	12 86       	std	Z+10, r1	; 0x0a
    58c6:	eb 81       	ldd	r30, Y+3	; 0x03
    58c8:	fc 81       	ldd	r31, Y+4	; 0x04
    58ca:	80 81       	ld	r24, Z
    58cc:	81 50       	subi	r24, 0x01	; 1
    58ce:	eb 81       	ldd	r30, Y+3	; 0x03
    58d0:	fc 81       	ldd	r31, Y+4	; 0x04
    58d2:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    58d4:	ef 81       	ldd	r30, Y+7	; 0x07
    58d6:	f8 85       	ldd	r31, Y+8	; 0x08
    58d8:	96 89       	ldd	r25, Z+22	; 0x16
    58da:	80 91 4e 07 	lds	r24, 0x074E
    58de:	89 17       	cp	r24, r25
    58e0:	28 f4       	brcc	.+10     	; 0x58ec <vTaskRemoveFromUnorderedEventList+0x138>
    58e2:	ef 81       	ldd	r30, Y+7	; 0x07
    58e4:	f8 85       	ldd	r31, Y+8	; 0x08
    58e6:	86 89       	ldd	r24, Z+22	; 0x16
    58e8:	80 93 4e 07 	sts	0x074E, r24
    58ec:	ef 81       	ldd	r30, Y+7	; 0x07
    58ee:	f8 85       	ldd	r31, Y+8	; 0x08
    58f0:	86 89       	ldd	r24, Z+22	; 0x16
    58f2:	28 2f       	mov	r18, r24
    58f4:	30 e0       	ldi	r19, 0x00	; 0
    58f6:	c9 01       	movw	r24, r18
    58f8:	88 0f       	add	r24, r24
    58fa:	99 1f       	adc	r25, r25
    58fc:	88 0f       	add	r24, r24
    58fe:	99 1f       	adc	r25, r25
    5900:	88 0f       	add	r24, r24
    5902:	99 1f       	adc	r25, r25
    5904:	82 0f       	add	r24, r18
    5906:	93 1f       	adc	r25, r19
    5908:	fc 01       	movw	r30, r24
    590a:	e6 5a       	subi	r30, 0xA6	; 166
    590c:	f8 4f       	sbci	r31, 0xF8	; 248
    590e:	81 81       	ldd	r24, Z+1	; 0x01
    5910:	92 81       	ldd	r25, Z+2	; 0x02
    5912:	9a 83       	std	Y+2, r25	; 0x02
    5914:	89 83       	std	Y+1, r24	; 0x01
    5916:	ef 81       	ldd	r30, Y+7	; 0x07
    5918:	f8 85       	ldd	r31, Y+8	; 0x08
    591a:	89 81       	ldd	r24, Y+1	; 0x01
    591c:	9a 81       	ldd	r25, Y+2	; 0x02
    591e:	95 83       	std	Z+5, r25	; 0x05
    5920:	84 83       	std	Z+4, r24	; 0x04
    5922:	e9 81       	ldd	r30, Y+1	; 0x01
    5924:	fa 81       	ldd	r31, Y+2	; 0x02
    5926:	84 81       	ldd	r24, Z+4	; 0x04
    5928:	95 81       	ldd	r25, Z+5	; 0x05
    592a:	ef 81       	ldd	r30, Y+7	; 0x07
    592c:	f8 85       	ldd	r31, Y+8	; 0x08
    592e:	97 83       	std	Z+7, r25	; 0x07
    5930:	86 83       	std	Z+6, r24	; 0x06
    5932:	e9 81       	ldd	r30, Y+1	; 0x01
    5934:	fa 81       	ldd	r31, Y+2	; 0x02
    5936:	04 80       	ldd	r0, Z+4	; 0x04
    5938:	f5 81       	ldd	r31, Z+5	; 0x05
    593a:	e0 2d       	mov	r30, r0
    593c:	8f 81       	ldd	r24, Y+7	; 0x07
    593e:	98 85       	ldd	r25, Y+8	; 0x08
    5940:	02 96       	adiw	r24, 0x02	; 2
    5942:	93 83       	std	Z+3, r25	; 0x03
    5944:	82 83       	std	Z+2, r24	; 0x02
    5946:	8f 81       	ldd	r24, Y+7	; 0x07
    5948:	98 85       	ldd	r25, Y+8	; 0x08
    594a:	02 96       	adiw	r24, 0x02	; 2
    594c:	e9 81       	ldd	r30, Y+1	; 0x01
    594e:	fa 81       	ldd	r31, Y+2	; 0x02
    5950:	95 83       	std	Z+5, r25	; 0x05
    5952:	84 83       	std	Z+4, r24	; 0x04
    5954:	ef 81       	ldd	r30, Y+7	; 0x07
    5956:	f8 85       	ldd	r31, Y+8	; 0x08
    5958:	86 89       	ldd	r24, Z+22	; 0x16
    595a:	28 2f       	mov	r18, r24
    595c:	30 e0       	ldi	r19, 0x00	; 0
    595e:	c9 01       	movw	r24, r18
    5960:	88 0f       	add	r24, r24
    5962:	99 1f       	adc	r25, r25
    5964:	88 0f       	add	r24, r24
    5966:	99 1f       	adc	r25, r25
    5968:	88 0f       	add	r24, r24
    596a:	99 1f       	adc	r25, r25
    596c:	82 0f       	add	r24, r18
    596e:	93 1f       	adc	r25, r19
    5970:	86 5a       	subi	r24, 0xA6	; 166
    5972:	98 4f       	sbci	r25, 0xF8	; 248
    5974:	ef 81       	ldd	r30, Y+7	; 0x07
    5976:	f8 85       	ldd	r31, Y+8	; 0x08
    5978:	93 87       	std	Z+11, r25	; 0x0b
    597a:	82 87       	std	Z+10, r24	; 0x0a
    597c:	ef 81       	ldd	r30, Y+7	; 0x07
    597e:	f8 85       	ldd	r31, Y+8	; 0x08
    5980:	86 89       	ldd	r24, Z+22	; 0x16
    5982:	28 2f       	mov	r18, r24
    5984:	30 e0       	ldi	r19, 0x00	; 0
    5986:	c9 01       	movw	r24, r18
    5988:	88 0f       	add	r24, r24
    598a:	99 1f       	adc	r25, r25
    598c:	88 0f       	add	r24, r24
    598e:	99 1f       	adc	r25, r25
    5990:	88 0f       	add	r24, r24
    5992:	99 1f       	adc	r25, r25
    5994:	82 0f       	add	r24, r18
    5996:	93 1f       	adc	r25, r19
    5998:	fc 01       	movw	r30, r24
    599a:	e6 5a       	subi	r30, 0xA6	; 166
    599c:	f8 4f       	sbci	r31, 0xF8	; 248
    599e:	80 81       	ld	r24, Z
    59a0:	8f 5f       	subi	r24, 0xFF	; 255
    59a2:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    59a4:	ef 81       	ldd	r30, Y+7	; 0x07
    59a6:	f8 85       	ldd	r31, Y+8	; 0x08
    59a8:	96 89       	ldd	r25, Z+22	; 0x16
    59aa:	e0 91 48 07 	lds	r30, 0x0748
    59ae:	f0 91 49 07 	lds	r31, 0x0749
    59b2:	86 89       	ldd	r24, Z+22	; 0x16
    59b4:	89 17       	cp	r24, r25
    59b6:	18 f4       	brcc	.+6      	; 0x59be <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    59b8:	81 e0       	ldi	r24, 0x01	; 1
    59ba:	80 93 52 07 	sts	0x0752, r24
    }
}
    59be:	2c 96       	adiw	r28, 0x0c	; 12
    59c0:	0f b6       	in	r0, 0x3f	; 63
    59c2:	f8 94       	cli
    59c4:	de bf       	out	0x3e, r29	; 62
    59c6:	0f be       	out	0x3f, r0	; 63
    59c8:	cd bf       	out	0x3d, r28	; 61
    59ca:	cf 91       	pop	r28
    59cc:	df 91       	pop	r29
    59ce:	08 95       	ret

000059d0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    59d0:	df 93       	push	r29
    59d2:	cf 93       	push	r28
    59d4:	00 d0       	rcall	.+0      	; 0x59d6 <vTaskSetTimeOutState+0x6>
    59d6:	cd b7       	in	r28, 0x3d	; 61
    59d8:	de b7       	in	r29, 0x3e	; 62
    59da:	9a 83       	std	Y+2, r25	; 0x02
    59dc:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    59de:	0f b6       	in	r0, 0x3f	; 63
    59e0:	f8 94       	cli
    59e2:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    59e4:	80 91 53 07 	lds	r24, 0x0753
    59e8:	e9 81       	ldd	r30, Y+1	; 0x01
    59ea:	fa 81       	ldd	r31, Y+2	; 0x02
    59ec:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    59ee:	80 91 4c 07 	lds	r24, 0x074C
    59f2:	90 91 4d 07 	lds	r25, 0x074D
    59f6:	e9 81       	ldd	r30, Y+1	; 0x01
    59f8:	fa 81       	ldd	r31, Y+2	; 0x02
    59fa:	92 83       	std	Z+2, r25	; 0x02
    59fc:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    59fe:	0f 90       	pop	r0
    5a00:	0f be       	out	0x3f, r0	; 63
}
    5a02:	0f 90       	pop	r0
    5a04:	0f 90       	pop	r0
    5a06:	cf 91       	pop	r28
    5a08:	df 91       	pop	r29
    5a0a:	08 95       	ret

00005a0c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5a0c:	df 93       	push	r29
    5a0e:	cf 93       	push	r28
    5a10:	00 d0       	rcall	.+0      	; 0x5a12 <vTaskInternalSetTimeOutState+0x6>
    5a12:	cd b7       	in	r28, 0x3d	; 61
    5a14:	de b7       	in	r29, 0x3e	; 62
    5a16:	9a 83       	std	Y+2, r25	; 0x02
    5a18:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    5a1a:	80 91 53 07 	lds	r24, 0x0753
    5a1e:	e9 81       	ldd	r30, Y+1	; 0x01
    5a20:	fa 81       	ldd	r31, Y+2	; 0x02
    5a22:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    5a24:	80 91 4c 07 	lds	r24, 0x074C
    5a28:	90 91 4d 07 	lds	r25, 0x074D
    5a2c:	e9 81       	ldd	r30, Y+1	; 0x01
    5a2e:	fa 81       	ldd	r31, Y+2	; 0x02
    5a30:	92 83       	std	Z+2, r25	; 0x02
    5a32:	81 83       	std	Z+1, r24	; 0x01
}
    5a34:	0f 90       	pop	r0
    5a36:	0f 90       	pop	r0
    5a38:	cf 91       	pop	r28
    5a3a:	df 91       	pop	r29
    5a3c:	08 95       	ret

00005a3e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    5a3e:	df 93       	push	r29
    5a40:	cf 93       	push	r28
    5a42:	cd b7       	in	r28, 0x3d	; 61
    5a44:	de b7       	in	r29, 0x3e	; 62
    5a46:	29 97       	sbiw	r28, 0x09	; 9
    5a48:	0f b6       	in	r0, 0x3f	; 63
    5a4a:	f8 94       	cli
    5a4c:	de bf       	out	0x3e, r29	; 62
    5a4e:	0f be       	out	0x3f, r0	; 63
    5a50:	cd bf       	out	0x3d, r28	; 61
    5a52:	9f 83       	std	Y+7, r25	; 0x07
    5a54:	8e 83       	std	Y+6, r24	; 0x06
    5a56:	79 87       	std	Y+9, r23	; 0x09
    5a58:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    5a5a:	0f b6       	in	r0, 0x3f	; 63
    5a5c:	f8 94       	cli
    5a5e:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    5a60:	80 91 4c 07 	lds	r24, 0x074C
    5a64:	90 91 4d 07 	lds	r25, 0x074D
    5a68:	9c 83       	std	Y+4, r25	; 0x04
    5a6a:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    5a6c:	ee 81       	ldd	r30, Y+6	; 0x06
    5a6e:	ff 81       	ldd	r31, Y+7	; 0x07
    5a70:	21 81       	ldd	r18, Z+1	; 0x01
    5a72:	32 81       	ldd	r19, Z+2	; 0x02
    5a74:	8b 81       	ldd	r24, Y+3	; 0x03
    5a76:	9c 81       	ldd	r25, Y+4	; 0x04
    5a78:	82 1b       	sub	r24, r18
    5a7a:	93 0b       	sbc	r25, r19
    5a7c:	9a 83       	std	Y+2, r25	; 0x02
    5a7e:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5a80:	ee 81       	ldd	r30, Y+6	; 0x06
    5a82:	ff 81       	ldd	r31, Y+7	; 0x07
    5a84:	90 81       	ld	r25, Z
    5a86:	80 91 53 07 	lds	r24, 0x0753
    5a8a:	98 17       	cp	r25, r24
    5a8c:	81 f0       	breq	.+32     	; 0x5aae <xTaskCheckForTimeOut+0x70>
    5a8e:	ee 81       	ldd	r30, Y+6	; 0x06
    5a90:	ff 81       	ldd	r31, Y+7	; 0x07
    5a92:	21 81       	ldd	r18, Z+1	; 0x01
    5a94:	32 81       	ldd	r19, Z+2	; 0x02
    5a96:	8b 81       	ldd	r24, Y+3	; 0x03
    5a98:	9c 81       	ldd	r25, Y+4	; 0x04
    5a9a:	82 17       	cp	r24, r18
    5a9c:	93 07       	cpc	r25, r19
    5a9e:	38 f0       	brcs	.+14     	; 0x5aae <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    5aa0:	81 e0       	ldi	r24, 0x01	; 1
    5aa2:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    5aa4:	e8 85       	ldd	r30, Y+8	; 0x08
    5aa6:	f9 85       	ldd	r31, Y+9	; 0x09
    5aa8:	11 82       	std	Z+1, r1	; 0x01
    5aaa:	10 82       	st	Z, r1
    5aac:	23 c0       	rjmp	.+70     	; 0x5af4 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5aae:	e8 85       	ldd	r30, Y+8	; 0x08
    5ab0:	f9 85       	ldd	r31, Y+9	; 0x09
    5ab2:	20 81       	ld	r18, Z
    5ab4:	31 81       	ldd	r19, Z+1	; 0x01
    5ab6:	89 81       	ldd	r24, Y+1	; 0x01
    5ab8:	9a 81       	ldd	r25, Y+2	; 0x02
    5aba:	82 17       	cp	r24, r18
    5abc:	93 07       	cpc	r25, r19
    5abe:	a0 f4       	brcc	.+40     	; 0x5ae8 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    5ac0:	e8 85       	ldd	r30, Y+8	; 0x08
    5ac2:	f9 85       	ldd	r31, Y+9	; 0x09
    5ac4:	20 81       	ld	r18, Z
    5ac6:	31 81       	ldd	r19, Z+1	; 0x01
    5ac8:	89 81       	ldd	r24, Y+1	; 0x01
    5aca:	9a 81       	ldd	r25, Y+2	; 0x02
    5acc:	a9 01       	movw	r20, r18
    5ace:	48 1b       	sub	r20, r24
    5ad0:	59 0b       	sbc	r21, r25
    5ad2:	ca 01       	movw	r24, r20
    5ad4:	e8 85       	ldd	r30, Y+8	; 0x08
    5ad6:	f9 85       	ldd	r31, Y+9	; 0x09
    5ad8:	91 83       	std	Z+1, r25	; 0x01
    5ada:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    5adc:	8e 81       	ldd	r24, Y+6	; 0x06
    5ade:	9f 81       	ldd	r25, Y+7	; 0x07
    5ae0:	0e 94 06 2d 	call	0x5a0c	; 0x5a0c <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    5ae4:	1d 82       	std	Y+5, r1	; 0x05
    5ae6:	06 c0       	rjmp	.+12     	; 0x5af4 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    5ae8:	e8 85       	ldd	r30, Y+8	; 0x08
    5aea:	f9 85       	ldd	r31, Y+9	; 0x09
    5aec:	11 82       	std	Z+1, r1	; 0x01
    5aee:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    5af0:	81 e0       	ldi	r24, 0x01	; 1
    5af2:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    5af4:	0f 90       	pop	r0
    5af6:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    5af8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5afa:	29 96       	adiw	r28, 0x09	; 9
    5afc:	0f b6       	in	r0, 0x3f	; 63
    5afe:	f8 94       	cli
    5b00:	de bf       	out	0x3e, r29	; 62
    5b02:	0f be       	out	0x3f, r0	; 63
    5b04:	cd bf       	out	0x3d, r28	; 61
    5b06:	cf 91       	pop	r28
    5b08:	df 91       	pop	r29
    5b0a:	08 95       	ret

00005b0c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5b0c:	df 93       	push	r29
    5b0e:	cf 93       	push	r28
    5b10:	cd b7       	in	r28, 0x3d	; 61
    5b12:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    5b14:	81 e0       	ldi	r24, 0x01	; 1
    5b16:	80 93 52 07 	sts	0x0752, r24
}
    5b1a:	cf 91       	pop	r28
    5b1c:	df 91       	pop	r29
    5b1e:	08 95       	ret

00005b20 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5b20:	df 93       	push	r29
    5b22:	cf 93       	push	r28
    5b24:	00 d0       	rcall	.+0      	; 0x5b26 <prvIdleTask+0x6>
    5b26:	cd b7       	in	r28, 0x3d	; 61
    5b28:	de b7       	in	r29, 0x3e	; 62
    5b2a:	9a 83       	std	Y+2, r25	; 0x02
    5b2c:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    5b2e:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5b32:	80 91 5a 07 	lds	r24, 0x075A
    5b36:	82 30       	cpi	r24, 0x02	; 2
    5b38:	d0 f3       	brcs	.-12     	; 0x5b2e <prvIdleTask+0xe>
                {
                    taskYIELD();
    5b3a:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
    5b3e:	f7 cf       	rjmp	.-18     	; 0x5b2e <prvIdleTask+0xe>

00005b40 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5b40:	df 93       	push	r29
    5b42:	cf 93       	push	r28
    5b44:	0f 92       	push	r0
    5b46:	cd b7       	in	r28, 0x3d	; 61
    5b48:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5b4a:	19 82       	std	Y+1, r1	; 0x01
    5b4c:	13 c0       	rjmp	.+38     	; 0x5b74 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5b4e:	89 81       	ldd	r24, Y+1	; 0x01
    5b50:	28 2f       	mov	r18, r24
    5b52:	30 e0       	ldi	r19, 0x00	; 0
    5b54:	c9 01       	movw	r24, r18
    5b56:	88 0f       	add	r24, r24
    5b58:	99 1f       	adc	r25, r25
    5b5a:	88 0f       	add	r24, r24
    5b5c:	99 1f       	adc	r25, r25
    5b5e:	88 0f       	add	r24, r24
    5b60:	99 1f       	adc	r25, r25
    5b62:	82 0f       	add	r24, r18
    5b64:	93 1f       	adc	r25, r19
    5b66:	86 5a       	subi	r24, 0xA6	; 166
    5b68:	98 4f       	sbci	r25, 0xF8	; 248
    5b6a:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5b6e:	89 81       	ldd	r24, Y+1	; 0x01
    5b70:	8f 5f       	subi	r24, 0xFF	; 255
    5b72:	89 83       	std	Y+1, r24	; 0x01
    5b74:	89 81       	ldd	r24, Y+1	; 0x01
    5b76:	84 30       	cpi	r24, 0x04	; 4
    5b78:	50 f3       	brcs	.-44     	; 0x5b4e <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    5b7a:	8e e7       	ldi	r24, 0x7E	; 126
    5b7c:	97 e0       	ldi	r25, 0x07	; 7
    5b7e:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    5b82:	87 e8       	ldi	r24, 0x87	; 135
    5b84:	97 e0       	ldi	r25, 0x07	; 7
    5b86:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    5b8a:	84 e9       	ldi	r24, 0x94	; 148
    5b8c:	97 e0       	ldi	r25, 0x07	; 7
    5b8e:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    5b92:	8d e9       	ldi	r24, 0x9D	; 157
    5b94:	97 e0       	ldi	r25, 0x07	; 7
    5b96:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    5b9a:	8e e7       	ldi	r24, 0x7E	; 126
    5b9c:	97 e0       	ldi	r25, 0x07	; 7
    5b9e:	90 93 91 07 	sts	0x0791, r25
    5ba2:	80 93 90 07 	sts	0x0790, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5ba6:	87 e8       	ldi	r24, 0x87	; 135
    5ba8:	97 e0       	ldi	r25, 0x07	; 7
    5baa:	90 93 93 07 	sts	0x0793, r25
    5bae:	80 93 92 07 	sts	0x0792, r24
}
    5bb2:	0f 90       	pop	r0
    5bb4:	cf 91       	pop	r28
    5bb6:	df 91       	pop	r29
    5bb8:	08 95       	ret

00005bba <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5bba:	df 93       	push	r29
    5bbc:	cf 93       	push	r28
    5bbe:	00 d0       	rcall	.+0      	; 0x5bc0 <prvCheckTasksWaitingTermination+0x6>
    5bc0:	cd b7       	in	r28, 0x3d	; 61
    5bc2:	de b7       	in	r29, 0x3e	; 62
    5bc4:	20 c0       	rjmp	.+64     	; 0x5c06 <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    5bc6:	0f b6       	in	r0, 0x3f	; 63
    5bc8:	f8 94       	cli
    5bca:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5bcc:	e0 91 a2 07 	lds	r30, 0x07A2
    5bd0:	f0 91 a3 07 	lds	r31, 0x07A3
    5bd4:	86 81       	ldd	r24, Z+6	; 0x06
    5bd6:	97 81       	ldd	r25, Z+7	; 0x07
    5bd8:	9a 83       	std	Y+2, r25	; 0x02
    5bda:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5bdc:	89 81       	ldd	r24, Y+1	; 0x01
    5bde:	9a 81       	ldd	r25, Y+2	; 0x02
    5be0:	02 96       	adiw	r24, 0x02	; 2
    5be2:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>
                    --uxCurrentNumberOfTasks;
    5be6:	80 91 4b 07 	lds	r24, 0x074B
    5bea:	81 50       	subi	r24, 0x01	; 1
    5bec:	80 93 4b 07 	sts	0x074B, r24
                    --uxDeletedTasksWaitingCleanUp;
    5bf0:	80 91 4a 07 	lds	r24, 0x074A
    5bf4:	81 50       	subi	r24, 0x01	; 1
    5bf6:	80 93 4a 07 	sts	0x074A, r24
                }
                taskEXIT_CRITICAL();
    5bfa:	0f 90       	pop	r0
    5bfc:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    5bfe:	89 81       	ldd	r24, Y+1	; 0x01
    5c00:	9a 81       	ldd	r25, Y+2	; 0x02
    5c02:	0e 94 0c 2e 	call	0x5c18	; 0x5c18 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5c06:	80 91 4a 07 	lds	r24, 0x074A
    5c0a:	88 23       	and	r24, r24
    5c0c:	e1 f6       	brne	.-72     	; 0x5bc6 <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    5c0e:	0f 90       	pop	r0
    5c10:	0f 90       	pop	r0
    5c12:	cf 91       	pop	r28
    5c14:	df 91       	pop	r29
    5c16:	08 95       	ret

00005c18 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    5c18:	df 93       	push	r29
    5c1a:	cf 93       	push	r28
    5c1c:	00 d0       	rcall	.+0      	; 0x5c1e <prvDeleteTCB+0x6>
    5c1e:	cd b7       	in	r28, 0x3d	; 61
    5c20:	de b7       	in	r29, 0x3e	; 62
    5c22:	9a 83       	std	Y+2, r25	; 0x02
    5c24:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    5c26:	e9 81       	ldd	r30, Y+1	; 0x01
    5c28:	fa 81       	ldd	r31, Y+2	; 0x02
    5c2a:	87 89       	ldd	r24, Z+23	; 0x17
    5c2c:	90 8d       	ldd	r25, Z+24	; 0x18
    5c2e:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <vPortFree>
                vPortFree( pxTCB );
    5c32:	89 81       	ldd	r24, Y+1	; 0x01
    5c34:	9a 81       	ldd	r25, Y+2	; 0x02
    5c36:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    5c3a:	0f 90       	pop	r0
    5c3c:	0f 90       	pop	r0
    5c3e:	cf 91       	pop	r28
    5c40:	df 91       	pop	r29
    5c42:	08 95       	ret

00005c44 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5c44:	df 93       	push	r29
    5c46:	cf 93       	push	r28
    5c48:	cd b7       	in	r28, 0x3d	; 61
    5c4a:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5c4c:	e0 91 90 07 	lds	r30, 0x0790
    5c50:	f0 91 91 07 	lds	r31, 0x0791
    5c54:	80 81       	ld	r24, Z
    5c56:	88 23       	and	r24, r24
    5c58:	39 f4       	brne	.+14     	; 0x5c68 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    5c5a:	8f ef       	ldi	r24, 0xFF	; 255
    5c5c:	9f ef       	ldi	r25, 0xFF	; 255
    5c5e:	90 93 56 07 	sts	0x0756, r25
    5c62:	80 93 55 07 	sts	0x0755, r24
    5c66:	0d c0       	rjmp	.+26     	; 0x5c82 <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    5c68:	e0 91 90 07 	lds	r30, 0x0790
    5c6c:	f0 91 91 07 	lds	r31, 0x0791
    5c70:	05 80       	ldd	r0, Z+5	; 0x05
    5c72:	f6 81       	ldd	r31, Z+6	; 0x06
    5c74:	e0 2d       	mov	r30, r0
    5c76:	80 81       	ld	r24, Z
    5c78:	91 81       	ldd	r25, Z+1	; 0x01
    5c7a:	90 93 56 07 	sts	0x0756, r25
    5c7e:	80 93 55 07 	sts	0x0755, r24
    }
}
    5c82:	cf 91       	pop	r28
    5c84:	df 91       	pop	r29
    5c86:	08 95       	ret

00005c88 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    5c88:	df 93       	push	r29
    5c8a:	cf 93       	push	r28
    5c8c:	0f 92       	push	r0
    5c8e:	cd b7       	in	r28, 0x3d	; 61
    5c90:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    5c92:	80 91 4f 07 	lds	r24, 0x074F
    5c96:	88 23       	and	r24, r24
    5c98:	19 f4       	brne	.+6      	; 0x5ca0 <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    5c9a:	81 e0       	ldi	r24, 0x01	; 1
    5c9c:	89 83       	std	Y+1, r24	; 0x01
    5c9e:	08 c0       	rjmp	.+16     	; 0x5cb0 <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5ca0:	80 91 59 07 	lds	r24, 0x0759
    5ca4:	88 23       	and	r24, r24
    5ca6:	19 f4       	brne	.+6      	; 0x5cae <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    5ca8:	82 e0       	ldi	r24, 0x02	; 2
    5caa:	89 83       	std	Y+1, r24	; 0x01
    5cac:	01 c0       	rjmp	.+2      	; 0x5cb0 <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    5cae:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    5cb0:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5cb2:	0f 90       	pop	r0
    5cb4:	cf 91       	pop	r28
    5cb6:	df 91       	pop	r29
    5cb8:	08 95       	ret

00005cba <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5cba:	df 93       	push	r29
    5cbc:	cf 93       	push	r28
    5cbe:	00 d0       	rcall	.+0      	; 0x5cc0 <uxTaskResetEventItemValue+0x6>
    5cc0:	cd b7       	in	r28, 0x3d	; 61
    5cc2:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5cc4:	e0 91 48 07 	lds	r30, 0x0748
    5cc8:	f0 91 49 07 	lds	r31, 0x0749
    5ccc:	84 85       	ldd	r24, Z+12	; 0x0c
    5cce:	95 85       	ldd	r25, Z+13	; 0x0d
    5cd0:	9a 83       	std	Y+2, r25	; 0x02
    5cd2:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5cd4:	a0 91 48 07 	lds	r26, 0x0748
    5cd8:	b0 91 49 07 	lds	r27, 0x0749
    5cdc:	e0 91 48 07 	lds	r30, 0x0748
    5ce0:	f0 91 49 07 	lds	r31, 0x0749
    5ce4:	86 89       	ldd	r24, Z+22	; 0x16
    5ce6:	28 2f       	mov	r18, r24
    5ce8:	30 e0       	ldi	r19, 0x00	; 0
    5cea:	84 e0       	ldi	r24, 0x04	; 4
    5cec:	90 e0       	ldi	r25, 0x00	; 0
    5cee:	82 1b       	sub	r24, r18
    5cf0:	93 0b       	sbc	r25, r19
    5cf2:	1d 96       	adiw	r26, 0x0d	; 13
    5cf4:	9c 93       	st	X, r25
    5cf6:	8e 93       	st	-X, r24
    5cf8:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    5cfa:	89 81       	ldd	r24, Y+1	; 0x01
    5cfc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5cfe:	0f 90       	pop	r0
    5d00:	0f 90       	pop	r0
    5d02:	cf 91       	pop	r28
    5d04:	df 91       	pop	r29
    5d06:	08 95       	ret

00005d08 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    5d08:	df 93       	push	r29
    5d0a:	cf 93       	push	r28
    5d0c:	cd b7       	in	r28, 0x3d	; 61
    5d0e:	de b7       	in	r29, 0x3e	; 62
    5d10:	28 97       	sbiw	r28, 0x08	; 8
    5d12:	0f b6       	in	r0, 0x3f	; 63
    5d14:	f8 94       	cli
    5d16:	de bf       	out	0x3e, r29	; 62
    5d18:	0f be       	out	0x3f, r0	; 63
    5d1a:	cd bf       	out	0x3d, r28	; 61
    5d1c:	8d 83       	std	Y+5, r24	; 0x05
    5d1e:	6e 83       	std	Y+6, r22	; 0x06
    5d20:	58 87       	std	Y+8, r21	; 0x08
    5d22:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5d24:	0f b6       	in	r0, 0x3f	; 63
    5d26:	f8 94       	cli
    5d28:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    5d2a:	20 91 48 07 	lds	r18, 0x0748
    5d2e:	30 91 49 07 	lds	r19, 0x0749
    5d32:	8d 81       	ldd	r24, Y+5	; 0x05
    5d34:	88 2f       	mov	r24, r24
    5d36:	90 e0       	ldi	r25, 0x00	; 0
    5d38:	88 0f       	add	r24, r24
    5d3a:	99 1f       	adc	r25, r25
    5d3c:	88 0f       	add	r24, r24
    5d3e:	99 1f       	adc	r25, r25
    5d40:	82 0f       	add	r24, r18
    5d42:	93 1f       	adc	r25, r19
    5d44:	fc 01       	movw	r30, r24
    5d46:	b1 96       	adiw	r30, 0x21	; 33
    5d48:	80 81       	ld	r24, Z
    5d4a:	91 81       	ldd	r25, Z+1	; 0x01
    5d4c:	a2 81       	ldd	r26, Z+2	; 0x02
    5d4e:	b3 81       	ldd	r27, Z+3	; 0x03
    5d50:	00 97       	sbiw	r24, 0x00	; 0
    5d52:	a1 05       	cpc	r26, r1
    5d54:	b1 05       	cpc	r27, r1
    5d56:	c1 f4       	brne	.+48     	; 0x5d88 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5d58:	20 91 48 07 	lds	r18, 0x0748
    5d5c:	30 91 49 07 	lds	r19, 0x0749
    5d60:	8d 81       	ldd	r24, Y+5	; 0x05
    5d62:	88 2f       	mov	r24, r24
    5d64:	90 e0       	ldi	r25, 0x00	; 0
    5d66:	82 0f       	add	r24, r18
    5d68:	93 1f       	adc	r25, r19
    5d6a:	fc 01       	movw	r30, r24
    5d6c:	b5 96       	adiw	r30, 0x25	; 37
    5d6e:	81 e0       	ldi	r24, 0x01	; 1
    5d70:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5d72:	8f 81       	ldd	r24, Y+7	; 0x07
    5d74:	98 85       	ldd	r25, Y+8	; 0x08
    5d76:	00 97       	sbiw	r24, 0x00	; 0
    5d78:	39 f0       	breq	.+14     	; 0x5d88 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5d7a:	8f 81       	ldd	r24, Y+7	; 0x07
    5d7c:	98 85       	ldd	r25, Y+8	; 0x08
    5d7e:	61 e0       	ldi	r22, 0x01	; 1
    5d80:	0e 94 09 36 	call	0x6c12	; 0x6c12 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5d84:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5d88:	0f 90       	pop	r0
    5d8a:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5d8c:	0f b6       	in	r0, 0x3f	; 63
    5d8e:	f8 94       	cli
    5d90:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5d92:	20 91 48 07 	lds	r18, 0x0748
    5d96:	30 91 49 07 	lds	r19, 0x0749
    5d9a:	8d 81       	ldd	r24, Y+5	; 0x05
    5d9c:	88 2f       	mov	r24, r24
    5d9e:	90 e0       	ldi	r25, 0x00	; 0
    5da0:	88 0f       	add	r24, r24
    5da2:	99 1f       	adc	r25, r25
    5da4:	88 0f       	add	r24, r24
    5da6:	99 1f       	adc	r25, r25
    5da8:	82 0f       	add	r24, r18
    5daa:	93 1f       	adc	r25, r19
    5dac:	fc 01       	movw	r30, r24
    5dae:	b1 96       	adiw	r30, 0x21	; 33
    5db0:	80 81       	ld	r24, Z
    5db2:	91 81       	ldd	r25, Z+1	; 0x01
    5db4:	a2 81       	ldd	r26, Z+2	; 0x02
    5db6:	b3 81       	ldd	r27, Z+3	; 0x03
    5db8:	89 83       	std	Y+1, r24	; 0x01
    5dba:	9a 83       	std	Y+2, r25	; 0x02
    5dbc:	ab 83       	std	Y+3, r26	; 0x03
    5dbe:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    5dc0:	89 81       	ldd	r24, Y+1	; 0x01
    5dc2:	9a 81       	ldd	r25, Y+2	; 0x02
    5dc4:	ab 81       	ldd	r26, Y+3	; 0x03
    5dc6:	bc 81       	ldd	r27, Y+4	; 0x04
    5dc8:	00 97       	sbiw	r24, 0x00	; 0
    5dca:	a1 05       	cpc	r26, r1
    5dcc:	b1 05       	cpc	r27, r1
    5dce:	a9 f1       	breq	.+106    	; 0x5e3a <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    5dd0:	8e 81       	ldd	r24, Y+6	; 0x06
    5dd2:	88 23       	and	r24, r24
    5dd4:	a1 f0       	breq	.+40     	; 0x5dfe <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    5dd6:	20 91 48 07 	lds	r18, 0x0748
    5dda:	30 91 49 07 	lds	r19, 0x0749
    5dde:	8d 81       	ldd	r24, Y+5	; 0x05
    5de0:	88 2f       	mov	r24, r24
    5de2:	90 e0       	ldi	r25, 0x00	; 0
    5de4:	88 0f       	add	r24, r24
    5de6:	99 1f       	adc	r25, r25
    5de8:	88 0f       	add	r24, r24
    5dea:	99 1f       	adc	r25, r25
    5dec:	82 0f       	add	r24, r18
    5dee:	93 1f       	adc	r25, r19
    5df0:	fc 01       	movw	r30, r24
    5df2:	b1 96       	adiw	r30, 0x21	; 33
    5df4:	10 82       	st	Z, r1
    5df6:	11 82       	std	Z+1, r1	; 0x01
    5df8:	12 82       	std	Z+2, r1	; 0x02
    5dfa:	13 82       	std	Z+3, r1	; 0x03
    5dfc:	1e c0       	rjmp	.+60     	; 0x5e3a <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    5dfe:	e0 91 48 07 	lds	r30, 0x0748
    5e02:	f0 91 49 07 	lds	r31, 0x0749
    5e06:	8d 81       	ldd	r24, Y+5	; 0x05
    5e08:	68 2f       	mov	r22, r24
    5e0a:	70 e0       	ldi	r23, 0x00	; 0
    5e0c:	89 81       	ldd	r24, Y+1	; 0x01
    5e0e:	9a 81       	ldd	r25, Y+2	; 0x02
    5e10:	ab 81       	ldd	r26, Y+3	; 0x03
    5e12:	bc 81       	ldd	r27, Y+4	; 0x04
    5e14:	9c 01       	movw	r18, r24
    5e16:	ad 01       	movw	r20, r26
    5e18:	21 50       	subi	r18, 0x01	; 1
    5e1a:	30 40       	sbci	r19, 0x00	; 0
    5e1c:	40 40       	sbci	r20, 0x00	; 0
    5e1e:	50 40       	sbci	r21, 0x00	; 0
    5e20:	cb 01       	movw	r24, r22
    5e22:	88 0f       	add	r24, r24
    5e24:	99 1f       	adc	r25, r25
    5e26:	88 0f       	add	r24, r24
    5e28:	99 1f       	adc	r25, r25
    5e2a:	8e 0f       	add	r24, r30
    5e2c:	9f 1f       	adc	r25, r31
    5e2e:	fc 01       	movw	r30, r24
    5e30:	b1 96       	adiw	r30, 0x21	; 33
    5e32:	20 83       	st	Z, r18
    5e34:	31 83       	std	Z+1, r19	; 0x01
    5e36:	42 83       	std	Z+2, r20	; 0x02
    5e38:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    5e3a:	20 91 48 07 	lds	r18, 0x0748
    5e3e:	30 91 49 07 	lds	r19, 0x0749
    5e42:	8d 81       	ldd	r24, Y+5	; 0x05
    5e44:	88 2f       	mov	r24, r24
    5e46:	90 e0       	ldi	r25, 0x00	; 0
    5e48:	82 0f       	add	r24, r18
    5e4a:	93 1f       	adc	r25, r19
    5e4c:	fc 01       	movw	r30, r24
    5e4e:	b5 96       	adiw	r30, 0x25	; 37
    5e50:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5e52:	0f 90       	pop	r0
    5e54:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5e56:	89 81       	ldd	r24, Y+1	; 0x01
    5e58:	9a 81       	ldd	r25, Y+2	; 0x02
    5e5a:	ab 81       	ldd	r26, Y+3	; 0x03
    5e5c:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5e5e:	bc 01       	movw	r22, r24
    5e60:	cd 01       	movw	r24, r26
    5e62:	28 96       	adiw	r28, 0x08	; 8
    5e64:	0f b6       	in	r0, 0x3f	; 63
    5e66:	f8 94       	cli
    5e68:	de bf       	out	0x3e, r29	; 62
    5e6a:	0f be       	out	0x3f, r0	; 63
    5e6c:	cd bf       	out	0x3d, r28	; 61
    5e6e:	cf 91       	pop	r28
    5e70:	df 91       	pop	r29
    5e72:	08 95       	ret

00005e74 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    5e74:	cf 92       	push	r12
    5e76:	df 92       	push	r13
    5e78:	ef 92       	push	r14
    5e7a:	ff 92       	push	r15
    5e7c:	0f 93       	push	r16
    5e7e:	1f 93       	push	r17
    5e80:	df 93       	push	r29
    5e82:	cf 93       	push	r28
    5e84:	cd b7       	in	r28, 0x3d	; 61
    5e86:	de b7       	in	r29, 0x3e	; 62
    5e88:	2e 97       	sbiw	r28, 0x0e	; 14
    5e8a:	0f b6       	in	r0, 0x3f	; 63
    5e8c:	f8 94       	cli
    5e8e:	de bf       	out	0x3e, r29	; 62
    5e90:	0f be       	out	0x3f, r0	; 63
    5e92:	cd bf       	out	0x3d, r28	; 61
    5e94:	8a 83       	std	Y+2, r24	; 0x02
    5e96:	4b 83       	std	Y+3, r20	; 0x03
    5e98:	5c 83       	std	Y+4, r21	; 0x04
    5e9a:	6d 83       	std	Y+5, r22	; 0x05
    5e9c:	7e 83       	std	Y+6, r23	; 0x06
    5e9e:	0f 83       	std	Y+7, r16	; 0x07
    5ea0:	18 87       	std	Y+8, r17	; 0x08
    5ea2:	29 87       	std	Y+9, r18	; 0x09
    5ea4:	3a 87       	std	Y+10, r19	; 0x0a
    5ea6:	fc 86       	std	Y+12, r15	; 0x0c
    5ea8:	eb 86       	std	Y+11, r14	; 0x0b
    5eaa:	de 86       	std	Y+14, r13	; 0x0e
    5eac:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5eae:	0f b6       	in	r0, 0x3f	; 63
    5eb0:	f8 94       	cli
    5eb2:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5eb4:	20 91 48 07 	lds	r18, 0x0748
    5eb8:	30 91 49 07 	lds	r19, 0x0749
    5ebc:	8a 81       	ldd	r24, Y+2	; 0x02
    5ebe:	88 2f       	mov	r24, r24
    5ec0:	90 e0       	ldi	r25, 0x00	; 0
    5ec2:	82 0f       	add	r24, r18
    5ec4:	93 1f       	adc	r25, r19
    5ec6:	fc 01       	movw	r30, r24
    5ec8:	b5 96       	adiw	r30, 0x25	; 37
    5eca:	80 81       	ld	r24, Z
    5ecc:	82 30       	cpi	r24, 0x02	; 2
    5ece:	09 f4       	brne	.+2      	; 0x5ed2 <xTaskGenericNotifyWait+0x5e>
    5ed0:	47 c0       	rjmp	.+142    	; 0x5f60 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    5ed2:	60 91 48 07 	lds	r22, 0x0748
    5ed6:	70 91 49 07 	lds	r23, 0x0749
    5eda:	8a 81       	ldd	r24, Y+2	; 0x02
    5edc:	08 2f       	mov	r16, r24
    5ede:	10 e0       	ldi	r17, 0x00	; 0
    5ee0:	8a 81       	ldd	r24, Y+2	; 0x02
    5ee2:	88 2f       	mov	r24, r24
    5ee4:	90 e0       	ldi	r25, 0x00	; 0
    5ee6:	88 0f       	add	r24, r24
    5ee8:	99 1f       	adc	r25, r25
    5eea:	88 0f       	add	r24, r24
    5eec:	99 1f       	adc	r25, r25
    5eee:	86 0f       	add	r24, r22
    5ef0:	97 1f       	adc	r25, r23
    5ef2:	fc 01       	movw	r30, r24
    5ef4:	b1 96       	adiw	r30, 0x21	; 33
    5ef6:	20 81       	ld	r18, Z
    5ef8:	31 81       	ldd	r19, Z+1	; 0x01
    5efa:	42 81       	ldd	r20, Z+2	; 0x02
    5efc:	53 81       	ldd	r21, Z+3	; 0x03
    5efe:	8b 81       	ldd	r24, Y+3	; 0x03
    5f00:	9c 81       	ldd	r25, Y+4	; 0x04
    5f02:	ad 81       	ldd	r26, Y+5	; 0x05
    5f04:	be 81       	ldd	r27, Y+6	; 0x06
    5f06:	80 95       	com	r24
    5f08:	90 95       	com	r25
    5f0a:	a0 95       	com	r26
    5f0c:	b0 95       	com	r27
    5f0e:	28 23       	and	r18, r24
    5f10:	39 23       	and	r19, r25
    5f12:	4a 23       	and	r20, r26
    5f14:	5b 23       	and	r21, r27
    5f16:	c8 01       	movw	r24, r16
    5f18:	88 0f       	add	r24, r24
    5f1a:	99 1f       	adc	r25, r25
    5f1c:	88 0f       	add	r24, r24
    5f1e:	99 1f       	adc	r25, r25
    5f20:	86 0f       	add	r24, r22
    5f22:	97 1f       	adc	r25, r23
    5f24:	fc 01       	movw	r30, r24
    5f26:	b1 96       	adiw	r30, 0x21	; 33
    5f28:	20 83       	st	Z, r18
    5f2a:	31 83       	std	Z+1, r19	; 0x01
    5f2c:	42 83       	std	Z+2, r20	; 0x02
    5f2e:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5f30:	20 91 48 07 	lds	r18, 0x0748
    5f34:	30 91 49 07 	lds	r19, 0x0749
    5f38:	8a 81       	ldd	r24, Y+2	; 0x02
    5f3a:	88 2f       	mov	r24, r24
    5f3c:	90 e0       	ldi	r25, 0x00	; 0
    5f3e:	82 0f       	add	r24, r18
    5f40:	93 1f       	adc	r25, r19
    5f42:	fc 01       	movw	r30, r24
    5f44:	b5 96       	adiw	r30, 0x25	; 37
    5f46:	81 e0       	ldi	r24, 0x01	; 1
    5f48:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5f4a:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f4c:	9e 85       	ldd	r25, Y+14	; 0x0e
    5f4e:	00 97       	sbiw	r24, 0x00	; 0
    5f50:	39 f0       	breq	.+14     	; 0x5f60 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5f52:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f54:	9e 85       	ldd	r25, Y+14	; 0x0e
    5f56:	61 e0       	ldi	r22, 0x01	; 1
    5f58:	0e 94 09 36 	call	0x6c12	; 0x6c12 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5f5c:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5f60:	0f 90       	pop	r0
    5f62:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5f64:	0f b6       	in	r0, 0x3f	; 63
    5f66:	f8 94       	cli
    5f68:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    5f6a:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f6c:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f6e:	00 97       	sbiw	r24, 0x00	; 0
    5f70:	c9 f0       	breq	.+50     	; 0x5fa4 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5f72:	20 91 48 07 	lds	r18, 0x0748
    5f76:	30 91 49 07 	lds	r19, 0x0749
    5f7a:	8a 81       	ldd	r24, Y+2	; 0x02
    5f7c:	88 2f       	mov	r24, r24
    5f7e:	90 e0       	ldi	r25, 0x00	; 0
    5f80:	88 0f       	add	r24, r24
    5f82:	99 1f       	adc	r25, r25
    5f84:	88 0f       	add	r24, r24
    5f86:	99 1f       	adc	r25, r25
    5f88:	82 0f       	add	r24, r18
    5f8a:	93 1f       	adc	r25, r19
    5f8c:	fc 01       	movw	r30, r24
    5f8e:	b1 96       	adiw	r30, 0x21	; 33
    5f90:	80 81       	ld	r24, Z
    5f92:	91 81       	ldd	r25, Z+1	; 0x01
    5f94:	a2 81       	ldd	r26, Z+2	; 0x02
    5f96:	b3 81       	ldd	r27, Z+3	; 0x03
    5f98:	eb 85       	ldd	r30, Y+11	; 0x0b
    5f9a:	fc 85       	ldd	r31, Y+12	; 0x0c
    5f9c:	80 83       	st	Z, r24
    5f9e:	91 83       	std	Z+1, r25	; 0x01
    5fa0:	a2 83       	std	Z+2, r26	; 0x02
    5fa2:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5fa4:	20 91 48 07 	lds	r18, 0x0748
    5fa8:	30 91 49 07 	lds	r19, 0x0749
    5fac:	8a 81       	ldd	r24, Y+2	; 0x02
    5fae:	88 2f       	mov	r24, r24
    5fb0:	90 e0       	ldi	r25, 0x00	; 0
    5fb2:	82 0f       	add	r24, r18
    5fb4:	93 1f       	adc	r25, r19
    5fb6:	fc 01       	movw	r30, r24
    5fb8:	b5 96       	adiw	r30, 0x25	; 37
    5fba:	80 81       	ld	r24, Z
    5fbc:	82 30       	cpi	r24, 0x02	; 2
    5fbe:	11 f0       	breq	.+4      	; 0x5fc4 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    5fc0:	19 82       	std	Y+1, r1	; 0x01
    5fc2:	31 c0       	rjmp	.+98     	; 0x6026 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    5fc4:	60 91 48 07 	lds	r22, 0x0748
    5fc8:	70 91 49 07 	lds	r23, 0x0749
    5fcc:	8a 81       	ldd	r24, Y+2	; 0x02
    5fce:	08 2f       	mov	r16, r24
    5fd0:	10 e0       	ldi	r17, 0x00	; 0
    5fd2:	8a 81       	ldd	r24, Y+2	; 0x02
    5fd4:	88 2f       	mov	r24, r24
    5fd6:	90 e0       	ldi	r25, 0x00	; 0
    5fd8:	88 0f       	add	r24, r24
    5fda:	99 1f       	adc	r25, r25
    5fdc:	88 0f       	add	r24, r24
    5fde:	99 1f       	adc	r25, r25
    5fe0:	86 0f       	add	r24, r22
    5fe2:	97 1f       	adc	r25, r23
    5fe4:	fc 01       	movw	r30, r24
    5fe6:	b1 96       	adiw	r30, 0x21	; 33
    5fe8:	20 81       	ld	r18, Z
    5fea:	31 81       	ldd	r19, Z+1	; 0x01
    5fec:	42 81       	ldd	r20, Z+2	; 0x02
    5fee:	53 81       	ldd	r21, Z+3	; 0x03
    5ff0:	8f 81       	ldd	r24, Y+7	; 0x07
    5ff2:	98 85       	ldd	r25, Y+8	; 0x08
    5ff4:	a9 85       	ldd	r26, Y+9	; 0x09
    5ff6:	ba 85       	ldd	r27, Y+10	; 0x0a
    5ff8:	80 95       	com	r24
    5ffa:	90 95       	com	r25
    5ffc:	a0 95       	com	r26
    5ffe:	b0 95       	com	r27
    6000:	28 23       	and	r18, r24
    6002:	39 23       	and	r19, r25
    6004:	4a 23       	and	r20, r26
    6006:	5b 23       	and	r21, r27
    6008:	c8 01       	movw	r24, r16
    600a:	88 0f       	add	r24, r24
    600c:	99 1f       	adc	r25, r25
    600e:	88 0f       	add	r24, r24
    6010:	99 1f       	adc	r25, r25
    6012:	86 0f       	add	r24, r22
    6014:	97 1f       	adc	r25, r23
    6016:	fc 01       	movw	r30, r24
    6018:	b1 96       	adiw	r30, 0x21	; 33
    601a:	20 83       	st	Z, r18
    601c:	31 83       	std	Z+1, r19	; 0x01
    601e:	42 83       	std	Z+2, r20	; 0x02
    6020:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    6022:	81 e0       	ldi	r24, 0x01	; 1
    6024:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    6026:	20 91 48 07 	lds	r18, 0x0748
    602a:	30 91 49 07 	lds	r19, 0x0749
    602e:	8a 81       	ldd	r24, Y+2	; 0x02
    6030:	88 2f       	mov	r24, r24
    6032:	90 e0       	ldi	r25, 0x00	; 0
    6034:	82 0f       	add	r24, r18
    6036:	93 1f       	adc	r25, r19
    6038:	fc 01       	movw	r30, r24
    603a:	b5 96       	adiw	r30, 0x25	; 37
    603c:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    603e:	0f 90       	pop	r0
    6040:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    6042:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6044:	2e 96       	adiw	r28, 0x0e	; 14
    6046:	0f b6       	in	r0, 0x3f	; 63
    6048:	f8 94       	cli
    604a:	de bf       	out	0x3e, r29	; 62
    604c:	0f be       	out	0x3f, r0	; 63
    604e:	cd bf       	out	0x3d, r28	; 61
    6050:	cf 91       	pop	r28
    6052:	df 91       	pop	r29
    6054:	1f 91       	pop	r17
    6056:	0f 91       	pop	r16
    6058:	ff 90       	pop	r15
    605a:	ef 90       	pop	r14
    605c:	df 90       	pop	r13
    605e:	cf 90       	pop	r12
    6060:	08 95       	ret

00006062 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    6062:	ef 92       	push	r14
    6064:	ff 92       	push	r15
    6066:	0f 93       	push	r16
    6068:	1f 93       	push	r17
    606a:	df 93       	push	r29
    606c:	cf 93       	push	r28
    606e:	cd b7       	in	r28, 0x3d	; 61
    6070:	de b7       	in	r29, 0x3e	; 62
    6072:	64 97       	sbiw	r28, 0x14	; 20
    6074:	0f b6       	in	r0, 0x3f	; 63
    6076:	f8 94       	cli
    6078:	de bf       	out	0x3e, r29	; 62
    607a:	0f be       	out	0x3f, r0	; 63
    607c:	cd bf       	out	0x3d, r28	; 61
    607e:	9a 87       	std	Y+10, r25	; 0x0a
    6080:	89 87       	std	Y+9, r24	; 0x09
    6082:	6b 87       	std	Y+11, r22	; 0x0b
    6084:	2c 87       	std	Y+12, r18	; 0x0c
    6086:	3d 87       	std	Y+13, r19	; 0x0d
    6088:	4e 87       	std	Y+14, r20	; 0x0e
    608a:	5f 87       	std	Y+15, r21	; 0x0f
    608c:	08 8b       	std	Y+16, r16	; 0x10
    608e:	fa 8a       	std	Y+18, r15	; 0x12
    6090:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    6092:	81 e0       	ldi	r24, 0x01	; 1
    6094:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    6096:	89 85       	ldd	r24, Y+9	; 0x09
    6098:	9a 85       	ldd	r25, Y+10	; 0x0a
    609a:	98 87       	std	Y+8, r25	; 0x08
    609c:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    609e:	0f b6       	in	r0, 0x3f	; 63
    60a0:	f8 94       	cli
    60a2:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    60a4:	89 89       	ldd	r24, Y+17	; 0x11
    60a6:	9a 89       	ldd	r25, Y+18	; 0x12
    60a8:	00 97       	sbiw	r24, 0x00	; 0
    60aa:	b9 f0       	breq	.+46     	; 0x60da <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    60ac:	8b 85       	ldd	r24, Y+11	; 0x0b
    60ae:	88 2f       	mov	r24, r24
    60b0:	90 e0       	ldi	r25, 0x00	; 0
    60b2:	2f 81       	ldd	r18, Y+7	; 0x07
    60b4:	38 85       	ldd	r19, Y+8	; 0x08
    60b6:	88 0f       	add	r24, r24
    60b8:	99 1f       	adc	r25, r25
    60ba:	88 0f       	add	r24, r24
    60bc:	99 1f       	adc	r25, r25
    60be:	82 0f       	add	r24, r18
    60c0:	93 1f       	adc	r25, r19
    60c2:	fc 01       	movw	r30, r24
    60c4:	b1 96       	adiw	r30, 0x21	; 33
    60c6:	80 81       	ld	r24, Z
    60c8:	91 81       	ldd	r25, Z+1	; 0x01
    60ca:	a2 81       	ldd	r26, Z+2	; 0x02
    60cc:	b3 81       	ldd	r27, Z+3	; 0x03
    60ce:	e9 89       	ldd	r30, Y+17	; 0x11
    60d0:	fa 89       	ldd	r31, Y+18	; 0x12
    60d2:	80 83       	st	Z, r24
    60d4:	91 83       	std	Z+1, r25	; 0x01
    60d6:	a2 83       	std	Z+2, r26	; 0x02
    60d8:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    60da:	8b 85       	ldd	r24, Y+11	; 0x0b
    60dc:	28 2f       	mov	r18, r24
    60de:	30 e0       	ldi	r19, 0x00	; 0
    60e0:	8f 81       	ldd	r24, Y+7	; 0x07
    60e2:	98 85       	ldd	r25, Y+8	; 0x08
    60e4:	82 0f       	add	r24, r18
    60e6:	93 1f       	adc	r25, r19
    60e8:	fc 01       	movw	r30, r24
    60ea:	b5 96       	adiw	r30, 0x25	; 37
    60ec:	80 81       	ld	r24, Z
    60ee:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    60f0:	8b 85       	ldd	r24, Y+11	; 0x0b
    60f2:	28 2f       	mov	r18, r24
    60f4:	30 e0       	ldi	r19, 0x00	; 0
    60f6:	8f 81       	ldd	r24, Y+7	; 0x07
    60f8:	98 85       	ldd	r25, Y+8	; 0x08
    60fa:	82 0f       	add	r24, r18
    60fc:	93 1f       	adc	r25, r19
    60fe:	fc 01       	movw	r30, r24
    6100:	b5 96       	adiw	r30, 0x25	; 37
    6102:	82 e0       	ldi	r24, 0x02	; 2
    6104:	80 83       	st	Z, r24

            switch( eAction )
    6106:	88 89       	ldd	r24, Y+16	; 0x10
    6108:	28 2f       	mov	r18, r24
    610a:	30 e0       	ldi	r19, 0x00	; 0
    610c:	3c 8b       	std	Y+20, r19	; 0x14
    610e:	2b 8b       	std	Y+19, r18	; 0x13
    6110:	8b 89       	ldd	r24, Y+19	; 0x13
    6112:	9c 89       	ldd	r25, Y+20	; 0x14
    6114:	82 30       	cpi	r24, 0x02	; 2
    6116:	91 05       	cpc	r25, r1
    6118:	09 f4       	brne	.+2      	; 0x611c <xTaskGenericNotify+0xba>
    611a:	46 c0       	rjmp	.+140    	; 0x61a8 <xTaskGenericNotify+0x146>
    611c:	2b 89       	ldd	r18, Y+19	; 0x13
    611e:	3c 89       	ldd	r19, Y+20	; 0x14
    6120:	23 30       	cpi	r18, 0x03	; 3
    6122:	31 05       	cpc	r19, r1
    6124:	34 f4       	brge	.+12     	; 0x6132 <xTaskGenericNotify+0xd0>
    6126:	8b 89       	ldd	r24, Y+19	; 0x13
    6128:	9c 89       	ldd	r25, Y+20	; 0x14
    612a:	81 30       	cpi	r24, 0x01	; 1
    612c:	91 05       	cpc	r25, r1
    612e:	71 f0       	breq	.+28     	; 0x614c <xTaskGenericNotify+0xea>
    6130:	93 c0       	rjmp	.+294    	; 0x6258 <xTaskGenericNotify+0x1f6>
    6132:	2b 89       	ldd	r18, Y+19	; 0x13
    6134:	3c 89       	ldd	r19, Y+20	; 0x14
    6136:	23 30       	cpi	r18, 0x03	; 3
    6138:	31 05       	cpc	r19, r1
    613a:	09 f4       	brne	.+2      	; 0x613e <xTaskGenericNotify+0xdc>
    613c:	5d c0       	rjmp	.+186    	; 0x61f8 <xTaskGenericNotify+0x196>
    613e:	8b 89       	ldd	r24, Y+19	; 0x13
    6140:	9c 89       	ldd	r25, Y+20	; 0x14
    6142:	84 30       	cpi	r24, 0x04	; 4
    6144:	91 05       	cpc	r25, r1
    6146:	09 f4       	brne	.+2      	; 0x614a <xTaskGenericNotify+0xe8>
    6148:	6d c0       	rjmp	.+218    	; 0x6224 <xTaskGenericNotify+0x1c2>
    614a:	86 c0       	rjmp	.+268    	; 0x6258 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    614c:	8b 85       	ldd	r24, Y+11	; 0x0b
    614e:	08 2f       	mov	r16, r24
    6150:	10 e0       	ldi	r17, 0x00	; 0
    6152:	8b 85       	ldd	r24, Y+11	; 0x0b
    6154:	88 2f       	mov	r24, r24
    6156:	90 e0       	ldi	r25, 0x00	; 0
    6158:	2f 81       	ldd	r18, Y+7	; 0x07
    615a:	38 85       	ldd	r19, Y+8	; 0x08
    615c:	88 0f       	add	r24, r24
    615e:	99 1f       	adc	r25, r25
    6160:	88 0f       	add	r24, r24
    6162:	99 1f       	adc	r25, r25
    6164:	82 0f       	add	r24, r18
    6166:	93 1f       	adc	r25, r19
    6168:	fc 01       	movw	r30, r24
    616a:	b1 96       	adiw	r30, 0x21	; 33
    616c:	20 81       	ld	r18, Z
    616e:	31 81       	ldd	r19, Z+1	; 0x01
    6170:	42 81       	ldd	r20, Z+2	; 0x02
    6172:	53 81       	ldd	r21, Z+3	; 0x03
    6174:	8c 85       	ldd	r24, Y+12	; 0x0c
    6176:	9d 85       	ldd	r25, Y+13	; 0x0d
    6178:	ae 85       	ldd	r26, Y+14	; 0x0e
    617a:	bf 85       	ldd	r27, Y+15	; 0x0f
    617c:	ba 01       	movw	r22, r20
    617e:	a9 01       	movw	r20, r18
    6180:	48 2b       	or	r20, r24
    6182:	59 2b       	or	r21, r25
    6184:	6a 2b       	or	r22, r26
    6186:	7b 2b       	or	r23, r27
    6188:	2f 81       	ldd	r18, Y+7	; 0x07
    618a:	38 85       	ldd	r19, Y+8	; 0x08
    618c:	c8 01       	movw	r24, r16
    618e:	88 0f       	add	r24, r24
    6190:	99 1f       	adc	r25, r25
    6192:	88 0f       	add	r24, r24
    6194:	99 1f       	adc	r25, r25
    6196:	82 0f       	add	r24, r18
    6198:	93 1f       	adc	r25, r19
    619a:	fc 01       	movw	r30, r24
    619c:	b1 96       	adiw	r30, 0x21	; 33
    619e:	40 83       	st	Z, r20
    61a0:	51 83       	std	Z+1, r21	; 0x01
    61a2:	62 83       	std	Z+2, r22	; 0x02
    61a4:	73 83       	std	Z+3, r23	; 0x03
    61a6:	58 c0       	rjmp	.+176    	; 0x6258 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    61a8:	8b 85       	ldd	r24, Y+11	; 0x0b
    61aa:	08 2f       	mov	r16, r24
    61ac:	10 e0       	ldi	r17, 0x00	; 0
    61ae:	2f 81       	ldd	r18, Y+7	; 0x07
    61b0:	38 85       	ldd	r19, Y+8	; 0x08
    61b2:	c8 01       	movw	r24, r16
    61b4:	88 0f       	add	r24, r24
    61b6:	99 1f       	adc	r25, r25
    61b8:	88 0f       	add	r24, r24
    61ba:	99 1f       	adc	r25, r25
    61bc:	82 0f       	add	r24, r18
    61be:	93 1f       	adc	r25, r19
    61c0:	fc 01       	movw	r30, r24
    61c2:	b1 96       	adiw	r30, 0x21	; 33
    61c4:	80 81       	ld	r24, Z
    61c6:	91 81       	ldd	r25, Z+1	; 0x01
    61c8:	a2 81       	ldd	r26, Z+2	; 0x02
    61ca:	b3 81       	ldd	r27, Z+3	; 0x03
    61cc:	ac 01       	movw	r20, r24
    61ce:	bd 01       	movw	r22, r26
    61d0:	4f 5f       	subi	r20, 0xFF	; 255
    61d2:	5f 4f       	sbci	r21, 0xFF	; 255
    61d4:	6f 4f       	sbci	r22, 0xFF	; 255
    61d6:	7f 4f       	sbci	r23, 0xFF	; 255
    61d8:	2f 81       	ldd	r18, Y+7	; 0x07
    61da:	38 85       	ldd	r19, Y+8	; 0x08
    61dc:	c8 01       	movw	r24, r16
    61de:	88 0f       	add	r24, r24
    61e0:	99 1f       	adc	r25, r25
    61e2:	88 0f       	add	r24, r24
    61e4:	99 1f       	adc	r25, r25
    61e6:	82 0f       	add	r24, r18
    61e8:	93 1f       	adc	r25, r19
    61ea:	fc 01       	movw	r30, r24
    61ec:	b1 96       	adiw	r30, 0x21	; 33
    61ee:	40 83       	st	Z, r20
    61f0:	51 83       	std	Z+1, r21	; 0x01
    61f2:	62 83       	std	Z+2, r22	; 0x02
    61f4:	73 83       	std	Z+3, r23	; 0x03
    61f6:	30 c0       	rjmp	.+96     	; 0x6258 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    61f8:	8b 85       	ldd	r24, Y+11	; 0x0b
    61fa:	88 2f       	mov	r24, r24
    61fc:	90 e0       	ldi	r25, 0x00	; 0
    61fe:	2f 81       	ldd	r18, Y+7	; 0x07
    6200:	38 85       	ldd	r19, Y+8	; 0x08
    6202:	88 0f       	add	r24, r24
    6204:	99 1f       	adc	r25, r25
    6206:	88 0f       	add	r24, r24
    6208:	99 1f       	adc	r25, r25
    620a:	82 0f       	add	r24, r18
    620c:	93 1f       	adc	r25, r19
    620e:	fc 01       	movw	r30, r24
    6210:	b1 96       	adiw	r30, 0x21	; 33
    6212:	8c 85       	ldd	r24, Y+12	; 0x0c
    6214:	9d 85       	ldd	r25, Y+13	; 0x0d
    6216:	ae 85       	ldd	r26, Y+14	; 0x0e
    6218:	bf 85       	ldd	r27, Y+15	; 0x0f
    621a:	80 83       	st	Z, r24
    621c:	91 83       	std	Z+1, r25	; 0x01
    621e:	a2 83       	std	Z+2, r26	; 0x02
    6220:	b3 83       	std	Z+3, r27	; 0x03
    6222:	1a c0       	rjmp	.+52     	; 0x6258 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    6224:	8d 81       	ldd	r24, Y+5	; 0x05
    6226:	82 30       	cpi	r24, 0x02	; 2
    6228:	b1 f0       	breq	.+44     	; 0x6256 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    622a:	8b 85       	ldd	r24, Y+11	; 0x0b
    622c:	88 2f       	mov	r24, r24
    622e:	90 e0       	ldi	r25, 0x00	; 0
    6230:	2f 81       	ldd	r18, Y+7	; 0x07
    6232:	38 85       	ldd	r19, Y+8	; 0x08
    6234:	88 0f       	add	r24, r24
    6236:	99 1f       	adc	r25, r25
    6238:	88 0f       	add	r24, r24
    623a:	99 1f       	adc	r25, r25
    623c:	82 0f       	add	r24, r18
    623e:	93 1f       	adc	r25, r19
    6240:	fc 01       	movw	r30, r24
    6242:	b1 96       	adiw	r30, 0x21	; 33
    6244:	8c 85       	ldd	r24, Y+12	; 0x0c
    6246:	9d 85       	ldd	r25, Y+13	; 0x0d
    6248:	ae 85       	ldd	r26, Y+14	; 0x0e
    624a:	bf 85       	ldd	r27, Y+15	; 0x0f
    624c:	80 83       	st	Z, r24
    624e:	91 83       	std	Z+1, r25	; 0x01
    6250:	a2 83       	std	Z+2, r26	; 0x02
    6252:	b3 83       	std	Z+3, r27	; 0x03
    6254:	01 c0       	rjmp	.+2      	; 0x6258 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    6256:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6258:	8d 81       	ldd	r24, Y+5	; 0x05
    625a:	81 30       	cpi	r24, 0x01	; 1
    625c:	09 f0       	breq	.+2      	; 0x6260 <xTaskGenericNotify+0x1fe>
    625e:	af c0       	rjmp	.+350    	; 0x63be <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    6260:	ef 81       	ldd	r30, Y+7	; 0x07
    6262:	f8 85       	ldd	r31, Y+8	; 0x08
    6264:	82 85       	ldd	r24, Z+10	; 0x0a
    6266:	93 85       	ldd	r25, Z+11	; 0x0b
    6268:	9c 83       	std	Y+4, r25	; 0x04
    626a:	8b 83       	std	Y+3, r24	; 0x03
    626c:	ef 81       	ldd	r30, Y+7	; 0x07
    626e:	f8 85       	ldd	r31, Y+8	; 0x08
    6270:	a4 81       	ldd	r26, Z+4	; 0x04
    6272:	b5 81       	ldd	r27, Z+5	; 0x05
    6274:	ef 81       	ldd	r30, Y+7	; 0x07
    6276:	f8 85       	ldd	r31, Y+8	; 0x08
    6278:	86 81       	ldd	r24, Z+6	; 0x06
    627a:	97 81       	ldd	r25, Z+7	; 0x07
    627c:	15 96       	adiw	r26, 0x05	; 5
    627e:	9c 93       	st	X, r25
    6280:	8e 93       	st	-X, r24
    6282:	14 97       	sbiw	r26, 0x04	; 4
    6284:	ef 81       	ldd	r30, Y+7	; 0x07
    6286:	f8 85       	ldd	r31, Y+8	; 0x08
    6288:	a6 81       	ldd	r26, Z+6	; 0x06
    628a:	b7 81       	ldd	r27, Z+7	; 0x07
    628c:	ef 81       	ldd	r30, Y+7	; 0x07
    628e:	f8 85       	ldd	r31, Y+8	; 0x08
    6290:	84 81       	ldd	r24, Z+4	; 0x04
    6292:	95 81       	ldd	r25, Z+5	; 0x05
    6294:	13 96       	adiw	r26, 0x03	; 3
    6296:	9c 93       	st	X, r25
    6298:	8e 93       	st	-X, r24
    629a:	12 97       	sbiw	r26, 0x02	; 2
    629c:	eb 81       	ldd	r30, Y+3	; 0x03
    629e:	fc 81       	ldd	r31, Y+4	; 0x04
    62a0:	21 81       	ldd	r18, Z+1	; 0x01
    62a2:	32 81       	ldd	r19, Z+2	; 0x02
    62a4:	8f 81       	ldd	r24, Y+7	; 0x07
    62a6:	98 85       	ldd	r25, Y+8	; 0x08
    62a8:	02 96       	adiw	r24, 0x02	; 2
    62aa:	28 17       	cp	r18, r24
    62ac:	39 07       	cpc	r19, r25
    62ae:	41 f4       	brne	.+16     	; 0x62c0 <xTaskGenericNotify+0x25e>
    62b0:	ef 81       	ldd	r30, Y+7	; 0x07
    62b2:	f8 85       	ldd	r31, Y+8	; 0x08
    62b4:	86 81       	ldd	r24, Z+6	; 0x06
    62b6:	97 81       	ldd	r25, Z+7	; 0x07
    62b8:	eb 81       	ldd	r30, Y+3	; 0x03
    62ba:	fc 81       	ldd	r31, Y+4	; 0x04
    62bc:	92 83       	std	Z+2, r25	; 0x02
    62be:	81 83       	std	Z+1, r24	; 0x01
    62c0:	ef 81       	ldd	r30, Y+7	; 0x07
    62c2:	f8 85       	ldd	r31, Y+8	; 0x08
    62c4:	13 86       	std	Z+11, r1	; 0x0b
    62c6:	12 86       	std	Z+10, r1	; 0x0a
    62c8:	eb 81       	ldd	r30, Y+3	; 0x03
    62ca:	fc 81       	ldd	r31, Y+4	; 0x04
    62cc:	80 81       	ld	r24, Z
    62ce:	81 50       	subi	r24, 0x01	; 1
    62d0:	eb 81       	ldd	r30, Y+3	; 0x03
    62d2:	fc 81       	ldd	r31, Y+4	; 0x04
    62d4:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    62d6:	ef 81       	ldd	r30, Y+7	; 0x07
    62d8:	f8 85       	ldd	r31, Y+8	; 0x08
    62da:	96 89       	ldd	r25, Z+22	; 0x16
    62dc:	80 91 4e 07 	lds	r24, 0x074E
    62e0:	89 17       	cp	r24, r25
    62e2:	28 f4       	brcc	.+10     	; 0x62ee <xTaskGenericNotify+0x28c>
    62e4:	ef 81       	ldd	r30, Y+7	; 0x07
    62e6:	f8 85       	ldd	r31, Y+8	; 0x08
    62e8:	86 89       	ldd	r24, Z+22	; 0x16
    62ea:	80 93 4e 07 	sts	0x074E, r24
    62ee:	ef 81       	ldd	r30, Y+7	; 0x07
    62f0:	f8 85       	ldd	r31, Y+8	; 0x08
    62f2:	86 89       	ldd	r24, Z+22	; 0x16
    62f4:	28 2f       	mov	r18, r24
    62f6:	30 e0       	ldi	r19, 0x00	; 0
    62f8:	c9 01       	movw	r24, r18
    62fa:	88 0f       	add	r24, r24
    62fc:	99 1f       	adc	r25, r25
    62fe:	88 0f       	add	r24, r24
    6300:	99 1f       	adc	r25, r25
    6302:	88 0f       	add	r24, r24
    6304:	99 1f       	adc	r25, r25
    6306:	82 0f       	add	r24, r18
    6308:	93 1f       	adc	r25, r19
    630a:	fc 01       	movw	r30, r24
    630c:	e6 5a       	subi	r30, 0xA6	; 166
    630e:	f8 4f       	sbci	r31, 0xF8	; 248
    6310:	81 81       	ldd	r24, Z+1	; 0x01
    6312:	92 81       	ldd	r25, Z+2	; 0x02
    6314:	9a 83       	std	Y+2, r25	; 0x02
    6316:	89 83       	std	Y+1, r24	; 0x01
    6318:	ef 81       	ldd	r30, Y+7	; 0x07
    631a:	f8 85       	ldd	r31, Y+8	; 0x08
    631c:	89 81       	ldd	r24, Y+1	; 0x01
    631e:	9a 81       	ldd	r25, Y+2	; 0x02
    6320:	95 83       	std	Z+5, r25	; 0x05
    6322:	84 83       	std	Z+4, r24	; 0x04
    6324:	e9 81       	ldd	r30, Y+1	; 0x01
    6326:	fa 81       	ldd	r31, Y+2	; 0x02
    6328:	84 81       	ldd	r24, Z+4	; 0x04
    632a:	95 81       	ldd	r25, Z+5	; 0x05
    632c:	ef 81       	ldd	r30, Y+7	; 0x07
    632e:	f8 85       	ldd	r31, Y+8	; 0x08
    6330:	97 83       	std	Z+7, r25	; 0x07
    6332:	86 83       	std	Z+6, r24	; 0x06
    6334:	e9 81       	ldd	r30, Y+1	; 0x01
    6336:	fa 81       	ldd	r31, Y+2	; 0x02
    6338:	04 80       	ldd	r0, Z+4	; 0x04
    633a:	f5 81       	ldd	r31, Z+5	; 0x05
    633c:	e0 2d       	mov	r30, r0
    633e:	8f 81       	ldd	r24, Y+7	; 0x07
    6340:	98 85       	ldd	r25, Y+8	; 0x08
    6342:	02 96       	adiw	r24, 0x02	; 2
    6344:	93 83       	std	Z+3, r25	; 0x03
    6346:	82 83       	std	Z+2, r24	; 0x02
    6348:	8f 81       	ldd	r24, Y+7	; 0x07
    634a:	98 85       	ldd	r25, Y+8	; 0x08
    634c:	02 96       	adiw	r24, 0x02	; 2
    634e:	e9 81       	ldd	r30, Y+1	; 0x01
    6350:	fa 81       	ldd	r31, Y+2	; 0x02
    6352:	95 83       	std	Z+5, r25	; 0x05
    6354:	84 83       	std	Z+4, r24	; 0x04
    6356:	ef 81       	ldd	r30, Y+7	; 0x07
    6358:	f8 85       	ldd	r31, Y+8	; 0x08
    635a:	86 89       	ldd	r24, Z+22	; 0x16
    635c:	28 2f       	mov	r18, r24
    635e:	30 e0       	ldi	r19, 0x00	; 0
    6360:	c9 01       	movw	r24, r18
    6362:	88 0f       	add	r24, r24
    6364:	99 1f       	adc	r25, r25
    6366:	88 0f       	add	r24, r24
    6368:	99 1f       	adc	r25, r25
    636a:	88 0f       	add	r24, r24
    636c:	99 1f       	adc	r25, r25
    636e:	82 0f       	add	r24, r18
    6370:	93 1f       	adc	r25, r19
    6372:	86 5a       	subi	r24, 0xA6	; 166
    6374:	98 4f       	sbci	r25, 0xF8	; 248
    6376:	ef 81       	ldd	r30, Y+7	; 0x07
    6378:	f8 85       	ldd	r31, Y+8	; 0x08
    637a:	93 87       	std	Z+11, r25	; 0x0b
    637c:	82 87       	std	Z+10, r24	; 0x0a
    637e:	ef 81       	ldd	r30, Y+7	; 0x07
    6380:	f8 85       	ldd	r31, Y+8	; 0x08
    6382:	86 89       	ldd	r24, Z+22	; 0x16
    6384:	28 2f       	mov	r18, r24
    6386:	30 e0       	ldi	r19, 0x00	; 0
    6388:	c9 01       	movw	r24, r18
    638a:	88 0f       	add	r24, r24
    638c:	99 1f       	adc	r25, r25
    638e:	88 0f       	add	r24, r24
    6390:	99 1f       	adc	r25, r25
    6392:	88 0f       	add	r24, r24
    6394:	99 1f       	adc	r25, r25
    6396:	82 0f       	add	r24, r18
    6398:	93 1f       	adc	r25, r19
    639a:	fc 01       	movw	r30, r24
    639c:	e6 5a       	subi	r30, 0xA6	; 166
    639e:	f8 4f       	sbci	r31, 0xF8	; 248
    63a0:	80 81       	ld	r24, Z
    63a2:	8f 5f       	subi	r24, 0xFF	; 255
    63a4:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    63a6:	ef 81       	ldd	r30, Y+7	; 0x07
    63a8:	f8 85       	ldd	r31, Y+8	; 0x08
    63aa:	96 89       	ldd	r25, Z+22	; 0x16
    63ac:	e0 91 48 07 	lds	r30, 0x0748
    63b0:	f0 91 49 07 	lds	r31, 0x0749
    63b4:	86 89       	ldd	r24, Z+22	; 0x16
    63b6:	89 17       	cp	r24, r25
    63b8:	10 f4       	brcc	.+4      	; 0x63be <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    63ba:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    63be:	0f 90       	pop	r0
    63c0:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    63c2:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    63c4:	64 96       	adiw	r28, 0x14	; 20
    63c6:	0f b6       	in	r0, 0x3f	; 63
    63c8:	f8 94       	cli
    63ca:	de bf       	out	0x3e, r29	; 62
    63cc:	0f be       	out	0x3f, r0	; 63
    63ce:	cd bf       	out	0x3d, r28	; 61
    63d0:	cf 91       	pop	r28
    63d2:	df 91       	pop	r29
    63d4:	1f 91       	pop	r17
    63d6:	0f 91       	pop	r16
    63d8:	ff 90       	pop	r15
    63da:	ef 90       	pop	r14
    63dc:	08 95       	ret

000063de <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    63de:	cf 92       	push	r12
    63e0:	df 92       	push	r13
    63e2:	ef 92       	push	r14
    63e4:	ff 92       	push	r15
    63e6:	0f 93       	push	r16
    63e8:	1f 93       	push	r17
    63ea:	df 93       	push	r29
    63ec:	cf 93       	push	r28
    63ee:	cd b7       	in	r28, 0x3d	; 61
    63f0:	de b7       	in	r29, 0x3e	; 62
    63f2:	69 97       	sbiw	r28, 0x19	; 25
    63f4:	0f b6       	in	r0, 0x3f	; 63
    63f6:	f8 94       	cli
    63f8:	de bf       	out	0x3e, r29	; 62
    63fa:	0f be       	out	0x3f, r0	; 63
    63fc:	cd bf       	out	0x3d, r28	; 61
    63fe:	9d 87       	std	Y+13, r25	; 0x0d
    6400:	8c 87       	std	Y+12, r24	; 0x0c
    6402:	6e 87       	std	Y+14, r22	; 0x0e
    6404:	2f 87       	std	Y+15, r18	; 0x0f
    6406:	38 8b       	std	Y+16, r19	; 0x10
    6408:	49 8b       	std	Y+17, r20	; 0x11
    640a:	5a 8b       	std	Y+18, r21	; 0x12
    640c:	0b 8b       	std	Y+19, r16	; 0x13
    640e:	fd 8a       	std	Y+21, r15	; 0x15
    6410:	ec 8a       	std	Y+20, r14	; 0x14
    6412:	df 8a       	std	Y+23, r13	; 0x17
    6414:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    6416:	81 e0       	ldi	r24, 0x01	; 1
    6418:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    641a:	8c 85       	ldd	r24, Y+12	; 0x0c
    641c:	9d 85       	ldd	r25, Y+13	; 0x0d
    641e:	9b 87       	std	Y+11, r25	; 0x0b
    6420:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6422:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    6424:	8c 89       	ldd	r24, Y+20	; 0x14
    6426:	9d 89       	ldd	r25, Y+21	; 0x15
    6428:	00 97       	sbiw	r24, 0x00	; 0
    642a:	b9 f0       	breq	.+46     	; 0x645a <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    642c:	8e 85       	ldd	r24, Y+14	; 0x0e
    642e:	88 2f       	mov	r24, r24
    6430:	90 e0       	ldi	r25, 0x00	; 0
    6432:	2a 85       	ldd	r18, Y+10	; 0x0a
    6434:	3b 85       	ldd	r19, Y+11	; 0x0b
    6436:	88 0f       	add	r24, r24
    6438:	99 1f       	adc	r25, r25
    643a:	88 0f       	add	r24, r24
    643c:	99 1f       	adc	r25, r25
    643e:	82 0f       	add	r24, r18
    6440:	93 1f       	adc	r25, r19
    6442:	fc 01       	movw	r30, r24
    6444:	b1 96       	adiw	r30, 0x21	; 33
    6446:	80 81       	ld	r24, Z
    6448:	91 81       	ldd	r25, Z+1	; 0x01
    644a:	a2 81       	ldd	r26, Z+2	; 0x02
    644c:	b3 81       	ldd	r27, Z+3	; 0x03
    644e:	ec 89       	ldd	r30, Y+20	; 0x14
    6450:	fd 89       	ldd	r31, Y+21	; 0x15
    6452:	80 83       	st	Z, r24
    6454:	91 83       	std	Z+1, r25	; 0x01
    6456:	a2 83       	std	Z+2, r26	; 0x02
    6458:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    645a:	8e 85       	ldd	r24, Y+14	; 0x0e
    645c:	28 2f       	mov	r18, r24
    645e:	30 e0       	ldi	r19, 0x00	; 0
    6460:	8a 85       	ldd	r24, Y+10	; 0x0a
    6462:	9b 85       	ldd	r25, Y+11	; 0x0b
    6464:	82 0f       	add	r24, r18
    6466:	93 1f       	adc	r25, r19
    6468:	fc 01       	movw	r30, r24
    646a:	b5 96       	adiw	r30, 0x25	; 37
    646c:	80 81       	ld	r24, Z
    646e:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    6470:	8e 85       	ldd	r24, Y+14	; 0x0e
    6472:	28 2f       	mov	r18, r24
    6474:	30 e0       	ldi	r19, 0x00	; 0
    6476:	8a 85       	ldd	r24, Y+10	; 0x0a
    6478:	9b 85       	ldd	r25, Y+11	; 0x0b
    647a:	82 0f       	add	r24, r18
    647c:	93 1f       	adc	r25, r19
    647e:	fc 01       	movw	r30, r24
    6480:	b5 96       	adiw	r30, 0x25	; 37
    6482:	82 e0       	ldi	r24, 0x02	; 2
    6484:	80 83       	st	Z, r24

            switch( eAction )
    6486:	8b 89       	ldd	r24, Y+19	; 0x13
    6488:	28 2f       	mov	r18, r24
    648a:	30 e0       	ldi	r19, 0x00	; 0
    648c:	39 8f       	std	Y+25, r19	; 0x19
    648e:	28 8f       	std	Y+24, r18	; 0x18
    6490:	88 8d       	ldd	r24, Y+24	; 0x18
    6492:	99 8d       	ldd	r25, Y+25	; 0x19
    6494:	82 30       	cpi	r24, 0x02	; 2
    6496:	91 05       	cpc	r25, r1
    6498:	09 f4       	brne	.+2      	; 0x649c <xTaskGenericNotifyFromISR+0xbe>
    649a:	46 c0       	rjmp	.+140    	; 0x6528 <xTaskGenericNotifyFromISR+0x14a>
    649c:	28 8d       	ldd	r18, Y+24	; 0x18
    649e:	39 8d       	ldd	r19, Y+25	; 0x19
    64a0:	23 30       	cpi	r18, 0x03	; 3
    64a2:	31 05       	cpc	r19, r1
    64a4:	34 f4       	brge	.+12     	; 0x64b2 <xTaskGenericNotifyFromISR+0xd4>
    64a6:	88 8d       	ldd	r24, Y+24	; 0x18
    64a8:	99 8d       	ldd	r25, Y+25	; 0x19
    64aa:	81 30       	cpi	r24, 0x01	; 1
    64ac:	91 05       	cpc	r25, r1
    64ae:	71 f0       	breq	.+28     	; 0x64cc <xTaskGenericNotifyFromISR+0xee>
    64b0:	93 c0       	rjmp	.+294    	; 0x65d8 <xTaskGenericNotifyFromISR+0x1fa>
    64b2:	28 8d       	ldd	r18, Y+24	; 0x18
    64b4:	39 8d       	ldd	r19, Y+25	; 0x19
    64b6:	23 30       	cpi	r18, 0x03	; 3
    64b8:	31 05       	cpc	r19, r1
    64ba:	09 f4       	brne	.+2      	; 0x64be <xTaskGenericNotifyFromISR+0xe0>
    64bc:	5d c0       	rjmp	.+186    	; 0x6578 <xTaskGenericNotifyFromISR+0x19a>
    64be:	88 8d       	ldd	r24, Y+24	; 0x18
    64c0:	99 8d       	ldd	r25, Y+25	; 0x19
    64c2:	84 30       	cpi	r24, 0x04	; 4
    64c4:	91 05       	cpc	r25, r1
    64c6:	09 f4       	brne	.+2      	; 0x64ca <xTaskGenericNotifyFromISR+0xec>
    64c8:	6d c0       	rjmp	.+218    	; 0x65a4 <xTaskGenericNotifyFromISR+0x1c6>
    64ca:	86 c0       	rjmp	.+268    	; 0x65d8 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    64cc:	8e 85       	ldd	r24, Y+14	; 0x0e
    64ce:	08 2f       	mov	r16, r24
    64d0:	10 e0       	ldi	r17, 0x00	; 0
    64d2:	8e 85       	ldd	r24, Y+14	; 0x0e
    64d4:	88 2f       	mov	r24, r24
    64d6:	90 e0       	ldi	r25, 0x00	; 0
    64d8:	2a 85       	ldd	r18, Y+10	; 0x0a
    64da:	3b 85       	ldd	r19, Y+11	; 0x0b
    64dc:	88 0f       	add	r24, r24
    64de:	99 1f       	adc	r25, r25
    64e0:	88 0f       	add	r24, r24
    64e2:	99 1f       	adc	r25, r25
    64e4:	82 0f       	add	r24, r18
    64e6:	93 1f       	adc	r25, r19
    64e8:	fc 01       	movw	r30, r24
    64ea:	b1 96       	adiw	r30, 0x21	; 33
    64ec:	20 81       	ld	r18, Z
    64ee:	31 81       	ldd	r19, Z+1	; 0x01
    64f0:	42 81       	ldd	r20, Z+2	; 0x02
    64f2:	53 81       	ldd	r21, Z+3	; 0x03
    64f4:	8f 85       	ldd	r24, Y+15	; 0x0f
    64f6:	98 89       	ldd	r25, Y+16	; 0x10
    64f8:	a9 89       	ldd	r26, Y+17	; 0x11
    64fa:	ba 89       	ldd	r27, Y+18	; 0x12
    64fc:	ba 01       	movw	r22, r20
    64fe:	a9 01       	movw	r20, r18
    6500:	48 2b       	or	r20, r24
    6502:	59 2b       	or	r21, r25
    6504:	6a 2b       	or	r22, r26
    6506:	7b 2b       	or	r23, r27
    6508:	2a 85       	ldd	r18, Y+10	; 0x0a
    650a:	3b 85       	ldd	r19, Y+11	; 0x0b
    650c:	c8 01       	movw	r24, r16
    650e:	88 0f       	add	r24, r24
    6510:	99 1f       	adc	r25, r25
    6512:	88 0f       	add	r24, r24
    6514:	99 1f       	adc	r25, r25
    6516:	82 0f       	add	r24, r18
    6518:	93 1f       	adc	r25, r19
    651a:	fc 01       	movw	r30, r24
    651c:	b1 96       	adiw	r30, 0x21	; 33
    651e:	40 83       	st	Z, r20
    6520:	51 83       	std	Z+1, r21	; 0x01
    6522:	62 83       	std	Z+2, r22	; 0x02
    6524:	73 83       	std	Z+3, r23	; 0x03
    6526:	58 c0       	rjmp	.+176    	; 0x65d8 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    6528:	8e 85       	ldd	r24, Y+14	; 0x0e
    652a:	08 2f       	mov	r16, r24
    652c:	10 e0       	ldi	r17, 0x00	; 0
    652e:	2a 85       	ldd	r18, Y+10	; 0x0a
    6530:	3b 85       	ldd	r19, Y+11	; 0x0b
    6532:	c8 01       	movw	r24, r16
    6534:	88 0f       	add	r24, r24
    6536:	99 1f       	adc	r25, r25
    6538:	88 0f       	add	r24, r24
    653a:	99 1f       	adc	r25, r25
    653c:	82 0f       	add	r24, r18
    653e:	93 1f       	adc	r25, r19
    6540:	fc 01       	movw	r30, r24
    6542:	b1 96       	adiw	r30, 0x21	; 33
    6544:	80 81       	ld	r24, Z
    6546:	91 81       	ldd	r25, Z+1	; 0x01
    6548:	a2 81       	ldd	r26, Z+2	; 0x02
    654a:	b3 81       	ldd	r27, Z+3	; 0x03
    654c:	ac 01       	movw	r20, r24
    654e:	bd 01       	movw	r22, r26
    6550:	4f 5f       	subi	r20, 0xFF	; 255
    6552:	5f 4f       	sbci	r21, 0xFF	; 255
    6554:	6f 4f       	sbci	r22, 0xFF	; 255
    6556:	7f 4f       	sbci	r23, 0xFF	; 255
    6558:	2a 85       	ldd	r18, Y+10	; 0x0a
    655a:	3b 85       	ldd	r19, Y+11	; 0x0b
    655c:	c8 01       	movw	r24, r16
    655e:	88 0f       	add	r24, r24
    6560:	99 1f       	adc	r25, r25
    6562:	88 0f       	add	r24, r24
    6564:	99 1f       	adc	r25, r25
    6566:	82 0f       	add	r24, r18
    6568:	93 1f       	adc	r25, r19
    656a:	fc 01       	movw	r30, r24
    656c:	b1 96       	adiw	r30, 0x21	; 33
    656e:	40 83       	st	Z, r20
    6570:	51 83       	std	Z+1, r21	; 0x01
    6572:	62 83       	std	Z+2, r22	; 0x02
    6574:	73 83       	std	Z+3, r23	; 0x03
    6576:	30 c0       	rjmp	.+96     	; 0x65d8 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    6578:	8e 85       	ldd	r24, Y+14	; 0x0e
    657a:	88 2f       	mov	r24, r24
    657c:	90 e0       	ldi	r25, 0x00	; 0
    657e:	2a 85       	ldd	r18, Y+10	; 0x0a
    6580:	3b 85       	ldd	r19, Y+11	; 0x0b
    6582:	88 0f       	add	r24, r24
    6584:	99 1f       	adc	r25, r25
    6586:	88 0f       	add	r24, r24
    6588:	99 1f       	adc	r25, r25
    658a:	82 0f       	add	r24, r18
    658c:	93 1f       	adc	r25, r19
    658e:	fc 01       	movw	r30, r24
    6590:	b1 96       	adiw	r30, 0x21	; 33
    6592:	8f 85       	ldd	r24, Y+15	; 0x0f
    6594:	98 89       	ldd	r25, Y+16	; 0x10
    6596:	a9 89       	ldd	r26, Y+17	; 0x11
    6598:	ba 89       	ldd	r27, Y+18	; 0x12
    659a:	80 83       	st	Z, r24
    659c:	91 83       	std	Z+1, r25	; 0x01
    659e:	a2 83       	std	Z+2, r26	; 0x02
    65a0:	b3 83       	std	Z+3, r27	; 0x03
    65a2:	1a c0       	rjmp	.+52     	; 0x65d8 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    65a4:	89 85       	ldd	r24, Y+9	; 0x09
    65a6:	82 30       	cpi	r24, 0x02	; 2
    65a8:	b1 f0       	breq	.+44     	; 0x65d6 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    65aa:	8e 85       	ldd	r24, Y+14	; 0x0e
    65ac:	88 2f       	mov	r24, r24
    65ae:	90 e0       	ldi	r25, 0x00	; 0
    65b0:	2a 85       	ldd	r18, Y+10	; 0x0a
    65b2:	3b 85       	ldd	r19, Y+11	; 0x0b
    65b4:	88 0f       	add	r24, r24
    65b6:	99 1f       	adc	r25, r25
    65b8:	88 0f       	add	r24, r24
    65ba:	99 1f       	adc	r25, r25
    65bc:	82 0f       	add	r24, r18
    65be:	93 1f       	adc	r25, r19
    65c0:	fc 01       	movw	r30, r24
    65c2:	b1 96       	adiw	r30, 0x21	; 33
    65c4:	8f 85       	ldd	r24, Y+15	; 0x0f
    65c6:	98 89       	ldd	r25, Y+16	; 0x10
    65c8:	a9 89       	ldd	r26, Y+17	; 0x11
    65ca:	ba 89       	ldd	r27, Y+18	; 0x12
    65cc:	80 83       	st	Z, r24
    65ce:	91 83       	std	Z+1, r25	; 0x01
    65d0:	a2 83       	std	Z+2, r26	; 0x02
    65d2:	b3 83       	std	Z+3, r27	; 0x03
    65d4:	01 c0       	rjmp	.+2      	; 0x65d8 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    65d6:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    65d8:	89 85       	ldd	r24, Y+9	; 0x09
    65da:	81 30       	cpi	r24, 0x01	; 1
    65dc:	09 f0       	breq	.+2      	; 0x65e0 <xTaskGenericNotifyFromISR+0x202>
    65de:	ee c0       	rjmp	.+476    	; 0x67bc <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    65e0:	80 91 59 07 	lds	r24, 0x0759
    65e4:	88 23       	and	r24, r24
    65e6:	09 f0       	breq	.+2      	; 0x65ea <xTaskGenericNotifyFromISR+0x20c>
    65e8:	a4 c0       	rjmp	.+328    	; 0x6732 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    65ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    65ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    65ee:	82 85       	ldd	r24, Z+10	; 0x0a
    65f0:	93 85       	ldd	r25, Z+11	; 0x0b
    65f2:	9e 83       	std	Y+6, r25	; 0x06
    65f4:	8d 83       	std	Y+5, r24	; 0x05
    65f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    65f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    65fa:	a4 81       	ldd	r26, Z+4	; 0x04
    65fc:	b5 81       	ldd	r27, Z+5	; 0x05
    65fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    6600:	fb 85       	ldd	r31, Y+11	; 0x0b
    6602:	86 81       	ldd	r24, Z+6	; 0x06
    6604:	97 81       	ldd	r25, Z+7	; 0x07
    6606:	15 96       	adiw	r26, 0x05	; 5
    6608:	9c 93       	st	X, r25
    660a:	8e 93       	st	-X, r24
    660c:	14 97       	sbiw	r26, 0x04	; 4
    660e:	ea 85       	ldd	r30, Y+10	; 0x0a
    6610:	fb 85       	ldd	r31, Y+11	; 0x0b
    6612:	a6 81       	ldd	r26, Z+6	; 0x06
    6614:	b7 81       	ldd	r27, Z+7	; 0x07
    6616:	ea 85       	ldd	r30, Y+10	; 0x0a
    6618:	fb 85       	ldd	r31, Y+11	; 0x0b
    661a:	84 81       	ldd	r24, Z+4	; 0x04
    661c:	95 81       	ldd	r25, Z+5	; 0x05
    661e:	13 96       	adiw	r26, 0x03	; 3
    6620:	9c 93       	st	X, r25
    6622:	8e 93       	st	-X, r24
    6624:	12 97       	sbiw	r26, 0x02	; 2
    6626:	ed 81       	ldd	r30, Y+5	; 0x05
    6628:	fe 81       	ldd	r31, Y+6	; 0x06
    662a:	21 81       	ldd	r18, Z+1	; 0x01
    662c:	32 81       	ldd	r19, Z+2	; 0x02
    662e:	8a 85       	ldd	r24, Y+10	; 0x0a
    6630:	9b 85       	ldd	r25, Y+11	; 0x0b
    6632:	02 96       	adiw	r24, 0x02	; 2
    6634:	28 17       	cp	r18, r24
    6636:	39 07       	cpc	r19, r25
    6638:	41 f4       	brne	.+16     	; 0x664a <xTaskGenericNotifyFromISR+0x26c>
    663a:	ea 85       	ldd	r30, Y+10	; 0x0a
    663c:	fb 85       	ldd	r31, Y+11	; 0x0b
    663e:	86 81       	ldd	r24, Z+6	; 0x06
    6640:	97 81       	ldd	r25, Z+7	; 0x07
    6642:	ed 81       	ldd	r30, Y+5	; 0x05
    6644:	fe 81       	ldd	r31, Y+6	; 0x06
    6646:	92 83       	std	Z+2, r25	; 0x02
    6648:	81 83       	std	Z+1, r24	; 0x01
    664a:	ea 85       	ldd	r30, Y+10	; 0x0a
    664c:	fb 85       	ldd	r31, Y+11	; 0x0b
    664e:	13 86       	std	Z+11, r1	; 0x0b
    6650:	12 86       	std	Z+10, r1	; 0x0a
    6652:	ed 81       	ldd	r30, Y+5	; 0x05
    6654:	fe 81       	ldd	r31, Y+6	; 0x06
    6656:	80 81       	ld	r24, Z
    6658:	81 50       	subi	r24, 0x01	; 1
    665a:	ed 81       	ldd	r30, Y+5	; 0x05
    665c:	fe 81       	ldd	r31, Y+6	; 0x06
    665e:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    6660:	ea 85       	ldd	r30, Y+10	; 0x0a
    6662:	fb 85       	ldd	r31, Y+11	; 0x0b
    6664:	96 89       	ldd	r25, Z+22	; 0x16
    6666:	80 91 4e 07 	lds	r24, 0x074E
    666a:	89 17       	cp	r24, r25
    666c:	28 f4       	brcc	.+10     	; 0x6678 <xTaskGenericNotifyFromISR+0x29a>
    666e:	ea 85       	ldd	r30, Y+10	; 0x0a
    6670:	fb 85       	ldd	r31, Y+11	; 0x0b
    6672:	86 89       	ldd	r24, Z+22	; 0x16
    6674:	80 93 4e 07 	sts	0x074E, r24
    6678:	ea 85       	ldd	r30, Y+10	; 0x0a
    667a:	fb 85       	ldd	r31, Y+11	; 0x0b
    667c:	86 89       	ldd	r24, Z+22	; 0x16
    667e:	28 2f       	mov	r18, r24
    6680:	30 e0       	ldi	r19, 0x00	; 0
    6682:	c9 01       	movw	r24, r18
    6684:	88 0f       	add	r24, r24
    6686:	99 1f       	adc	r25, r25
    6688:	88 0f       	add	r24, r24
    668a:	99 1f       	adc	r25, r25
    668c:	88 0f       	add	r24, r24
    668e:	99 1f       	adc	r25, r25
    6690:	82 0f       	add	r24, r18
    6692:	93 1f       	adc	r25, r19
    6694:	fc 01       	movw	r30, r24
    6696:	e6 5a       	subi	r30, 0xA6	; 166
    6698:	f8 4f       	sbci	r31, 0xF8	; 248
    669a:	81 81       	ldd	r24, Z+1	; 0x01
    669c:	92 81       	ldd	r25, Z+2	; 0x02
    669e:	9c 83       	std	Y+4, r25	; 0x04
    66a0:	8b 83       	std	Y+3, r24	; 0x03
    66a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    66a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    66a6:	8b 81       	ldd	r24, Y+3	; 0x03
    66a8:	9c 81       	ldd	r25, Y+4	; 0x04
    66aa:	95 83       	std	Z+5, r25	; 0x05
    66ac:	84 83       	std	Z+4, r24	; 0x04
    66ae:	eb 81       	ldd	r30, Y+3	; 0x03
    66b0:	fc 81       	ldd	r31, Y+4	; 0x04
    66b2:	84 81       	ldd	r24, Z+4	; 0x04
    66b4:	95 81       	ldd	r25, Z+5	; 0x05
    66b6:	ea 85       	ldd	r30, Y+10	; 0x0a
    66b8:	fb 85       	ldd	r31, Y+11	; 0x0b
    66ba:	97 83       	std	Z+7, r25	; 0x07
    66bc:	86 83       	std	Z+6, r24	; 0x06
    66be:	eb 81       	ldd	r30, Y+3	; 0x03
    66c0:	fc 81       	ldd	r31, Y+4	; 0x04
    66c2:	04 80       	ldd	r0, Z+4	; 0x04
    66c4:	f5 81       	ldd	r31, Z+5	; 0x05
    66c6:	e0 2d       	mov	r30, r0
    66c8:	8a 85       	ldd	r24, Y+10	; 0x0a
    66ca:	9b 85       	ldd	r25, Y+11	; 0x0b
    66cc:	02 96       	adiw	r24, 0x02	; 2
    66ce:	93 83       	std	Z+3, r25	; 0x03
    66d0:	82 83       	std	Z+2, r24	; 0x02
    66d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    66d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    66d6:	02 96       	adiw	r24, 0x02	; 2
    66d8:	eb 81       	ldd	r30, Y+3	; 0x03
    66da:	fc 81       	ldd	r31, Y+4	; 0x04
    66dc:	95 83       	std	Z+5, r25	; 0x05
    66de:	84 83       	std	Z+4, r24	; 0x04
    66e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    66e2:	fb 85       	ldd	r31, Y+11	; 0x0b
    66e4:	86 89       	ldd	r24, Z+22	; 0x16
    66e6:	28 2f       	mov	r18, r24
    66e8:	30 e0       	ldi	r19, 0x00	; 0
    66ea:	c9 01       	movw	r24, r18
    66ec:	88 0f       	add	r24, r24
    66ee:	99 1f       	adc	r25, r25
    66f0:	88 0f       	add	r24, r24
    66f2:	99 1f       	adc	r25, r25
    66f4:	88 0f       	add	r24, r24
    66f6:	99 1f       	adc	r25, r25
    66f8:	82 0f       	add	r24, r18
    66fa:	93 1f       	adc	r25, r19
    66fc:	86 5a       	subi	r24, 0xA6	; 166
    66fe:	98 4f       	sbci	r25, 0xF8	; 248
    6700:	ea 85       	ldd	r30, Y+10	; 0x0a
    6702:	fb 85       	ldd	r31, Y+11	; 0x0b
    6704:	93 87       	std	Z+11, r25	; 0x0b
    6706:	82 87       	std	Z+10, r24	; 0x0a
    6708:	ea 85       	ldd	r30, Y+10	; 0x0a
    670a:	fb 85       	ldd	r31, Y+11	; 0x0b
    670c:	86 89       	ldd	r24, Z+22	; 0x16
    670e:	28 2f       	mov	r18, r24
    6710:	30 e0       	ldi	r19, 0x00	; 0
    6712:	c9 01       	movw	r24, r18
    6714:	88 0f       	add	r24, r24
    6716:	99 1f       	adc	r25, r25
    6718:	88 0f       	add	r24, r24
    671a:	99 1f       	adc	r25, r25
    671c:	88 0f       	add	r24, r24
    671e:	99 1f       	adc	r25, r25
    6720:	82 0f       	add	r24, r18
    6722:	93 1f       	adc	r25, r19
    6724:	fc 01       	movw	r30, r24
    6726:	e6 5a       	subi	r30, 0xA6	; 166
    6728:	f8 4f       	sbci	r31, 0xF8	; 248
    672a:	80 81       	ld	r24, Z
    672c:	8f 5f       	subi	r24, 0xFF	; 255
    672e:	80 83       	st	Z, r24
    6730:	30 c0       	rjmp	.+96     	; 0x6792 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    6732:	80 91 95 07 	lds	r24, 0x0795
    6736:	90 91 96 07 	lds	r25, 0x0796
    673a:	9a 83       	std	Y+2, r25	; 0x02
    673c:	89 83       	std	Y+1, r24	; 0x01
    673e:	ea 85       	ldd	r30, Y+10	; 0x0a
    6740:	fb 85       	ldd	r31, Y+11	; 0x0b
    6742:	89 81       	ldd	r24, Y+1	; 0x01
    6744:	9a 81       	ldd	r25, Y+2	; 0x02
    6746:	97 87       	std	Z+15, r25	; 0x0f
    6748:	86 87       	std	Z+14, r24	; 0x0e
    674a:	e9 81       	ldd	r30, Y+1	; 0x01
    674c:	fa 81       	ldd	r31, Y+2	; 0x02
    674e:	84 81       	ldd	r24, Z+4	; 0x04
    6750:	95 81       	ldd	r25, Z+5	; 0x05
    6752:	ea 85       	ldd	r30, Y+10	; 0x0a
    6754:	fb 85       	ldd	r31, Y+11	; 0x0b
    6756:	91 8b       	std	Z+17, r25	; 0x11
    6758:	80 8b       	std	Z+16, r24	; 0x10
    675a:	e9 81       	ldd	r30, Y+1	; 0x01
    675c:	fa 81       	ldd	r31, Y+2	; 0x02
    675e:	04 80       	ldd	r0, Z+4	; 0x04
    6760:	f5 81       	ldd	r31, Z+5	; 0x05
    6762:	e0 2d       	mov	r30, r0
    6764:	8a 85       	ldd	r24, Y+10	; 0x0a
    6766:	9b 85       	ldd	r25, Y+11	; 0x0b
    6768:	0c 96       	adiw	r24, 0x0c	; 12
    676a:	93 83       	std	Z+3, r25	; 0x03
    676c:	82 83       	std	Z+2, r24	; 0x02
    676e:	8a 85       	ldd	r24, Y+10	; 0x0a
    6770:	9b 85       	ldd	r25, Y+11	; 0x0b
    6772:	0c 96       	adiw	r24, 0x0c	; 12
    6774:	e9 81       	ldd	r30, Y+1	; 0x01
    6776:	fa 81       	ldd	r31, Y+2	; 0x02
    6778:	95 83       	std	Z+5, r25	; 0x05
    677a:	84 83       	std	Z+4, r24	; 0x04
    677c:	ea 85       	ldd	r30, Y+10	; 0x0a
    677e:	fb 85       	ldd	r31, Y+11	; 0x0b
    6780:	84 e9       	ldi	r24, 0x94	; 148
    6782:	97 e0       	ldi	r25, 0x07	; 7
    6784:	95 8b       	std	Z+21, r25	; 0x15
    6786:	84 8b       	std	Z+20, r24	; 0x14
    6788:	80 91 94 07 	lds	r24, 0x0794
    678c:	8f 5f       	subi	r24, 0xFF	; 255
    678e:	80 93 94 07 	sts	0x0794, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6792:	ea 85       	ldd	r30, Y+10	; 0x0a
    6794:	fb 85       	ldd	r31, Y+11	; 0x0b
    6796:	96 89       	ldd	r25, Z+22	; 0x16
    6798:	e0 91 48 07 	lds	r30, 0x0748
    679c:	f0 91 49 07 	lds	r31, 0x0749
    67a0:	86 89       	ldd	r24, Z+22	; 0x16
    67a2:	89 17       	cp	r24, r25
    67a4:	58 f4       	brcc	.+22     	; 0x67bc <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    67a6:	8e 89       	ldd	r24, Y+22	; 0x16
    67a8:	9f 89       	ldd	r25, Y+23	; 0x17
    67aa:	00 97       	sbiw	r24, 0x00	; 0
    67ac:	21 f0       	breq	.+8      	; 0x67b6 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    67ae:	ee 89       	ldd	r30, Y+22	; 0x16
    67b0:	ff 89       	ldd	r31, Y+23	; 0x17
    67b2:	81 e0       	ldi	r24, 0x01	; 1
    67b4:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    67b6:	81 e0       	ldi	r24, 0x01	; 1
    67b8:	80 93 52 07 	sts	0x0752, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    67bc:	88 85       	ldd	r24, Y+8	; 0x08
    }
    67be:	69 96       	adiw	r28, 0x19	; 25
    67c0:	0f b6       	in	r0, 0x3f	; 63
    67c2:	f8 94       	cli
    67c4:	de bf       	out	0x3e, r29	; 62
    67c6:	0f be       	out	0x3f, r0	; 63
    67c8:	cd bf       	out	0x3d, r28	; 61
    67ca:	cf 91       	pop	r28
    67cc:	df 91       	pop	r29
    67ce:	1f 91       	pop	r17
    67d0:	0f 91       	pop	r16
    67d2:	ff 90       	pop	r15
    67d4:	ef 90       	pop	r14
    67d6:	df 90       	pop	r13
    67d8:	cf 90       	pop	r12
    67da:	08 95       	ret

000067dc <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    67dc:	0f 93       	push	r16
    67de:	1f 93       	push	r17
    67e0:	df 93       	push	r29
    67e2:	cf 93       	push	r28
    67e4:	cd b7       	in	r28, 0x3d	; 61
    67e6:	de b7       	in	r29, 0x3e	; 62
    67e8:	2f 97       	sbiw	r28, 0x0f	; 15
    67ea:	0f b6       	in	r0, 0x3f	; 63
    67ec:	f8 94       	cli
    67ee:	de bf       	out	0x3e, r29	; 62
    67f0:	0f be       	out	0x3f, r0	; 63
    67f2:	cd bf       	out	0x3d, r28	; 61
    67f4:	9c 87       	std	Y+12, r25	; 0x0c
    67f6:	8b 87       	std	Y+11, r24	; 0x0b
    67f8:	6d 87       	std	Y+13, r22	; 0x0d
    67fa:	5f 87       	std	Y+15, r21	; 0x0f
    67fc:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    67fe:	8b 85       	ldd	r24, Y+11	; 0x0b
    6800:	9c 85       	ldd	r25, Y+12	; 0x0c
    6802:	9a 87       	std	Y+10, r25	; 0x0a
    6804:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6806:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    6808:	8d 85       	ldd	r24, Y+13	; 0x0d
    680a:	28 2f       	mov	r18, r24
    680c:	30 e0       	ldi	r19, 0x00	; 0
    680e:	89 85       	ldd	r24, Y+9	; 0x09
    6810:	9a 85       	ldd	r25, Y+10	; 0x0a
    6812:	82 0f       	add	r24, r18
    6814:	93 1f       	adc	r25, r19
    6816:	fc 01       	movw	r30, r24
    6818:	b5 96       	adiw	r30, 0x25	; 37
    681a:	80 81       	ld	r24, Z
    681c:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    681e:	8d 85       	ldd	r24, Y+13	; 0x0d
    6820:	28 2f       	mov	r18, r24
    6822:	30 e0       	ldi	r19, 0x00	; 0
    6824:	89 85       	ldd	r24, Y+9	; 0x09
    6826:	9a 85       	ldd	r25, Y+10	; 0x0a
    6828:	82 0f       	add	r24, r18
    682a:	93 1f       	adc	r25, r19
    682c:	fc 01       	movw	r30, r24
    682e:	b5 96       	adiw	r30, 0x25	; 37
    6830:	82 e0       	ldi	r24, 0x02	; 2
    6832:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    6834:	8d 85       	ldd	r24, Y+13	; 0x0d
    6836:	08 2f       	mov	r16, r24
    6838:	10 e0       	ldi	r17, 0x00	; 0
    683a:	29 85       	ldd	r18, Y+9	; 0x09
    683c:	3a 85       	ldd	r19, Y+10	; 0x0a
    683e:	c8 01       	movw	r24, r16
    6840:	88 0f       	add	r24, r24
    6842:	99 1f       	adc	r25, r25
    6844:	88 0f       	add	r24, r24
    6846:	99 1f       	adc	r25, r25
    6848:	82 0f       	add	r24, r18
    684a:	93 1f       	adc	r25, r19
    684c:	fc 01       	movw	r30, r24
    684e:	b1 96       	adiw	r30, 0x21	; 33
    6850:	80 81       	ld	r24, Z
    6852:	91 81       	ldd	r25, Z+1	; 0x01
    6854:	a2 81       	ldd	r26, Z+2	; 0x02
    6856:	b3 81       	ldd	r27, Z+3	; 0x03
    6858:	ac 01       	movw	r20, r24
    685a:	bd 01       	movw	r22, r26
    685c:	4f 5f       	subi	r20, 0xFF	; 255
    685e:	5f 4f       	sbci	r21, 0xFF	; 255
    6860:	6f 4f       	sbci	r22, 0xFF	; 255
    6862:	7f 4f       	sbci	r23, 0xFF	; 255
    6864:	29 85       	ldd	r18, Y+9	; 0x09
    6866:	3a 85       	ldd	r19, Y+10	; 0x0a
    6868:	c8 01       	movw	r24, r16
    686a:	88 0f       	add	r24, r24
    686c:	99 1f       	adc	r25, r25
    686e:	88 0f       	add	r24, r24
    6870:	99 1f       	adc	r25, r25
    6872:	82 0f       	add	r24, r18
    6874:	93 1f       	adc	r25, r19
    6876:	fc 01       	movw	r30, r24
    6878:	b1 96       	adiw	r30, 0x21	; 33
    687a:	40 83       	st	Z, r20
    687c:	51 83       	std	Z+1, r21	; 0x01
    687e:	62 83       	std	Z+2, r22	; 0x02
    6880:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6882:	88 85       	ldd	r24, Y+8	; 0x08
    6884:	81 30       	cpi	r24, 0x01	; 1
    6886:	09 f0       	breq	.+2      	; 0x688a <vTaskGenericNotifyGiveFromISR+0xae>
    6888:	ee c0       	rjmp	.+476    	; 0x6a66 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    688a:	80 91 59 07 	lds	r24, 0x0759
    688e:	88 23       	and	r24, r24
    6890:	09 f0       	breq	.+2      	; 0x6894 <vTaskGenericNotifyGiveFromISR+0xb8>
    6892:	a4 c0       	rjmp	.+328    	; 0x69dc <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    6894:	e9 85       	ldd	r30, Y+9	; 0x09
    6896:	fa 85       	ldd	r31, Y+10	; 0x0a
    6898:	82 85       	ldd	r24, Z+10	; 0x0a
    689a:	93 85       	ldd	r25, Z+11	; 0x0b
    689c:	9e 83       	std	Y+6, r25	; 0x06
    689e:	8d 83       	std	Y+5, r24	; 0x05
    68a0:	e9 85       	ldd	r30, Y+9	; 0x09
    68a2:	fa 85       	ldd	r31, Y+10	; 0x0a
    68a4:	a4 81       	ldd	r26, Z+4	; 0x04
    68a6:	b5 81       	ldd	r27, Z+5	; 0x05
    68a8:	e9 85       	ldd	r30, Y+9	; 0x09
    68aa:	fa 85       	ldd	r31, Y+10	; 0x0a
    68ac:	86 81       	ldd	r24, Z+6	; 0x06
    68ae:	97 81       	ldd	r25, Z+7	; 0x07
    68b0:	15 96       	adiw	r26, 0x05	; 5
    68b2:	9c 93       	st	X, r25
    68b4:	8e 93       	st	-X, r24
    68b6:	14 97       	sbiw	r26, 0x04	; 4
    68b8:	e9 85       	ldd	r30, Y+9	; 0x09
    68ba:	fa 85       	ldd	r31, Y+10	; 0x0a
    68bc:	a6 81       	ldd	r26, Z+6	; 0x06
    68be:	b7 81       	ldd	r27, Z+7	; 0x07
    68c0:	e9 85       	ldd	r30, Y+9	; 0x09
    68c2:	fa 85       	ldd	r31, Y+10	; 0x0a
    68c4:	84 81       	ldd	r24, Z+4	; 0x04
    68c6:	95 81       	ldd	r25, Z+5	; 0x05
    68c8:	13 96       	adiw	r26, 0x03	; 3
    68ca:	9c 93       	st	X, r25
    68cc:	8e 93       	st	-X, r24
    68ce:	12 97       	sbiw	r26, 0x02	; 2
    68d0:	ed 81       	ldd	r30, Y+5	; 0x05
    68d2:	fe 81       	ldd	r31, Y+6	; 0x06
    68d4:	21 81       	ldd	r18, Z+1	; 0x01
    68d6:	32 81       	ldd	r19, Z+2	; 0x02
    68d8:	89 85       	ldd	r24, Y+9	; 0x09
    68da:	9a 85       	ldd	r25, Y+10	; 0x0a
    68dc:	02 96       	adiw	r24, 0x02	; 2
    68de:	28 17       	cp	r18, r24
    68e0:	39 07       	cpc	r19, r25
    68e2:	41 f4       	brne	.+16     	; 0x68f4 <vTaskGenericNotifyGiveFromISR+0x118>
    68e4:	e9 85       	ldd	r30, Y+9	; 0x09
    68e6:	fa 85       	ldd	r31, Y+10	; 0x0a
    68e8:	86 81       	ldd	r24, Z+6	; 0x06
    68ea:	97 81       	ldd	r25, Z+7	; 0x07
    68ec:	ed 81       	ldd	r30, Y+5	; 0x05
    68ee:	fe 81       	ldd	r31, Y+6	; 0x06
    68f0:	92 83       	std	Z+2, r25	; 0x02
    68f2:	81 83       	std	Z+1, r24	; 0x01
    68f4:	e9 85       	ldd	r30, Y+9	; 0x09
    68f6:	fa 85       	ldd	r31, Y+10	; 0x0a
    68f8:	13 86       	std	Z+11, r1	; 0x0b
    68fa:	12 86       	std	Z+10, r1	; 0x0a
    68fc:	ed 81       	ldd	r30, Y+5	; 0x05
    68fe:	fe 81       	ldd	r31, Y+6	; 0x06
    6900:	80 81       	ld	r24, Z
    6902:	81 50       	subi	r24, 0x01	; 1
    6904:	ed 81       	ldd	r30, Y+5	; 0x05
    6906:	fe 81       	ldd	r31, Y+6	; 0x06
    6908:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    690a:	e9 85       	ldd	r30, Y+9	; 0x09
    690c:	fa 85       	ldd	r31, Y+10	; 0x0a
    690e:	96 89       	ldd	r25, Z+22	; 0x16
    6910:	80 91 4e 07 	lds	r24, 0x074E
    6914:	89 17       	cp	r24, r25
    6916:	28 f4       	brcc	.+10     	; 0x6922 <vTaskGenericNotifyGiveFromISR+0x146>
    6918:	e9 85       	ldd	r30, Y+9	; 0x09
    691a:	fa 85       	ldd	r31, Y+10	; 0x0a
    691c:	86 89       	ldd	r24, Z+22	; 0x16
    691e:	80 93 4e 07 	sts	0x074E, r24
    6922:	e9 85       	ldd	r30, Y+9	; 0x09
    6924:	fa 85       	ldd	r31, Y+10	; 0x0a
    6926:	86 89       	ldd	r24, Z+22	; 0x16
    6928:	28 2f       	mov	r18, r24
    692a:	30 e0       	ldi	r19, 0x00	; 0
    692c:	c9 01       	movw	r24, r18
    692e:	88 0f       	add	r24, r24
    6930:	99 1f       	adc	r25, r25
    6932:	88 0f       	add	r24, r24
    6934:	99 1f       	adc	r25, r25
    6936:	88 0f       	add	r24, r24
    6938:	99 1f       	adc	r25, r25
    693a:	82 0f       	add	r24, r18
    693c:	93 1f       	adc	r25, r19
    693e:	fc 01       	movw	r30, r24
    6940:	e6 5a       	subi	r30, 0xA6	; 166
    6942:	f8 4f       	sbci	r31, 0xF8	; 248
    6944:	81 81       	ldd	r24, Z+1	; 0x01
    6946:	92 81       	ldd	r25, Z+2	; 0x02
    6948:	9c 83       	std	Y+4, r25	; 0x04
    694a:	8b 83       	std	Y+3, r24	; 0x03
    694c:	e9 85       	ldd	r30, Y+9	; 0x09
    694e:	fa 85       	ldd	r31, Y+10	; 0x0a
    6950:	8b 81       	ldd	r24, Y+3	; 0x03
    6952:	9c 81       	ldd	r25, Y+4	; 0x04
    6954:	95 83       	std	Z+5, r25	; 0x05
    6956:	84 83       	std	Z+4, r24	; 0x04
    6958:	eb 81       	ldd	r30, Y+3	; 0x03
    695a:	fc 81       	ldd	r31, Y+4	; 0x04
    695c:	84 81       	ldd	r24, Z+4	; 0x04
    695e:	95 81       	ldd	r25, Z+5	; 0x05
    6960:	e9 85       	ldd	r30, Y+9	; 0x09
    6962:	fa 85       	ldd	r31, Y+10	; 0x0a
    6964:	97 83       	std	Z+7, r25	; 0x07
    6966:	86 83       	std	Z+6, r24	; 0x06
    6968:	eb 81       	ldd	r30, Y+3	; 0x03
    696a:	fc 81       	ldd	r31, Y+4	; 0x04
    696c:	04 80       	ldd	r0, Z+4	; 0x04
    696e:	f5 81       	ldd	r31, Z+5	; 0x05
    6970:	e0 2d       	mov	r30, r0
    6972:	89 85       	ldd	r24, Y+9	; 0x09
    6974:	9a 85       	ldd	r25, Y+10	; 0x0a
    6976:	02 96       	adiw	r24, 0x02	; 2
    6978:	93 83       	std	Z+3, r25	; 0x03
    697a:	82 83       	std	Z+2, r24	; 0x02
    697c:	89 85       	ldd	r24, Y+9	; 0x09
    697e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6980:	02 96       	adiw	r24, 0x02	; 2
    6982:	eb 81       	ldd	r30, Y+3	; 0x03
    6984:	fc 81       	ldd	r31, Y+4	; 0x04
    6986:	95 83       	std	Z+5, r25	; 0x05
    6988:	84 83       	std	Z+4, r24	; 0x04
    698a:	e9 85       	ldd	r30, Y+9	; 0x09
    698c:	fa 85       	ldd	r31, Y+10	; 0x0a
    698e:	86 89       	ldd	r24, Z+22	; 0x16
    6990:	28 2f       	mov	r18, r24
    6992:	30 e0       	ldi	r19, 0x00	; 0
    6994:	c9 01       	movw	r24, r18
    6996:	88 0f       	add	r24, r24
    6998:	99 1f       	adc	r25, r25
    699a:	88 0f       	add	r24, r24
    699c:	99 1f       	adc	r25, r25
    699e:	88 0f       	add	r24, r24
    69a0:	99 1f       	adc	r25, r25
    69a2:	82 0f       	add	r24, r18
    69a4:	93 1f       	adc	r25, r19
    69a6:	86 5a       	subi	r24, 0xA6	; 166
    69a8:	98 4f       	sbci	r25, 0xF8	; 248
    69aa:	e9 85       	ldd	r30, Y+9	; 0x09
    69ac:	fa 85       	ldd	r31, Y+10	; 0x0a
    69ae:	93 87       	std	Z+11, r25	; 0x0b
    69b0:	82 87       	std	Z+10, r24	; 0x0a
    69b2:	e9 85       	ldd	r30, Y+9	; 0x09
    69b4:	fa 85       	ldd	r31, Y+10	; 0x0a
    69b6:	86 89       	ldd	r24, Z+22	; 0x16
    69b8:	28 2f       	mov	r18, r24
    69ba:	30 e0       	ldi	r19, 0x00	; 0
    69bc:	c9 01       	movw	r24, r18
    69be:	88 0f       	add	r24, r24
    69c0:	99 1f       	adc	r25, r25
    69c2:	88 0f       	add	r24, r24
    69c4:	99 1f       	adc	r25, r25
    69c6:	88 0f       	add	r24, r24
    69c8:	99 1f       	adc	r25, r25
    69ca:	82 0f       	add	r24, r18
    69cc:	93 1f       	adc	r25, r19
    69ce:	fc 01       	movw	r30, r24
    69d0:	e6 5a       	subi	r30, 0xA6	; 166
    69d2:	f8 4f       	sbci	r31, 0xF8	; 248
    69d4:	80 81       	ld	r24, Z
    69d6:	8f 5f       	subi	r24, 0xFF	; 255
    69d8:	80 83       	st	Z, r24
    69da:	30 c0       	rjmp	.+96     	; 0x6a3c <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    69dc:	80 91 95 07 	lds	r24, 0x0795
    69e0:	90 91 96 07 	lds	r25, 0x0796
    69e4:	9a 83       	std	Y+2, r25	; 0x02
    69e6:	89 83       	std	Y+1, r24	; 0x01
    69e8:	e9 85       	ldd	r30, Y+9	; 0x09
    69ea:	fa 85       	ldd	r31, Y+10	; 0x0a
    69ec:	89 81       	ldd	r24, Y+1	; 0x01
    69ee:	9a 81       	ldd	r25, Y+2	; 0x02
    69f0:	97 87       	std	Z+15, r25	; 0x0f
    69f2:	86 87       	std	Z+14, r24	; 0x0e
    69f4:	e9 81       	ldd	r30, Y+1	; 0x01
    69f6:	fa 81       	ldd	r31, Y+2	; 0x02
    69f8:	84 81       	ldd	r24, Z+4	; 0x04
    69fa:	95 81       	ldd	r25, Z+5	; 0x05
    69fc:	e9 85       	ldd	r30, Y+9	; 0x09
    69fe:	fa 85       	ldd	r31, Y+10	; 0x0a
    6a00:	91 8b       	std	Z+17, r25	; 0x11
    6a02:	80 8b       	std	Z+16, r24	; 0x10
    6a04:	e9 81       	ldd	r30, Y+1	; 0x01
    6a06:	fa 81       	ldd	r31, Y+2	; 0x02
    6a08:	04 80       	ldd	r0, Z+4	; 0x04
    6a0a:	f5 81       	ldd	r31, Z+5	; 0x05
    6a0c:	e0 2d       	mov	r30, r0
    6a0e:	89 85       	ldd	r24, Y+9	; 0x09
    6a10:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a12:	0c 96       	adiw	r24, 0x0c	; 12
    6a14:	93 83       	std	Z+3, r25	; 0x03
    6a16:	82 83       	std	Z+2, r24	; 0x02
    6a18:	89 85       	ldd	r24, Y+9	; 0x09
    6a1a:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a1c:	0c 96       	adiw	r24, 0x0c	; 12
    6a1e:	e9 81       	ldd	r30, Y+1	; 0x01
    6a20:	fa 81       	ldd	r31, Y+2	; 0x02
    6a22:	95 83       	std	Z+5, r25	; 0x05
    6a24:	84 83       	std	Z+4, r24	; 0x04
    6a26:	e9 85       	ldd	r30, Y+9	; 0x09
    6a28:	fa 85       	ldd	r31, Y+10	; 0x0a
    6a2a:	84 e9       	ldi	r24, 0x94	; 148
    6a2c:	97 e0       	ldi	r25, 0x07	; 7
    6a2e:	95 8b       	std	Z+21, r25	; 0x15
    6a30:	84 8b       	std	Z+20, r24	; 0x14
    6a32:	80 91 94 07 	lds	r24, 0x0794
    6a36:	8f 5f       	subi	r24, 0xFF	; 255
    6a38:	80 93 94 07 	sts	0x0794, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6a3c:	e9 85       	ldd	r30, Y+9	; 0x09
    6a3e:	fa 85       	ldd	r31, Y+10	; 0x0a
    6a40:	96 89       	ldd	r25, Z+22	; 0x16
    6a42:	e0 91 48 07 	lds	r30, 0x0748
    6a46:	f0 91 49 07 	lds	r31, 0x0749
    6a4a:	86 89       	ldd	r24, Z+22	; 0x16
    6a4c:	89 17       	cp	r24, r25
    6a4e:	58 f4       	brcc	.+22     	; 0x6a66 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    6a50:	8e 85       	ldd	r24, Y+14	; 0x0e
    6a52:	9f 85       	ldd	r25, Y+15	; 0x0f
    6a54:	00 97       	sbiw	r24, 0x00	; 0
    6a56:	21 f0       	breq	.+8      	; 0x6a60 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    6a58:	ee 85       	ldd	r30, Y+14	; 0x0e
    6a5a:	ff 85       	ldd	r31, Y+15	; 0x0f
    6a5c:	81 e0       	ldi	r24, 0x01	; 1
    6a5e:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    6a60:	81 e0       	ldi	r24, 0x01	; 1
    6a62:	80 93 52 07 	sts	0x0752, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    6a66:	2f 96       	adiw	r28, 0x0f	; 15
    6a68:	0f b6       	in	r0, 0x3f	; 63
    6a6a:	f8 94       	cli
    6a6c:	de bf       	out	0x3e, r29	; 62
    6a6e:	0f be       	out	0x3f, r0	; 63
    6a70:	cd bf       	out	0x3d, r28	; 61
    6a72:	cf 91       	pop	r28
    6a74:	df 91       	pop	r29
    6a76:	1f 91       	pop	r17
    6a78:	0f 91       	pop	r16
    6a7a:	08 95       	ret

00006a7c <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    6a7c:	df 93       	push	r29
    6a7e:	cf 93       	push	r28
    6a80:	cd b7       	in	r28, 0x3d	; 61
    6a82:	de b7       	in	r29, 0x3e	; 62
    6a84:	28 97       	sbiw	r28, 0x08	; 8
    6a86:	0f b6       	in	r0, 0x3f	; 63
    6a88:	f8 94       	cli
    6a8a:	de bf       	out	0x3e, r29	; 62
    6a8c:	0f be       	out	0x3f, r0	; 63
    6a8e:	cd bf       	out	0x3d, r28	; 61
    6a90:	9d 83       	std	Y+5, r25	; 0x05
    6a92:	8c 83       	std	Y+4, r24	; 0x04
    6a94:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    6a96:	8c 81       	ldd	r24, Y+4	; 0x04
    6a98:	9d 81       	ldd	r25, Y+5	; 0x05
    6a9a:	00 97       	sbiw	r24, 0x00	; 0
    6a9c:	39 f4       	brne	.+14     	; 0x6aac <xTaskGenericNotifyStateClear+0x30>
    6a9e:	80 91 48 07 	lds	r24, 0x0748
    6aa2:	90 91 49 07 	lds	r25, 0x0749
    6aa6:	98 87       	std	Y+8, r25	; 0x08
    6aa8:	8f 83       	std	Y+7, r24	; 0x07
    6aaa:	04 c0       	rjmp	.+8      	; 0x6ab4 <xTaskGenericNotifyStateClear+0x38>
    6aac:	8c 81       	ldd	r24, Y+4	; 0x04
    6aae:	9d 81       	ldd	r25, Y+5	; 0x05
    6ab0:	98 87       	std	Y+8, r25	; 0x08
    6ab2:	8f 83       	std	Y+7, r24	; 0x07
    6ab4:	8f 81       	ldd	r24, Y+7	; 0x07
    6ab6:	98 85       	ldd	r25, Y+8	; 0x08
    6ab8:	9b 83       	std	Y+3, r25	; 0x03
    6aba:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    6abc:	0f b6       	in	r0, 0x3f	; 63
    6abe:	f8 94       	cli
    6ac0:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    6ac2:	8e 81       	ldd	r24, Y+6	; 0x06
    6ac4:	28 2f       	mov	r18, r24
    6ac6:	30 e0       	ldi	r19, 0x00	; 0
    6ac8:	8a 81       	ldd	r24, Y+2	; 0x02
    6aca:	9b 81       	ldd	r25, Y+3	; 0x03
    6acc:	82 0f       	add	r24, r18
    6ace:	93 1f       	adc	r25, r19
    6ad0:	fc 01       	movw	r30, r24
    6ad2:	b5 96       	adiw	r30, 0x25	; 37
    6ad4:	80 81       	ld	r24, Z
    6ad6:	82 30       	cpi	r24, 0x02	; 2
    6ad8:	69 f4       	brne	.+26     	; 0x6af4 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    6ada:	8e 81       	ldd	r24, Y+6	; 0x06
    6adc:	28 2f       	mov	r18, r24
    6ade:	30 e0       	ldi	r19, 0x00	; 0
    6ae0:	8a 81       	ldd	r24, Y+2	; 0x02
    6ae2:	9b 81       	ldd	r25, Y+3	; 0x03
    6ae4:	82 0f       	add	r24, r18
    6ae6:	93 1f       	adc	r25, r19
    6ae8:	fc 01       	movw	r30, r24
    6aea:	b5 96       	adiw	r30, 0x25	; 37
    6aec:	10 82       	st	Z, r1
                xReturn = pdPASS;
    6aee:	81 e0       	ldi	r24, 0x01	; 1
    6af0:	89 83       	std	Y+1, r24	; 0x01
    6af2:	01 c0       	rjmp	.+2      	; 0x6af6 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    6af4:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    6af6:	0f 90       	pop	r0
    6af8:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    6afa:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6afc:	28 96       	adiw	r28, 0x08	; 8
    6afe:	0f b6       	in	r0, 0x3f	; 63
    6b00:	f8 94       	cli
    6b02:	de bf       	out	0x3e, r29	; 62
    6b04:	0f be       	out	0x3f, r0	; 63
    6b06:	cd bf       	out	0x3d, r28	; 61
    6b08:	cf 91       	pop	r28
    6b0a:	df 91       	pop	r29
    6b0c:	08 95       	ret

00006b0e <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    6b0e:	0f 93       	push	r16
    6b10:	1f 93       	push	r17
    6b12:	df 93       	push	r29
    6b14:	cf 93       	push	r28
    6b16:	cd b7       	in	r28, 0x3d	; 61
    6b18:	de b7       	in	r29, 0x3e	; 62
    6b1a:	2f 97       	sbiw	r28, 0x0f	; 15
    6b1c:	0f b6       	in	r0, 0x3f	; 63
    6b1e:	f8 94       	cli
    6b20:	de bf       	out	0x3e, r29	; 62
    6b22:	0f be       	out	0x3f, r0	; 63
    6b24:	cd bf       	out	0x3d, r28	; 61
    6b26:	98 87       	std	Y+8, r25	; 0x08
    6b28:	8f 83       	std	Y+7, r24	; 0x07
    6b2a:	69 87       	std	Y+9, r22	; 0x09
    6b2c:	2a 87       	std	Y+10, r18	; 0x0a
    6b2e:	3b 87       	std	Y+11, r19	; 0x0b
    6b30:	4c 87       	std	Y+12, r20	; 0x0c
    6b32:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    6b34:	8f 81       	ldd	r24, Y+7	; 0x07
    6b36:	98 85       	ldd	r25, Y+8	; 0x08
    6b38:	00 97       	sbiw	r24, 0x00	; 0
    6b3a:	39 f4       	brne	.+14     	; 0x6b4a <ulTaskGenericNotifyValueClear+0x3c>
    6b3c:	80 91 48 07 	lds	r24, 0x0748
    6b40:	90 91 49 07 	lds	r25, 0x0749
    6b44:	9f 87       	std	Y+15, r25	; 0x0f
    6b46:	8e 87       	std	Y+14, r24	; 0x0e
    6b48:	04 c0       	rjmp	.+8      	; 0x6b52 <ulTaskGenericNotifyValueClear+0x44>
    6b4a:	8f 81       	ldd	r24, Y+7	; 0x07
    6b4c:	98 85       	ldd	r25, Y+8	; 0x08
    6b4e:	9f 87       	std	Y+15, r25	; 0x0f
    6b50:	8e 87       	std	Y+14, r24	; 0x0e
    6b52:	8e 85       	ldd	r24, Y+14	; 0x0e
    6b54:	9f 85       	ldd	r25, Y+15	; 0x0f
    6b56:	9e 83       	std	Y+6, r25	; 0x06
    6b58:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    6b5a:	0f b6       	in	r0, 0x3f	; 63
    6b5c:	f8 94       	cli
    6b5e:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    6b60:	89 85       	ldd	r24, Y+9	; 0x09
    6b62:	88 2f       	mov	r24, r24
    6b64:	90 e0       	ldi	r25, 0x00	; 0
    6b66:	2d 81       	ldd	r18, Y+5	; 0x05
    6b68:	3e 81       	ldd	r19, Y+6	; 0x06
    6b6a:	88 0f       	add	r24, r24
    6b6c:	99 1f       	adc	r25, r25
    6b6e:	88 0f       	add	r24, r24
    6b70:	99 1f       	adc	r25, r25
    6b72:	82 0f       	add	r24, r18
    6b74:	93 1f       	adc	r25, r19
    6b76:	fc 01       	movw	r30, r24
    6b78:	b1 96       	adiw	r30, 0x21	; 33
    6b7a:	80 81       	ld	r24, Z
    6b7c:	91 81       	ldd	r25, Z+1	; 0x01
    6b7e:	a2 81       	ldd	r26, Z+2	; 0x02
    6b80:	b3 81       	ldd	r27, Z+3	; 0x03
    6b82:	89 83       	std	Y+1, r24	; 0x01
    6b84:	9a 83       	std	Y+2, r25	; 0x02
    6b86:	ab 83       	std	Y+3, r26	; 0x03
    6b88:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    6b8a:	89 85       	ldd	r24, Y+9	; 0x09
    6b8c:	08 2f       	mov	r16, r24
    6b8e:	10 e0       	ldi	r17, 0x00	; 0
    6b90:	89 85       	ldd	r24, Y+9	; 0x09
    6b92:	88 2f       	mov	r24, r24
    6b94:	90 e0       	ldi	r25, 0x00	; 0
    6b96:	2d 81       	ldd	r18, Y+5	; 0x05
    6b98:	3e 81       	ldd	r19, Y+6	; 0x06
    6b9a:	88 0f       	add	r24, r24
    6b9c:	99 1f       	adc	r25, r25
    6b9e:	88 0f       	add	r24, r24
    6ba0:	99 1f       	adc	r25, r25
    6ba2:	82 0f       	add	r24, r18
    6ba4:	93 1f       	adc	r25, r19
    6ba6:	fc 01       	movw	r30, r24
    6ba8:	b1 96       	adiw	r30, 0x21	; 33
    6baa:	20 81       	ld	r18, Z
    6bac:	31 81       	ldd	r19, Z+1	; 0x01
    6bae:	42 81       	ldd	r20, Z+2	; 0x02
    6bb0:	53 81       	ldd	r21, Z+3	; 0x03
    6bb2:	8a 85       	ldd	r24, Y+10	; 0x0a
    6bb4:	9b 85       	ldd	r25, Y+11	; 0x0b
    6bb6:	ac 85       	ldd	r26, Y+12	; 0x0c
    6bb8:	bd 85       	ldd	r27, Y+13	; 0x0d
    6bba:	80 95       	com	r24
    6bbc:	90 95       	com	r25
    6bbe:	a0 95       	com	r26
    6bc0:	b0 95       	com	r27
    6bc2:	ba 01       	movw	r22, r20
    6bc4:	a9 01       	movw	r20, r18
    6bc6:	48 23       	and	r20, r24
    6bc8:	59 23       	and	r21, r25
    6bca:	6a 23       	and	r22, r26
    6bcc:	7b 23       	and	r23, r27
    6bce:	2d 81       	ldd	r18, Y+5	; 0x05
    6bd0:	3e 81       	ldd	r19, Y+6	; 0x06
    6bd2:	c8 01       	movw	r24, r16
    6bd4:	88 0f       	add	r24, r24
    6bd6:	99 1f       	adc	r25, r25
    6bd8:	88 0f       	add	r24, r24
    6bda:	99 1f       	adc	r25, r25
    6bdc:	82 0f       	add	r24, r18
    6bde:	93 1f       	adc	r25, r19
    6be0:	fc 01       	movw	r30, r24
    6be2:	b1 96       	adiw	r30, 0x21	; 33
    6be4:	40 83       	st	Z, r20
    6be6:	51 83       	std	Z+1, r21	; 0x01
    6be8:	62 83       	std	Z+2, r22	; 0x02
    6bea:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    6bec:	0f 90       	pop	r0
    6bee:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    6bf0:	89 81       	ldd	r24, Y+1	; 0x01
    6bf2:	9a 81       	ldd	r25, Y+2	; 0x02
    6bf4:	ab 81       	ldd	r26, Y+3	; 0x03
    6bf6:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    6bf8:	bc 01       	movw	r22, r24
    6bfa:	cd 01       	movw	r24, r26
    6bfc:	2f 96       	adiw	r28, 0x0f	; 15
    6bfe:	0f b6       	in	r0, 0x3f	; 63
    6c00:	f8 94       	cli
    6c02:	de bf       	out	0x3e, r29	; 62
    6c04:	0f be       	out	0x3f, r0	; 63
    6c06:	cd bf       	out	0x3d, r28	; 61
    6c08:	cf 91       	pop	r28
    6c0a:	df 91       	pop	r29
    6c0c:	1f 91       	pop	r17
    6c0e:	0f 91       	pop	r16
    6c10:	08 95       	ret

00006c12 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    6c12:	df 93       	push	r29
    6c14:	cf 93       	push	r28
    6c16:	cd b7       	in	r28, 0x3d	; 61
    6c18:	de b7       	in	r29, 0x3e	; 62
    6c1a:	27 97       	sbiw	r28, 0x07	; 7
    6c1c:	0f b6       	in	r0, 0x3f	; 63
    6c1e:	f8 94       	cli
    6c20:	de bf       	out	0x3e, r29	; 62
    6c22:	0f be       	out	0x3f, r0	; 63
    6c24:	cd bf       	out	0x3d, r28	; 61
    6c26:	9e 83       	std	Y+6, r25	; 0x06
    6c28:	8d 83       	std	Y+5, r24	; 0x05
    6c2a:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    6c2c:	80 91 4c 07 	lds	r24, 0x074C
    6c30:	90 91 4d 07 	lds	r25, 0x074D
    6c34:	9a 83       	std	Y+2, r25	; 0x02
    6c36:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6c38:	80 91 48 07 	lds	r24, 0x0748
    6c3c:	90 91 49 07 	lds	r25, 0x0749
    6c40:	02 96       	adiw	r24, 0x02	; 2
    6c42:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    6c46:	29 81       	ldd	r18, Y+1	; 0x01
    6c48:	3a 81       	ldd	r19, Y+2	; 0x02
    6c4a:	8d 81       	ldd	r24, Y+5	; 0x05
    6c4c:	9e 81       	ldd	r25, Y+6	; 0x06
    6c4e:	82 0f       	add	r24, r18
    6c50:	93 1f       	adc	r25, r19
    6c52:	9c 83       	std	Y+4, r25	; 0x04
    6c54:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    6c56:	e0 91 48 07 	lds	r30, 0x0748
    6c5a:	f0 91 49 07 	lds	r31, 0x0749
    6c5e:	8b 81       	ldd	r24, Y+3	; 0x03
    6c60:	9c 81       	ldd	r25, Y+4	; 0x04
    6c62:	93 83       	std	Z+3, r25	; 0x03
    6c64:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    6c66:	2b 81       	ldd	r18, Y+3	; 0x03
    6c68:	3c 81       	ldd	r19, Y+4	; 0x04
    6c6a:	89 81       	ldd	r24, Y+1	; 0x01
    6c6c:	9a 81       	ldd	r25, Y+2	; 0x02
    6c6e:	28 17       	cp	r18, r24
    6c70:	39 07       	cpc	r19, r25
    6c72:	70 f4       	brcc	.+28     	; 0x6c90 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6c74:	80 91 92 07 	lds	r24, 0x0792
    6c78:	90 91 93 07 	lds	r25, 0x0793
    6c7c:	20 91 48 07 	lds	r18, 0x0748
    6c80:	30 91 49 07 	lds	r19, 0x0749
    6c84:	2e 5f       	subi	r18, 0xFE	; 254
    6c86:	3f 4f       	sbci	r19, 0xFF	; 255
    6c88:	b9 01       	movw	r22, r18
    6c8a:	0e 94 71 18 	call	0x30e2	; 0x30e2 <vListInsert>
    6c8e:	1e c0       	rjmp	.+60     	; 0x6ccc <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6c90:	40 91 90 07 	lds	r20, 0x0790
    6c94:	50 91 91 07 	lds	r21, 0x0791
    6c98:	80 91 48 07 	lds	r24, 0x0748
    6c9c:	90 91 49 07 	lds	r25, 0x0749
    6ca0:	9c 01       	movw	r18, r24
    6ca2:	2e 5f       	subi	r18, 0xFE	; 254
    6ca4:	3f 4f       	sbci	r19, 0xFF	; 255
    6ca6:	ca 01       	movw	r24, r20
    6ca8:	b9 01       	movw	r22, r18
    6caa:	0e 94 71 18 	call	0x30e2	; 0x30e2 <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    6cae:	20 91 55 07 	lds	r18, 0x0755
    6cb2:	30 91 56 07 	lds	r19, 0x0756
    6cb6:	8b 81       	ldd	r24, Y+3	; 0x03
    6cb8:	9c 81       	ldd	r25, Y+4	; 0x04
    6cba:	82 17       	cp	r24, r18
    6cbc:	93 07       	cpc	r25, r19
    6cbe:	30 f4       	brcc	.+12     	; 0x6ccc <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    6cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    6cc2:	9c 81       	ldd	r25, Y+4	; 0x04
    6cc4:	90 93 56 07 	sts	0x0756, r25
    6cc8:	80 93 55 07 	sts	0x0755, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    6ccc:	27 96       	adiw	r28, 0x07	; 7
    6cce:	0f b6       	in	r0, 0x3f	; 63
    6cd0:	f8 94       	cli
    6cd2:	de bf       	out	0x3e, r29	; 62
    6cd4:	0f be       	out	0x3f, r0	; 63
    6cd6:	cd bf       	out	0x3d, r28	; 61
    6cd8:	cf 91       	pop	r28
    6cda:	df 91       	pop	r29
    6cdc:	08 95       	ret

00006cde <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    6cde:	ef 92       	push	r14
    6ce0:	ff 92       	push	r15
    6ce2:	0f 93       	push	r16
    6ce4:	df 93       	push	r29
    6ce6:	cf 93       	push	r28
    6ce8:	0f 92       	push	r0
    6cea:	cd b7       	in	r28, 0x3d	; 61
    6cec:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    6cee:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    6cf0:	0e 94 2e 3b 	call	0x765c	; 0x765c <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    6cf4:	80 91 a6 07 	lds	r24, 0x07A6
    6cf8:	90 91 a7 07 	lds	r25, 0x07A7
    6cfc:	00 97       	sbiw	r24, 0x00	; 0
    6cfe:	81 f0       	breq	.+32     	; 0x6d20 <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    6d00:	80 ec       	ldi	r24, 0xC0	; 192
    6d02:	98 e3       	ldi	r25, 0x38	; 56
    6d04:	2a e7       	ldi	r18, 0x7A	; 122
    6d06:	30 e0       	ldi	r19, 0x00	; 0
    6d08:	e8 ea       	ldi	r30, 0xA8	; 168
    6d0a:	f7 e0       	ldi	r31, 0x07	; 7
    6d0c:	b9 01       	movw	r22, r18
    6d0e:	45 e5       	ldi	r20, 0x55	; 85
    6d10:	50 e0       	ldi	r21, 0x00	; 0
    6d12:	20 e0       	ldi	r18, 0x00	; 0
    6d14:	30 e0       	ldi	r19, 0x00	; 0
    6d16:	03 e0       	ldi	r16, 0x03	; 3
    6d18:	7f 01       	movw	r14, r30
    6d1a:	0e 94 7f 22 	call	0x44fe	; 0x44fe <xTaskCreate>
    6d1e:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    6d20:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6d22:	0f 90       	pop	r0
    6d24:	cf 91       	pop	r28
    6d26:	df 91       	pop	r29
    6d28:	0f 91       	pop	r16
    6d2a:	ff 90       	pop	r15
    6d2c:	ef 90       	pop	r14
    6d2e:	08 95       	ret

00006d30 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    6d30:	ef 92       	push	r14
    6d32:	ff 92       	push	r15
    6d34:	0f 93       	push	r16
    6d36:	1f 93       	push	r17
    6d38:	df 93       	push	r29
    6d3a:	cf 93       	push	r28
    6d3c:	cd b7       	in	r28, 0x3d	; 61
    6d3e:	de b7       	in	r29, 0x3e	; 62
    6d40:	2b 97       	sbiw	r28, 0x0b	; 11
    6d42:	0f b6       	in	r0, 0x3f	; 63
    6d44:	f8 94       	cli
    6d46:	de bf       	out	0x3e, r29	; 62
    6d48:	0f be       	out	0x3f, r0	; 63
    6d4a:	cd bf       	out	0x3d, r28	; 61
    6d4c:	9c 83       	std	Y+4, r25	; 0x04
    6d4e:	8b 83       	std	Y+3, r24	; 0x03
    6d50:	7e 83       	std	Y+6, r23	; 0x06
    6d52:	6d 83       	std	Y+5, r22	; 0x05
    6d54:	4f 83       	std	Y+7, r20	; 0x07
    6d56:	39 87       	std	Y+9, r19	; 0x09
    6d58:	28 87       	std	Y+8, r18	; 0x08
    6d5a:	1b 87       	std	Y+11, r17	; 0x0b
    6d5c:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    6d5e:	83 e1       	ldi	r24, 0x13	; 19
    6d60:	90 e0       	ldi	r25, 0x00	; 0
    6d62:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <pvPortMalloc>
    6d66:	9a 83       	std	Y+2, r25	; 0x02
    6d68:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    6d6a:	89 81       	ldd	r24, Y+1	; 0x01
    6d6c:	9a 81       	ldd	r25, Y+2	; 0x02
    6d6e:	00 97       	sbiw	r24, 0x00	; 0
    6d70:	99 f0       	breq	.+38     	; 0x6d98 <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    6d72:	e9 81       	ldd	r30, Y+1	; 0x01
    6d74:	fa 81       	ldd	r31, Y+2	; 0x02
    6d76:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    6d78:	8b 81       	ldd	r24, Y+3	; 0x03
    6d7a:	9c 81       	ldd	r25, Y+4	; 0x04
    6d7c:	2d 81       	ldd	r18, Y+5	; 0x05
    6d7e:	3e 81       	ldd	r19, Y+6	; 0x06
    6d80:	e8 85       	ldd	r30, Y+8	; 0x08
    6d82:	f9 85       	ldd	r31, Y+9	; 0x09
    6d84:	aa 85       	ldd	r26, Y+10	; 0x0a
    6d86:	bb 85       	ldd	r27, Y+11	; 0x0b
    6d88:	e9 80       	ldd	r14, Y+1	; 0x01
    6d8a:	fa 80       	ldd	r15, Y+2	; 0x02
    6d8c:	b9 01       	movw	r22, r18
    6d8e:	4f 81       	ldd	r20, Y+7	; 0x07
    6d90:	9f 01       	movw	r18, r30
    6d92:	8d 01       	movw	r16, r26
    6d94:	0e 94 db 36 	call	0x6db6	; 0x6db6 <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    6d98:	89 81       	ldd	r24, Y+1	; 0x01
    6d9a:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    6d9c:	2b 96       	adiw	r28, 0x0b	; 11
    6d9e:	0f b6       	in	r0, 0x3f	; 63
    6da0:	f8 94       	cli
    6da2:	de bf       	out	0x3e, r29	; 62
    6da4:	0f be       	out	0x3f, r0	; 63
    6da6:	cd bf       	out	0x3d, r28	; 61
    6da8:	cf 91       	pop	r28
    6daa:	df 91       	pop	r29
    6dac:	1f 91       	pop	r17
    6dae:	0f 91       	pop	r16
    6db0:	ff 90       	pop	r15
    6db2:	ef 90       	pop	r14
    6db4:	08 95       	ret

00006db6 <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    6db6:	ef 92       	push	r14
    6db8:	ff 92       	push	r15
    6dba:	0f 93       	push	r16
    6dbc:	1f 93       	push	r17
    6dbe:	df 93       	push	r29
    6dc0:	cf 93       	push	r28
    6dc2:	cd b7       	in	r28, 0x3d	; 61
    6dc4:	de b7       	in	r29, 0x3e	; 62
    6dc6:	2b 97       	sbiw	r28, 0x0b	; 11
    6dc8:	0f b6       	in	r0, 0x3f	; 63
    6dca:	f8 94       	cli
    6dcc:	de bf       	out	0x3e, r29	; 62
    6dce:	0f be       	out	0x3f, r0	; 63
    6dd0:	cd bf       	out	0x3d, r28	; 61
    6dd2:	9a 83       	std	Y+2, r25	; 0x02
    6dd4:	89 83       	std	Y+1, r24	; 0x01
    6dd6:	7c 83       	std	Y+4, r23	; 0x04
    6dd8:	6b 83       	std	Y+3, r22	; 0x03
    6dda:	4d 83       	std	Y+5, r20	; 0x05
    6ddc:	3f 83       	std	Y+7, r19	; 0x07
    6dde:	2e 83       	std	Y+6, r18	; 0x06
    6de0:	19 87       	std	Y+9, r17	; 0x09
    6de2:	08 87       	std	Y+8, r16	; 0x08
    6de4:	fb 86       	std	Y+11, r15	; 0x0b
    6de6:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    6de8:	0e 94 2e 3b 	call	0x765c	; 0x765c <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    6dec:	ea 85       	ldd	r30, Y+10	; 0x0a
    6dee:	fb 85       	ldd	r31, Y+11	; 0x0b
    6df0:	89 81       	ldd	r24, Y+1	; 0x01
    6df2:	9a 81       	ldd	r25, Y+2	; 0x02
    6df4:	91 83       	std	Z+1, r25	; 0x01
    6df6:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    6df8:	ea 85       	ldd	r30, Y+10	; 0x0a
    6dfa:	fb 85       	ldd	r31, Y+11	; 0x0b
    6dfc:	8b 81       	ldd	r24, Y+3	; 0x03
    6dfe:	9c 81       	ldd	r25, Y+4	; 0x04
    6e00:	95 87       	std	Z+13, r25	; 0x0d
    6e02:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    6e04:	ea 85       	ldd	r30, Y+10	; 0x0a
    6e06:	fb 85       	ldd	r31, Y+11	; 0x0b
    6e08:	8e 81       	ldd	r24, Y+6	; 0x06
    6e0a:	9f 81       	ldd	r25, Y+7	; 0x07
    6e0c:	97 87       	std	Z+15, r25	; 0x0f
    6e0e:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    6e10:	ea 85       	ldd	r30, Y+10	; 0x0a
    6e12:	fb 85       	ldd	r31, Y+11	; 0x0b
    6e14:	88 85       	ldd	r24, Y+8	; 0x08
    6e16:	99 85       	ldd	r25, Y+9	; 0x09
    6e18:	91 8b       	std	Z+17, r25	; 0x11
    6e1a:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    6e1c:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e1e:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e20:	02 96       	adiw	r24, 0x02	; 2
    6e22:	0e 94 1d 18 	call	0x303a	; 0x303a <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    6e26:	8d 81       	ldd	r24, Y+5	; 0x05
    6e28:	88 23       	and	r24, r24
    6e2a:	39 f0       	breq	.+14     	; 0x6e3a <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    6e2c:	ea 85       	ldd	r30, Y+10	; 0x0a
    6e2e:	fb 85       	ldd	r31, Y+11	; 0x0b
    6e30:	82 89       	ldd	r24, Z+18	; 0x12
    6e32:	84 60       	ori	r24, 0x04	; 4
    6e34:	ea 85       	ldd	r30, Y+10	; 0x0a
    6e36:	fb 85       	ldd	r31, Y+11	; 0x0b
    6e38:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    6e3a:	2b 96       	adiw	r28, 0x0b	; 11
    6e3c:	0f b6       	in	r0, 0x3f	; 63
    6e3e:	f8 94       	cli
    6e40:	de bf       	out	0x3e, r29	; 62
    6e42:	0f be       	out	0x3f, r0	; 63
    6e44:	cd bf       	out	0x3d, r28	; 61
    6e46:	cf 91       	pop	r28
    6e48:	df 91       	pop	r29
    6e4a:	1f 91       	pop	r17
    6e4c:	0f 91       	pop	r16
    6e4e:	ff 90       	pop	r15
    6e50:	ef 90       	pop	r14
    6e52:	08 95       	ret

00006e54 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    6e54:	0f 93       	push	r16
    6e56:	1f 93       	push	r17
    6e58:	df 93       	push	r29
    6e5a:	cf 93       	push	r28
    6e5c:	cd b7       	in	r28, 0x3d	; 61
    6e5e:	de b7       	in	r29, 0x3e	; 62
    6e60:	2f 97       	sbiw	r28, 0x0f	; 15
    6e62:	0f b6       	in	r0, 0x3f	; 63
    6e64:	f8 94       	cli
    6e66:	de bf       	out	0x3e, r29	; 62
    6e68:	0f be       	out	0x3f, r0	; 63
    6e6a:	cd bf       	out	0x3d, r28	; 61
    6e6c:	98 87       	std	Y+8, r25	; 0x08
    6e6e:	8f 83       	std	Y+7, r24	; 0x07
    6e70:	69 87       	std	Y+9, r22	; 0x09
    6e72:	5b 87       	std	Y+11, r21	; 0x0b
    6e74:	4a 87       	std	Y+10, r20	; 0x0a
    6e76:	3d 87       	std	Y+13, r19	; 0x0d
    6e78:	2c 87       	std	Y+12, r18	; 0x0c
    6e7a:	1f 87       	std	Y+15, r17	; 0x0f
    6e7c:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    6e7e:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    6e80:	80 91 a6 07 	lds	r24, 0x07A6
    6e84:	90 91 a7 07 	lds	r25, 0x07A7
    6e88:	00 97       	sbiw	r24, 0x00	; 0
    6e8a:	e9 f1       	breq	.+122    	; 0x6f06 <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    6e8c:	89 85       	ldd	r24, Y+9	; 0x09
    6e8e:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    6e90:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e92:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e94:	9c 83       	std	Y+4, r25	; 0x04
    6e96:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    6e98:	8f 81       	ldd	r24, Y+7	; 0x07
    6e9a:	98 85       	ldd	r25, Y+8	; 0x08
    6e9c:	9e 83       	std	Y+6, r25	; 0x06
    6e9e:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    6ea0:	89 85       	ldd	r24, Y+9	; 0x09
    6ea2:	86 30       	cpi	r24, 0x06	; 6
    6ea4:	14 f5       	brge	.+68     	; 0x6eea <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    6ea6:	0e 94 44 2e 	call	0x5c88	; 0x5c88 <xTaskGetSchedulerState>
    6eaa:	82 30       	cpi	r24, 0x02	; 2
    6eac:	79 f4       	brne	.+30     	; 0x6ecc <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    6eae:	80 91 a6 07 	lds	r24, 0x07A6
    6eb2:	90 91 a7 07 	lds	r25, 0x07A7
    6eb6:	9e 01       	movw	r18, r28
    6eb8:	2e 5f       	subi	r18, 0xFE	; 254
    6eba:	3f 4f       	sbci	r19, 0xFF	; 255
    6ebc:	4e 85       	ldd	r20, Y+14	; 0x0e
    6ebe:	5f 85       	ldd	r21, Y+15	; 0x0f
    6ec0:	b9 01       	movw	r22, r18
    6ec2:	20 e0       	ldi	r18, 0x00	; 0
    6ec4:	0e 94 83 1a 	call	0x3506	; 0x3506 <xQueueGenericSend>
    6ec8:	89 83       	std	Y+1, r24	; 0x01
    6eca:	1d c0       	rjmp	.+58     	; 0x6f06 <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    6ecc:	80 91 a6 07 	lds	r24, 0x07A6
    6ed0:	90 91 a7 07 	lds	r25, 0x07A7
    6ed4:	9e 01       	movw	r18, r28
    6ed6:	2e 5f       	subi	r18, 0xFE	; 254
    6ed8:	3f 4f       	sbci	r19, 0xFF	; 255
    6eda:	b9 01       	movw	r22, r18
    6edc:	40 e0       	ldi	r20, 0x00	; 0
    6ede:	50 e0       	ldi	r21, 0x00	; 0
    6ee0:	20 e0       	ldi	r18, 0x00	; 0
    6ee2:	0e 94 83 1a 	call	0x3506	; 0x3506 <xQueueGenericSend>
    6ee6:	89 83       	std	Y+1, r24	; 0x01
    6ee8:	0e c0       	rjmp	.+28     	; 0x6f06 <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    6eea:	80 91 a6 07 	lds	r24, 0x07A6
    6eee:	90 91 a7 07 	lds	r25, 0x07A7
    6ef2:	9e 01       	movw	r18, r28
    6ef4:	2e 5f       	subi	r18, 0xFE	; 254
    6ef6:	3f 4f       	sbci	r19, 0xFF	; 255
    6ef8:	4c 85       	ldd	r20, Y+12	; 0x0c
    6efa:	5d 85       	ldd	r21, Y+13	; 0x0d
    6efc:	b9 01       	movw	r22, r18
    6efe:	20 e0       	ldi	r18, 0x00	; 0
    6f00:	0e 94 2f 1b 	call	0x365e	; 0x365e <xQueueGenericSendFromISR>
    6f04:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    6f06:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6f08:	2f 96       	adiw	r28, 0x0f	; 15
    6f0a:	0f b6       	in	r0, 0x3f	; 63
    6f0c:	f8 94       	cli
    6f0e:	de bf       	out	0x3e, r29	; 62
    6f10:	0f be       	out	0x3f, r0	; 63
    6f12:	cd bf       	out	0x3d, r28	; 61
    6f14:	cf 91       	pop	r28
    6f16:	df 91       	pop	r29
    6f18:	1f 91       	pop	r17
    6f1a:	0f 91       	pop	r16
    6f1c:	08 95       	ret

00006f1e <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    6f1e:	df 93       	push	r29
    6f20:	cf 93       	push	r28
    6f22:	cd b7       	in	r28, 0x3d	; 61
    6f24:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    6f26:	80 91 a8 07 	lds	r24, 0x07A8
    6f2a:	90 91 a9 07 	lds	r25, 0x07A9
    }
    6f2e:	cf 91       	pop	r28
    6f30:	df 91       	pop	r29
    6f32:	08 95       	ret

00006f34 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    6f34:	df 93       	push	r29
    6f36:	cf 93       	push	r28
    6f38:	00 d0       	rcall	.+0      	; 0x6f3a <xTimerGetPeriod+0x6>
    6f3a:	00 d0       	rcall	.+0      	; 0x6f3c <xTimerGetPeriod+0x8>
    6f3c:	cd b7       	in	r28, 0x3d	; 61
    6f3e:	de b7       	in	r29, 0x3e	; 62
    6f40:	9c 83       	std	Y+4, r25	; 0x04
    6f42:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    6f44:	8b 81       	ldd	r24, Y+3	; 0x03
    6f46:	9c 81       	ldd	r25, Y+4	; 0x04
    6f48:	9a 83       	std	Y+2, r25	; 0x02
    6f4a:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    6f4c:	e9 81       	ldd	r30, Y+1	; 0x01
    6f4e:	fa 81       	ldd	r31, Y+2	; 0x02
    6f50:	84 85       	ldd	r24, Z+12	; 0x0c
    6f52:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    6f54:	0f 90       	pop	r0
    6f56:	0f 90       	pop	r0
    6f58:	0f 90       	pop	r0
    6f5a:	0f 90       	pop	r0
    6f5c:	cf 91       	pop	r28
    6f5e:	df 91       	pop	r29
    6f60:	08 95       	ret

00006f62 <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    6f62:	df 93       	push	r29
    6f64:	cf 93       	push	r28
    6f66:	00 d0       	rcall	.+0      	; 0x6f68 <vTimerSetReloadMode+0x6>
    6f68:	00 d0       	rcall	.+0      	; 0x6f6a <vTimerSetReloadMode+0x8>
    6f6a:	0f 92       	push	r0
    6f6c:	cd b7       	in	r28, 0x3d	; 61
    6f6e:	de b7       	in	r29, 0x3e	; 62
    6f70:	9c 83       	std	Y+4, r25	; 0x04
    6f72:	8b 83       	std	Y+3, r24	; 0x03
    6f74:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    6f76:	8b 81       	ldd	r24, Y+3	; 0x03
    6f78:	9c 81       	ldd	r25, Y+4	; 0x04
    6f7a:	9a 83       	std	Y+2, r25	; 0x02
    6f7c:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    6f7e:	0f b6       	in	r0, 0x3f	; 63
    6f80:	f8 94       	cli
    6f82:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    6f84:	8d 81       	ldd	r24, Y+5	; 0x05
    6f86:	88 23       	and	r24, r24
    6f88:	41 f0       	breq	.+16     	; 0x6f9a <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    6f8a:	e9 81       	ldd	r30, Y+1	; 0x01
    6f8c:	fa 81       	ldd	r31, Y+2	; 0x02
    6f8e:	82 89       	ldd	r24, Z+18	; 0x12
    6f90:	84 60       	ori	r24, 0x04	; 4
    6f92:	e9 81       	ldd	r30, Y+1	; 0x01
    6f94:	fa 81       	ldd	r31, Y+2	; 0x02
    6f96:	82 8b       	std	Z+18, r24	; 0x12
    6f98:	07 c0       	rjmp	.+14     	; 0x6fa8 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    6f9a:	e9 81       	ldd	r30, Y+1	; 0x01
    6f9c:	fa 81       	ldd	r31, Y+2	; 0x02
    6f9e:	82 89       	ldd	r24, Z+18	; 0x12
    6fa0:	8b 7f       	andi	r24, 0xFB	; 251
    6fa2:	e9 81       	ldd	r30, Y+1	; 0x01
    6fa4:	fa 81       	ldd	r31, Y+2	; 0x02
    6fa6:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    6fa8:	0f 90       	pop	r0
    6faa:	0f be       	out	0x3f, r0	; 63
    }
    6fac:	0f 90       	pop	r0
    6fae:	0f 90       	pop	r0
    6fb0:	0f 90       	pop	r0
    6fb2:	0f 90       	pop	r0
    6fb4:	0f 90       	pop	r0
    6fb6:	cf 91       	pop	r28
    6fb8:	df 91       	pop	r29
    6fba:	08 95       	ret

00006fbc <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    6fbc:	df 93       	push	r29
    6fbe:	cf 93       	push	r28
    6fc0:	00 d0       	rcall	.+0      	; 0x6fc2 <uxTimerGetReloadMode+0x6>
    6fc2:	00 d0       	rcall	.+0      	; 0x6fc4 <uxTimerGetReloadMode+0x8>
    6fc4:	0f 92       	push	r0
    6fc6:	cd b7       	in	r28, 0x3d	; 61
    6fc8:	de b7       	in	r29, 0x3e	; 62
    6fca:	9d 83       	std	Y+5, r25	; 0x05
    6fcc:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    6fce:	8c 81       	ldd	r24, Y+4	; 0x04
    6fd0:	9d 81       	ldd	r25, Y+5	; 0x05
    6fd2:	9b 83       	std	Y+3, r25	; 0x03
    6fd4:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    6fd6:	0f b6       	in	r0, 0x3f	; 63
    6fd8:	f8 94       	cli
    6fda:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    6fdc:	ea 81       	ldd	r30, Y+2	; 0x02
    6fde:	fb 81       	ldd	r31, Y+3	; 0x03
    6fe0:	82 89       	ldd	r24, Z+18	; 0x12
    6fe2:	88 2f       	mov	r24, r24
    6fe4:	90 e0       	ldi	r25, 0x00	; 0
    6fe6:	84 70       	andi	r24, 0x04	; 4
    6fe8:	90 70       	andi	r25, 0x00	; 0
    6fea:	00 97       	sbiw	r24, 0x00	; 0
    6fec:	11 f4       	brne	.+4      	; 0x6ff2 <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    6fee:	19 82       	std	Y+1, r1	; 0x01
    6ff0:	02 c0       	rjmp	.+4      	; 0x6ff6 <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    6ff2:	81 e0       	ldi	r24, 0x01	; 1
    6ff4:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    6ff6:	0f 90       	pop	r0
    6ff8:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    6ffa:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6ffc:	0f 90       	pop	r0
    6ffe:	0f 90       	pop	r0
    7000:	0f 90       	pop	r0
    7002:	0f 90       	pop	r0
    7004:	0f 90       	pop	r0
    7006:	cf 91       	pop	r28
    7008:	df 91       	pop	r29
    700a:	08 95       	ret

0000700c <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    700c:	df 93       	push	r29
    700e:	cf 93       	push	r28
    7010:	00 d0       	rcall	.+0      	; 0x7012 <xTimerGetExpiryTime+0x6>
    7012:	00 d0       	rcall	.+0      	; 0x7014 <xTimerGetExpiryTime+0x8>
    7014:	00 d0       	rcall	.+0      	; 0x7016 <xTimerGetExpiryTime+0xa>
    7016:	cd b7       	in	r28, 0x3d	; 61
    7018:	de b7       	in	r29, 0x3e	; 62
    701a:	9e 83       	std	Y+6, r25	; 0x06
    701c:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    701e:	8d 81       	ldd	r24, Y+5	; 0x05
    7020:	9e 81       	ldd	r25, Y+6	; 0x06
    7022:	9c 83       	std	Y+4, r25	; 0x04
    7024:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    7026:	eb 81       	ldd	r30, Y+3	; 0x03
    7028:	fc 81       	ldd	r31, Y+4	; 0x04
    702a:	82 81       	ldd	r24, Z+2	; 0x02
    702c:	93 81       	ldd	r25, Z+3	; 0x03
    702e:	9a 83       	std	Y+2, r25	; 0x02
    7030:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    7032:	89 81       	ldd	r24, Y+1	; 0x01
    7034:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    7036:	26 96       	adiw	r28, 0x06	; 6
    7038:	0f b6       	in	r0, 0x3f	; 63
    703a:	f8 94       	cli
    703c:	de bf       	out	0x3e, r29	; 62
    703e:	0f be       	out	0x3f, r0	; 63
    7040:	cd bf       	out	0x3d, r28	; 61
    7042:	cf 91       	pop	r28
    7044:	df 91       	pop	r29
    7046:	08 95       	ret

00007048 <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    7048:	df 93       	push	r29
    704a:	cf 93       	push	r28
    704c:	00 d0       	rcall	.+0      	; 0x704e <pcTimerGetName+0x6>
    704e:	00 d0       	rcall	.+0      	; 0x7050 <pcTimerGetName+0x8>
    7050:	cd b7       	in	r28, 0x3d	; 61
    7052:	de b7       	in	r29, 0x3e	; 62
    7054:	9c 83       	std	Y+4, r25	; 0x04
    7056:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    7058:	8b 81       	ldd	r24, Y+3	; 0x03
    705a:	9c 81       	ldd	r25, Y+4	; 0x04
    705c:	9a 83       	std	Y+2, r25	; 0x02
    705e:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    7060:	e9 81       	ldd	r30, Y+1	; 0x01
    7062:	fa 81       	ldd	r31, Y+2	; 0x02
    7064:	80 81       	ld	r24, Z
    7066:	91 81       	ldd	r25, Z+1	; 0x01
    }
    7068:	0f 90       	pop	r0
    706a:	0f 90       	pop	r0
    706c:	0f 90       	pop	r0
    706e:	0f 90       	pop	r0
    7070:	cf 91       	pop	r28
    7072:	df 91       	pop	r29
    7074:	08 95       	ret

00007076 <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    7076:	df 93       	push	r29
    7078:	cf 93       	push	r28
    707a:	00 d0       	rcall	.+0      	; 0x707c <prvReloadTimer+0x6>
    707c:	00 d0       	rcall	.+0      	; 0x707e <prvReloadTimer+0x8>
    707e:	00 d0       	rcall	.+0      	; 0x7080 <prvReloadTimer+0xa>
    7080:	cd b7       	in	r28, 0x3d	; 61
    7082:	de b7       	in	r29, 0x3e	; 62
    7084:	9a 83       	std	Y+2, r25	; 0x02
    7086:	89 83       	std	Y+1, r24	; 0x01
    7088:	7c 83       	std	Y+4, r23	; 0x04
    708a:	6b 83       	std	Y+3, r22	; 0x03
    708c:	5e 83       	std	Y+6, r21	; 0x06
    708e:	4d 83       	std	Y+5, r20	; 0x05
    7090:	12 c0       	rjmp	.+36     	; 0x70b6 <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    7092:	e9 81       	ldd	r30, Y+1	; 0x01
    7094:	fa 81       	ldd	r31, Y+2	; 0x02
    7096:	24 85       	ldd	r18, Z+12	; 0x0c
    7098:	35 85       	ldd	r19, Z+13	; 0x0d
    709a:	8b 81       	ldd	r24, Y+3	; 0x03
    709c:	9c 81       	ldd	r25, Y+4	; 0x04
    709e:	82 0f       	add	r24, r18
    70a0:	93 1f       	adc	r25, r19
    70a2:	9c 83       	std	Y+4, r25	; 0x04
    70a4:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    70a6:	e9 81       	ldd	r30, Y+1	; 0x01
    70a8:	fa 81       	ldd	r31, Y+2	; 0x02
    70aa:	00 88       	ldd	r0, Z+16	; 0x10
    70ac:	f1 89       	ldd	r31, Z+17	; 0x11
    70ae:	e0 2d       	mov	r30, r0
    70b0:	89 81       	ldd	r24, Y+1	; 0x01
    70b2:	9a 81       	ldd	r25, Y+2	; 0x02
    70b4:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    70b6:	e9 81       	ldd	r30, Y+1	; 0x01
    70b8:	fa 81       	ldd	r31, Y+2	; 0x02
    70ba:	24 85       	ldd	r18, Z+12	; 0x0c
    70bc:	35 85       	ldd	r19, Z+13	; 0x0d
    70be:	8b 81       	ldd	r24, Y+3	; 0x03
    70c0:	9c 81       	ldd	r25, Y+4	; 0x04
    70c2:	a9 01       	movw	r20, r18
    70c4:	48 0f       	add	r20, r24
    70c6:	59 1f       	adc	r21, r25
    70c8:	89 81       	ldd	r24, Y+1	; 0x01
    70ca:	9a 81       	ldd	r25, Y+2	; 0x02
    70cc:	2d 81       	ldd	r18, Y+5	; 0x05
    70ce:	3e 81       	ldd	r19, Y+6	; 0x06
    70d0:	eb 81       	ldd	r30, Y+3	; 0x03
    70d2:	fc 81       	ldd	r31, Y+4	; 0x04
    70d4:	ba 01       	movw	r22, r20
    70d6:	a9 01       	movw	r20, r18
    70d8:	9f 01       	movw	r18, r30
    70da:	0e 94 91 39 	call	0x7322	; 0x7322 <prvInsertTimerInActiveList>
    70de:	88 23       	and	r24, r24
    70e0:	c1 f6       	brne	.-80     	; 0x7092 <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    70e2:	26 96       	adiw	r28, 0x06	; 6
    70e4:	0f b6       	in	r0, 0x3f	; 63
    70e6:	f8 94       	cli
    70e8:	de bf       	out	0x3e, r29	; 62
    70ea:	0f be       	out	0x3f, r0	; 63
    70ec:	cd bf       	out	0x3d, r28	; 61
    70ee:	cf 91       	pop	r28
    70f0:	df 91       	pop	r29
    70f2:	08 95       	ret

000070f4 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    70f4:	df 93       	push	r29
    70f6:	cf 93       	push	r28
    70f8:	00 d0       	rcall	.+0      	; 0x70fa <prvProcessExpiredTimer+0x6>
    70fa:	00 d0       	rcall	.+0      	; 0x70fc <prvProcessExpiredTimer+0x8>
    70fc:	00 d0       	rcall	.+0      	; 0x70fe <prvProcessExpiredTimer+0xa>
    70fe:	cd b7       	in	r28, 0x3d	; 61
    7100:	de b7       	in	r29, 0x3e	; 62
    7102:	9c 83       	std	Y+4, r25	; 0x04
    7104:	8b 83       	std	Y+3, r24	; 0x03
    7106:	7e 83       	std	Y+6, r23	; 0x06
    7108:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    710a:	e0 91 be 07 	lds	r30, 0x07BE
    710e:	f0 91 bf 07 	lds	r31, 0x07BF
    7112:	05 80       	ldd	r0, Z+5	; 0x05
    7114:	f6 81       	ldd	r31, Z+6	; 0x06
    7116:	e0 2d       	mov	r30, r0
    7118:	86 81       	ldd	r24, Z+6	; 0x06
    711a:	97 81       	ldd	r25, Z+7	; 0x07
    711c:	9a 83       	std	Y+2, r25	; 0x02
    711e:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    7120:	89 81       	ldd	r24, Y+1	; 0x01
    7122:	9a 81       	ldd	r25, Y+2	; 0x02
    7124:	02 96       	adiw	r24, 0x02	; 2
    7126:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    712a:	e9 81       	ldd	r30, Y+1	; 0x01
    712c:	fa 81       	ldd	r31, Y+2	; 0x02
    712e:	82 89       	ldd	r24, Z+18	; 0x12
    7130:	88 2f       	mov	r24, r24
    7132:	90 e0       	ldi	r25, 0x00	; 0
    7134:	84 70       	andi	r24, 0x04	; 4
    7136:	90 70       	andi	r25, 0x00	; 0
    7138:	00 97       	sbiw	r24, 0x00	; 0
    713a:	51 f0       	breq	.+20     	; 0x7150 <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    713c:	89 81       	ldd	r24, Y+1	; 0x01
    713e:	9a 81       	ldd	r25, Y+2	; 0x02
    7140:	2b 81       	ldd	r18, Y+3	; 0x03
    7142:	3c 81       	ldd	r19, Y+4	; 0x04
    7144:	4d 81       	ldd	r20, Y+5	; 0x05
    7146:	5e 81       	ldd	r21, Y+6	; 0x06
    7148:	b9 01       	movw	r22, r18
    714a:	0e 94 3b 38 	call	0x7076	; 0x7076 <prvReloadTimer>
    714e:	07 c0       	rjmp	.+14     	; 0x715e <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    7150:	e9 81       	ldd	r30, Y+1	; 0x01
    7152:	fa 81       	ldd	r31, Y+2	; 0x02
    7154:	82 89       	ldd	r24, Z+18	; 0x12
    7156:	8e 7f       	andi	r24, 0xFE	; 254
    7158:	e9 81       	ldd	r30, Y+1	; 0x01
    715a:	fa 81       	ldd	r31, Y+2	; 0x02
    715c:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    715e:	e9 81       	ldd	r30, Y+1	; 0x01
    7160:	fa 81       	ldd	r31, Y+2	; 0x02
    7162:	00 88       	ldd	r0, Z+16	; 0x10
    7164:	f1 89       	ldd	r31, Z+17	; 0x11
    7166:	e0 2d       	mov	r30, r0
    7168:	89 81       	ldd	r24, Y+1	; 0x01
    716a:	9a 81       	ldd	r25, Y+2	; 0x02
    716c:	09 95       	icall
    }
    716e:	26 96       	adiw	r28, 0x06	; 6
    7170:	0f b6       	in	r0, 0x3f	; 63
    7172:	f8 94       	cli
    7174:	de bf       	out	0x3e, r29	; 62
    7176:	0f be       	out	0x3f, r0	; 63
    7178:	cd bf       	out	0x3d, r28	; 61
    717a:	cf 91       	pop	r28
    717c:	df 91       	pop	r29
    717e:	08 95       	ret

00007180 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    7180:	df 93       	push	r29
    7182:	cf 93       	push	r28
    7184:	00 d0       	rcall	.+0      	; 0x7186 <prvTimerTask+0x6>
    7186:	00 d0       	rcall	.+0      	; 0x7188 <prvTimerTask+0x8>
    7188:	0f 92       	push	r0
    718a:	cd b7       	in	r28, 0x3d	; 61
    718c:	de b7       	in	r29, 0x3e	; 62
    718e:	9d 83       	std	Y+5, r25	; 0x05
    7190:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    7192:	ce 01       	movw	r24, r28
    7194:	03 96       	adiw	r24, 0x03	; 3
    7196:	0e 94 2f 39 	call	0x725e	; 0x725e <prvGetNextExpireTime>
    719a:	9a 83       	std	Y+2, r25	; 0x02
    719c:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    719e:	2b 81       	ldd	r18, Y+3	; 0x03
    71a0:	89 81       	ldd	r24, Y+1	; 0x01
    71a2:	9a 81       	ldd	r25, Y+2	; 0x02
    71a4:	62 2f       	mov	r22, r18
    71a6:	0e 94 d8 38 	call	0x71b0	; 0x71b0 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    71aa:	0e 94 f9 39 	call	0x73f2	; 0x73f2 <prvProcessReceivedCommands>
    71ae:	f1 cf       	rjmp	.-30     	; 0x7192 <prvTimerTask+0x12>

000071b0 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    71b0:	df 93       	push	r29
    71b2:	cf 93       	push	r28
    71b4:	00 d0       	rcall	.+0      	; 0x71b6 <prvProcessTimerOrBlockTask+0x6>
    71b6:	00 d0       	rcall	.+0      	; 0x71b8 <prvProcessTimerOrBlockTask+0x8>
    71b8:	00 d0       	rcall	.+0      	; 0x71ba <prvProcessTimerOrBlockTask+0xa>
    71ba:	cd b7       	in	r28, 0x3d	; 61
    71bc:	de b7       	in	r29, 0x3e	; 62
    71be:	9d 83       	std	Y+5, r25	; 0x05
    71c0:	8c 83       	std	Y+4, r24	; 0x04
    71c2:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    71c4:	0e 94 d0 25 	call	0x4ba0	; 0x4ba0 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    71c8:	ce 01       	movw	r24, r28
    71ca:	03 96       	adiw	r24, 0x03	; 3
    71cc:	0e 94 63 39 	call	0x72c6	; 0x72c6 <prvSampleTimeNow>
    71d0:	9a 83       	std	Y+2, r25	; 0x02
    71d2:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    71d4:	8b 81       	ldd	r24, Y+3	; 0x03
    71d6:	88 23       	and	r24, r24
    71d8:	b9 f5       	brne	.+110    	; 0x7248 <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    71da:	8e 81       	ldd	r24, Y+6	; 0x06
    71dc:	88 23       	and	r24, r24
    71de:	89 f4       	brne	.+34     	; 0x7202 <prvProcessTimerOrBlockTask+0x52>
    71e0:	2c 81       	ldd	r18, Y+4	; 0x04
    71e2:	3d 81       	ldd	r19, Y+5	; 0x05
    71e4:	89 81       	ldd	r24, Y+1	; 0x01
    71e6:	9a 81       	ldd	r25, Y+2	; 0x02
    71e8:	82 17       	cp	r24, r18
    71ea:	93 07       	cpc	r25, r19
    71ec:	50 f0       	brcs	.+20     	; 0x7202 <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    71ee:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    71f2:	8c 81       	ldd	r24, Y+4	; 0x04
    71f4:	9d 81       	ldd	r25, Y+5	; 0x05
    71f6:	29 81       	ldd	r18, Y+1	; 0x01
    71f8:	3a 81       	ldd	r19, Y+2	; 0x02
    71fa:	b9 01       	movw	r22, r18
    71fc:	0e 94 7a 38 	call	0x70f4	; 0x70f4 <prvProcessExpiredTimer>
    7200:	25 c0       	rjmp	.+74     	; 0x724c <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    7202:	8e 81       	ldd	r24, Y+6	; 0x06
    7204:	88 23       	and	r24, r24
    7206:	51 f0       	breq	.+20     	; 0x721c <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    7208:	e0 91 c0 07 	lds	r30, 0x07C0
    720c:	f0 91 c1 07 	lds	r31, 0x07C1
    7210:	80 81       	ld	r24, Z
    7212:	1e 82       	std	Y+6, r1	; 0x06
    7214:	88 23       	and	r24, r24
    7216:	11 f4       	brne	.+4      	; 0x721c <prvProcessTimerOrBlockTask+0x6c>
    7218:	81 e0       	ldi	r24, 0x01	; 1
    721a:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    721c:	40 91 a6 07 	lds	r20, 0x07A6
    7220:	50 91 a7 07 	lds	r21, 0x07A7
    7224:	2c 81       	ldd	r18, Y+4	; 0x04
    7226:	3d 81       	ldd	r19, Y+5	; 0x05
    7228:	89 81       	ldd	r24, Y+1	; 0x01
    722a:	9a 81       	ldd	r25, Y+2	; 0x02
    722c:	28 1b       	sub	r18, r24
    722e:	39 0b       	sbc	r19, r25
    7230:	ca 01       	movw	r24, r20
    7232:	b9 01       	movw	r22, r18
    7234:	4e 81       	ldd	r20, Y+6	; 0x06
    7236:	0e 94 3c 22 	call	0x4478	; 0x4478 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    723a:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
    723e:	88 23       	and	r24, r24
    7240:	29 f4       	brne	.+10     	; 0x724c <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    7242:	0e 94 ba 10 	call	0x2174	; 0x2174 <vPortYield>
    7246:	02 c0       	rjmp	.+4      	; 0x724c <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    7248:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <xTaskResumeAll>
            }
        }
    }
    724c:	26 96       	adiw	r28, 0x06	; 6
    724e:	0f b6       	in	r0, 0x3f	; 63
    7250:	f8 94       	cli
    7252:	de bf       	out	0x3e, r29	; 62
    7254:	0f be       	out	0x3f, r0	; 63
    7256:	cd bf       	out	0x3d, r28	; 61
    7258:	cf 91       	pop	r28
    725a:	df 91       	pop	r29
    725c:	08 95       	ret

0000725e <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    725e:	df 93       	push	r29
    7260:	cf 93       	push	r28
    7262:	00 d0       	rcall	.+0      	; 0x7264 <prvGetNextExpireTime+0x6>
    7264:	00 d0       	rcall	.+0      	; 0x7266 <prvGetNextExpireTime+0x8>
    7266:	0f 92       	push	r0
    7268:	cd b7       	in	r28, 0x3d	; 61
    726a:	de b7       	in	r29, 0x3e	; 62
    726c:	9c 83       	std	Y+4, r25	; 0x04
    726e:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    7270:	e0 91 be 07 	lds	r30, 0x07BE
    7274:	f0 91 bf 07 	lds	r31, 0x07BF
    7278:	80 81       	ld	r24, Z
    727a:	1d 82       	std	Y+5, r1	; 0x05
    727c:	88 23       	and	r24, r24
    727e:	11 f4       	brne	.+4      	; 0x7284 <prvGetNextExpireTime+0x26>
    7280:	81 e0       	ldi	r24, 0x01	; 1
    7282:	8d 83       	std	Y+5, r24	; 0x05
    7284:	eb 81       	ldd	r30, Y+3	; 0x03
    7286:	fc 81       	ldd	r31, Y+4	; 0x04
    7288:	8d 81       	ldd	r24, Y+5	; 0x05
    728a:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    728c:	eb 81       	ldd	r30, Y+3	; 0x03
    728e:	fc 81       	ldd	r31, Y+4	; 0x04
    7290:	80 81       	ld	r24, Z
    7292:	88 23       	and	r24, r24
    7294:	61 f4       	brne	.+24     	; 0x72ae <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    7296:	e0 91 be 07 	lds	r30, 0x07BE
    729a:	f0 91 bf 07 	lds	r31, 0x07BF
    729e:	05 80       	ldd	r0, Z+5	; 0x05
    72a0:	f6 81       	ldd	r31, Z+6	; 0x06
    72a2:	e0 2d       	mov	r30, r0
    72a4:	80 81       	ld	r24, Z
    72a6:	91 81       	ldd	r25, Z+1	; 0x01
    72a8:	9a 83       	std	Y+2, r25	; 0x02
    72aa:	89 83       	std	Y+1, r24	; 0x01
    72ac:	02 c0       	rjmp	.+4      	; 0x72b2 <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    72ae:	1a 82       	std	Y+2, r1	; 0x02
    72b0:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    72b2:	89 81       	ldd	r24, Y+1	; 0x01
    72b4:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    72b6:	0f 90       	pop	r0
    72b8:	0f 90       	pop	r0
    72ba:	0f 90       	pop	r0
    72bc:	0f 90       	pop	r0
    72be:	0f 90       	pop	r0
    72c0:	cf 91       	pop	r28
    72c2:	df 91       	pop	r29
    72c4:	08 95       	ret

000072c6 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    72c6:	df 93       	push	r29
    72c8:	cf 93       	push	r28
    72ca:	00 d0       	rcall	.+0      	; 0x72cc <prvSampleTimeNow+0x6>
    72cc:	00 d0       	rcall	.+0      	; 0x72ce <prvSampleTimeNow+0x8>
    72ce:	cd b7       	in	r28, 0x3d	; 61
    72d0:	de b7       	in	r29, 0x3e	; 62
    72d2:	9c 83       	std	Y+4, r25	; 0x04
    72d4:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    72d6:	0e 94 2c 27 	call	0x4e58	; 0x4e58 <xTaskGetTickCount>
    72da:	9a 83       	std	Y+2, r25	; 0x02
    72dc:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    72de:	20 91 aa 07 	lds	r18, 0x07AA
    72e2:	30 91 ab 07 	lds	r19, 0x07AB
    72e6:	89 81       	ldd	r24, Y+1	; 0x01
    72e8:	9a 81       	ldd	r25, Y+2	; 0x02
    72ea:	82 17       	cp	r24, r18
    72ec:	93 07       	cpc	r25, r19
    72ee:	38 f4       	brcc	.+14     	; 0x72fe <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    72f0:	0e 94 f4 3a 	call	0x75e8	; 0x75e8 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    72f4:	eb 81       	ldd	r30, Y+3	; 0x03
    72f6:	fc 81       	ldd	r31, Y+4	; 0x04
    72f8:	81 e0       	ldi	r24, 0x01	; 1
    72fa:	80 83       	st	Z, r24
    72fc:	03 c0       	rjmp	.+6      	; 0x7304 <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    72fe:	eb 81       	ldd	r30, Y+3	; 0x03
    7300:	fc 81       	ldd	r31, Y+4	; 0x04
    7302:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    7304:	89 81       	ldd	r24, Y+1	; 0x01
    7306:	9a 81       	ldd	r25, Y+2	; 0x02
    7308:	90 93 ab 07 	sts	0x07AB, r25
    730c:	80 93 aa 07 	sts	0x07AA, r24

        return xTimeNow;
    7310:	89 81       	ldd	r24, Y+1	; 0x01
    7312:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    7314:	0f 90       	pop	r0
    7316:	0f 90       	pop	r0
    7318:	0f 90       	pop	r0
    731a:	0f 90       	pop	r0
    731c:	cf 91       	pop	r28
    731e:	df 91       	pop	r29
    7320:	08 95       	ret

00007322 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    7322:	df 93       	push	r29
    7324:	cf 93       	push	r28
    7326:	cd b7       	in	r28, 0x3d	; 61
    7328:	de b7       	in	r29, 0x3e	; 62
    732a:	29 97       	sbiw	r28, 0x09	; 9
    732c:	0f b6       	in	r0, 0x3f	; 63
    732e:	f8 94       	cli
    7330:	de bf       	out	0x3e, r29	; 62
    7332:	0f be       	out	0x3f, r0	; 63
    7334:	cd bf       	out	0x3d, r28	; 61
    7336:	9b 83       	std	Y+3, r25	; 0x03
    7338:	8a 83       	std	Y+2, r24	; 0x02
    733a:	7d 83       	std	Y+5, r23	; 0x05
    733c:	6c 83       	std	Y+4, r22	; 0x04
    733e:	5f 83       	std	Y+7, r21	; 0x07
    7340:	4e 83       	std	Y+6, r20	; 0x06
    7342:	39 87       	std	Y+9, r19	; 0x09
    7344:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    7346:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    7348:	ea 81       	ldd	r30, Y+2	; 0x02
    734a:	fb 81       	ldd	r31, Y+3	; 0x03
    734c:	8c 81       	ldd	r24, Y+4	; 0x04
    734e:	9d 81       	ldd	r25, Y+5	; 0x05
    7350:	93 83       	std	Z+3, r25	; 0x03
    7352:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    7354:	ea 81       	ldd	r30, Y+2	; 0x02
    7356:	fb 81       	ldd	r31, Y+3	; 0x03
    7358:	8a 81       	ldd	r24, Y+2	; 0x02
    735a:	9b 81       	ldd	r25, Y+3	; 0x03
    735c:	91 87       	std	Z+9, r25	; 0x09
    735e:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    7360:	2c 81       	ldd	r18, Y+4	; 0x04
    7362:	3d 81       	ldd	r19, Y+5	; 0x05
    7364:	8e 81       	ldd	r24, Y+6	; 0x06
    7366:	9f 81       	ldd	r25, Y+7	; 0x07
    7368:	82 17       	cp	r24, r18
    736a:	93 07       	cpc	r25, r19
    736c:	e0 f0       	brcs	.+56     	; 0x73a6 <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    736e:	2e 81       	ldd	r18, Y+6	; 0x06
    7370:	3f 81       	ldd	r19, Y+7	; 0x07
    7372:	88 85       	ldd	r24, Y+8	; 0x08
    7374:	99 85       	ldd	r25, Y+9	; 0x09
    7376:	28 1b       	sub	r18, r24
    7378:	39 0b       	sbc	r19, r25
    737a:	ea 81       	ldd	r30, Y+2	; 0x02
    737c:	fb 81       	ldd	r31, Y+3	; 0x03
    737e:	84 85       	ldd	r24, Z+12	; 0x0c
    7380:	95 85       	ldd	r25, Z+13	; 0x0d
    7382:	28 17       	cp	r18, r24
    7384:	39 07       	cpc	r19, r25
    7386:	18 f0       	brcs	.+6      	; 0x738e <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    7388:	81 e0       	ldi	r24, 0x01	; 1
    738a:	89 83       	std	Y+1, r24	; 0x01
    738c:	28 c0       	rjmp	.+80     	; 0x73de <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    738e:	80 91 c0 07 	lds	r24, 0x07C0
    7392:	90 91 c1 07 	lds	r25, 0x07C1
    7396:	2a 81       	ldd	r18, Y+2	; 0x02
    7398:	3b 81       	ldd	r19, Y+3	; 0x03
    739a:	2e 5f       	subi	r18, 0xFE	; 254
    739c:	3f 4f       	sbci	r19, 0xFF	; 255
    739e:	b9 01       	movw	r22, r18
    73a0:	0e 94 71 18 	call	0x30e2	; 0x30e2 <vListInsert>
    73a4:	1c c0       	rjmp	.+56     	; 0x73de <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    73a6:	2e 81       	ldd	r18, Y+6	; 0x06
    73a8:	3f 81       	ldd	r19, Y+7	; 0x07
    73aa:	88 85       	ldd	r24, Y+8	; 0x08
    73ac:	99 85       	ldd	r25, Y+9	; 0x09
    73ae:	28 17       	cp	r18, r24
    73b0:	39 07       	cpc	r19, r25
    73b2:	50 f4       	brcc	.+20     	; 0x73c8 <prvInsertTimerInActiveList+0xa6>
    73b4:	2c 81       	ldd	r18, Y+4	; 0x04
    73b6:	3d 81       	ldd	r19, Y+5	; 0x05
    73b8:	88 85       	ldd	r24, Y+8	; 0x08
    73ba:	99 85       	ldd	r25, Y+9	; 0x09
    73bc:	28 17       	cp	r18, r24
    73be:	39 07       	cpc	r19, r25
    73c0:	18 f0       	brcs	.+6      	; 0x73c8 <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    73c2:	81 e0       	ldi	r24, 0x01	; 1
    73c4:	89 83       	std	Y+1, r24	; 0x01
    73c6:	0b c0       	rjmp	.+22     	; 0x73de <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    73c8:	80 91 be 07 	lds	r24, 0x07BE
    73cc:	90 91 bf 07 	lds	r25, 0x07BF
    73d0:	2a 81       	ldd	r18, Y+2	; 0x02
    73d2:	3b 81       	ldd	r19, Y+3	; 0x03
    73d4:	2e 5f       	subi	r18, 0xFE	; 254
    73d6:	3f 4f       	sbci	r19, 0xFF	; 255
    73d8:	b9 01       	movw	r22, r18
    73da:	0e 94 71 18 	call	0x30e2	; 0x30e2 <vListInsert>
            }
        }

        return xProcessTimerNow;
    73de:	89 81       	ldd	r24, Y+1	; 0x01
    }
    73e0:	29 96       	adiw	r28, 0x09	; 9
    73e2:	0f b6       	in	r0, 0x3f	; 63
    73e4:	f8 94       	cli
    73e6:	de bf       	out	0x3e, r29	; 62
    73e8:	0f be       	out	0x3f, r0	; 63
    73ea:	cd bf       	out	0x3d, r28	; 61
    73ec:	cf 91       	pop	r28
    73ee:	df 91       	pop	r29
    73f0:	08 95       	ret

000073f2 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    73f2:	df 93       	push	r29
    73f4:	cf 93       	push	r28
    73f6:	cd b7       	in	r28, 0x3d	; 61
    73f8:	de b7       	in	r29, 0x3e	; 62
    73fa:	2c 97       	sbiw	r28, 0x0c	; 12
    73fc:	0f b6       	in	r0, 0x3f	; 63
    73fe:	f8 94       	cli
    7400:	de bf       	out	0x3e, r29	; 62
    7402:	0f be       	out	0x3f, r0	; 63
    7404:	cd bf       	out	0x3d, r28	; 61
    7406:	d8 c0       	rjmp	.+432    	; 0x75b8 <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    7408:	8d 81       	ldd	r24, Y+5	; 0x05
    740a:	88 23       	and	r24, r24
    740c:	0c f4       	brge	.+2      	; 0x7410 <prvProcessReceivedCommands+0x1e>
    740e:	d4 c0       	rjmp	.+424    	; 0x75b8 <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    7410:	88 85       	ldd	r24, Y+8	; 0x08
    7412:	99 85       	ldd	r25, Y+9	; 0x09
    7414:	9c 83       	std	Y+4, r25	; 0x04
    7416:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    7418:	eb 81       	ldd	r30, Y+3	; 0x03
    741a:	fc 81       	ldd	r31, Y+4	; 0x04
    741c:	82 85       	ldd	r24, Z+10	; 0x0a
    741e:	93 85       	ldd	r25, Z+11	; 0x0b
    7420:	00 97       	sbiw	r24, 0x00	; 0
    7422:	29 f0       	breq	.+10     	; 0x742e <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    7424:	8b 81       	ldd	r24, Y+3	; 0x03
    7426:	9c 81       	ldd	r25, Y+4	; 0x04
    7428:	02 96       	adiw	r24, 0x02	; 2
    742a:	0e 94 dd 18 	call	0x31ba	; 0x31ba <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    742e:	ce 01       	movw	r24, r28
    7430:	0a 96       	adiw	r24, 0x0a	; 10
    7432:	0e 94 63 39 	call	0x72c6	; 0x72c6 <prvSampleTimeNow>
    7436:	9a 83       	std	Y+2, r25	; 0x02
    7438:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    743a:	8d 81       	ldd	r24, Y+5	; 0x05
    743c:	28 2f       	mov	r18, r24
    743e:	33 27       	eor	r19, r19
    7440:	27 fd       	sbrc	r18, 7
    7442:	30 95       	com	r19
    7444:	3c 87       	std	Y+12, r19	; 0x0c
    7446:	2b 87       	std	Y+11, r18	; 0x0b
    7448:	8b 85       	ldd	r24, Y+11	; 0x0b
    744a:	9c 85       	ldd	r25, Y+12	; 0x0c
    744c:	85 30       	cpi	r24, 0x05	; 5
    744e:	91 05       	cpc	r25, r1
    7450:	09 f4       	brne	.+2      	; 0x7454 <prvProcessReceivedCommands+0x62>
    7452:	9d c0       	rjmp	.+314    	; 0x758e <prvProcessReceivedCommands+0x19c>
    7454:	2b 85       	ldd	r18, Y+11	; 0x0b
    7456:	3c 85       	ldd	r19, Y+12	; 0x0c
    7458:	26 30       	cpi	r18, 0x06	; 6
    745a:	31 05       	cpc	r19, r1
    745c:	9c f4       	brge	.+38     	; 0x7484 <prvProcessReceivedCommands+0x92>
    745e:	8b 85       	ldd	r24, Y+11	; 0x0b
    7460:	9c 85       	ldd	r25, Y+12	; 0x0c
    7462:	83 30       	cpi	r24, 0x03	; 3
    7464:	91 05       	cpc	r25, r1
    7466:	09 f4       	brne	.+2      	; 0x746a <prvProcessReceivedCommands+0x78>
    7468:	68 c0       	rjmp	.+208    	; 0x753a <prvProcessReceivedCommands+0x148>
    746a:	2b 85       	ldd	r18, Y+11	; 0x0b
    746c:	3c 85       	ldd	r19, Y+12	; 0x0c
    746e:	24 30       	cpi	r18, 0x04	; 4
    7470:	31 05       	cpc	r19, r1
    7472:	0c f0       	brlt	.+2      	; 0x7476 <prvProcessReceivedCommands+0x84>
    7474:	6a c0       	rjmp	.+212    	; 0x754a <prvProcessReceivedCommands+0x158>
    7476:	8b 85       	ldd	r24, Y+11	; 0x0b
    7478:	9c 85       	ldd	r25, Y+12	; 0x0c
    747a:	81 30       	cpi	r24, 0x01	; 1
    747c:	91 05       	cpc	r25, r1
    747e:	0c f4       	brge	.+2      	; 0x7482 <prvProcessReceivedCommands+0x90>
    7480:	9b c0       	rjmp	.+310    	; 0x75b8 <prvProcessReceivedCommands+0x1c6>
    7482:	12 c0       	rjmp	.+36     	; 0x74a8 <prvProcessReceivedCommands+0xb6>
    7484:	2b 85       	ldd	r18, Y+11	; 0x0b
    7486:	3c 85       	ldd	r19, Y+12	; 0x0c
    7488:	28 30       	cpi	r18, 0x08	; 8
    748a:	31 05       	cpc	r19, r1
    748c:	09 f4       	brne	.+2      	; 0x7490 <prvProcessReceivedCommands+0x9e>
    748e:	55 c0       	rjmp	.+170    	; 0x753a <prvProcessReceivedCommands+0x148>
    7490:	8b 85       	ldd	r24, Y+11	; 0x0b
    7492:	9c 85       	ldd	r25, Y+12	; 0x0c
    7494:	88 30       	cpi	r24, 0x08	; 8
    7496:	91 05       	cpc	r25, r1
    7498:	3c f0       	brlt	.+14     	; 0x74a8 <prvProcessReceivedCommands+0xb6>
    749a:	2b 85       	ldd	r18, Y+11	; 0x0b
    749c:	3c 85       	ldd	r19, Y+12	; 0x0c
    749e:	29 30       	cpi	r18, 0x09	; 9
    74a0:	31 05       	cpc	r19, r1
    74a2:	09 f4       	brne	.+2      	; 0x74a6 <prvProcessReceivedCommands+0xb4>
    74a4:	52 c0       	rjmp	.+164    	; 0x754a <prvProcessReceivedCommands+0x158>
    74a6:	88 c0       	rjmp	.+272    	; 0x75b8 <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    74a8:	eb 81       	ldd	r30, Y+3	; 0x03
    74aa:	fc 81       	ldd	r31, Y+4	; 0x04
    74ac:	82 89       	ldd	r24, Z+18	; 0x12
    74ae:	81 60       	ori	r24, 0x01	; 1
    74b0:	eb 81       	ldd	r30, Y+3	; 0x03
    74b2:	fc 81       	ldd	r31, Y+4	; 0x04
    74b4:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    74b6:	2e 81       	ldd	r18, Y+6	; 0x06
    74b8:	3f 81       	ldd	r19, Y+7	; 0x07
    74ba:	eb 81       	ldd	r30, Y+3	; 0x03
    74bc:	fc 81       	ldd	r31, Y+4	; 0x04
    74be:	84 85       	ldd	r24, Z+12	; 0x0c
    74c0:	95 85       	ldd	r25, Z+13	; 0x0d
    74c2:	a9 01       	movw	r20, r18
    74c4:	48 0f       	add	r20, r24
    74c6:	59 1f       	adc	r21, r25
    74c8:	ee 81       	ldd	r30, Y+6	; 0x06
    74ca:	ff 81       	ldd	r31, Y+7	; 0x07
    74cc:	8b 81       	ldd	r24, Y+3	; 0x03
    74ce:	9c 81       	ldd	r25, Y+4	; 0x04
    74d0:	29 81       	ldd	r18, Y+1	; 0x01
    74d2:	3a 81       	ldd	r19, Y+2	; 0x02
    74d4:	ba 01       	movw	r22, r20
    74d6:	a9 01       	movw	r20, r18
    74d8:	9f 01       	movw	r18, r30
    74da:	0e 94 91 39 	call	0x7322	; 0x7322 <prvInsertTimerInActiveList>
    74de:	88 23       	and	r24, r24
    74e0:	09 f4       	brne	.+2      	; 0x74e4 <prvProcessReceivedCommands+0xf2>
    74e2:	6a c0       	rjmp	.+212    	; 0x75b8 <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    74e4:	eb 81       	ldd	r30, Y+3	; 0x03
    74e6:	fc 81       	ldd	r31, Y+4	; 0x04
    74e8:	82 89       	ldd	r24, Z+18	; 0x12
    74ea:	88 2f       	mov	r24, r24
    74ec:	90 e0       	ldi	r25, 0x00	; 0
    74ee:	84 70       	andi	r24, 0x04	; 4
    74f0:	90 70       	andi	r25, 0x00	; 0
    74f2:	00 97       	sbiw	r24, 0x00	; 0
    74f4:	91 f0       	breq	.+36     	; 0x751a <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    74f6:	2e 81       	ldd	r18, Y+6	; 0x06
    74f8:	3f 81       	ldd	r19, Y+7	; 0x07
    74fa:	eb 81       	ldd	r30, Y+3	; 0x03
    74fc:	fc 81       	ldd	r31, Y+4	; 0x04
    74fe:	84 85       	ldd	r24, Z+12	; 0x0c
    7500:	95 85       	ldd	r25, Z+13	; 0x0d
    7502:	a9 01       	movw	r20, r18
    7504:	48 0f       	add	r20, r24
    7506:	59 1f       	adc	r21, r25
    7508:	8b 81       	ldd	r24, Y+3	; 0x03
    750a:	9c 81       	ldd	r25, Y+4	; 0x04
    750c:	29 81       	ldd	r18, Y+1	; 0x01
    750e:	3a 81       	ldd	r19, Y+2	; 0x02
    7510:	ba 01       	movw	r22, r20
    7512:	a9 01       	movw	r20, r18
    7514:	0e 94 3b 38 	call	0x7076	; 0x7076 <prvReloadTimer>
    7518:	07 c0       	rjmp	.+14     	; 0x7528 <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    751a:	eb 81       	ldd	r30, Y+3	; 0x03
    751c:	fc 81       	ldd	r31, Y+4	; 0x04
    751e:	82 89       	ldd	r24, Z+18	; 0x12
    7520:	8e 7f       	andi	r24, 0xFE	; 254
    7522:	eb 81       	ldd	r30, Y+3	; 0x03
    7524:	fc 81       	ldd	r31, Y+4	; 0x04
    7526:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    7528:	eb 81       	ldd	r30, Y+3	; 0x03
    752a:	fc 81       	ldd	r31, Y+4	; 0x04
    752c:	00 88       	ldd	r0, Z+16	; 0x10
    752e:	f1 89       	ldd	r31, Z+17	; 0x11
    7530:	e0 2d       	mov	r30, r0
    7532:	8b 81       	ldd	r24, Y+3	; 0x03
    7534:	9c 81       	ldd	r25, Y+4	; 0x04
    7536:	09 95       	icall
    7538:	3f c0       	rjmp	.+126    	; 0x75b8 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    753a:	eb 81       	ldd	r30, Y+3	; 0x03
    753c:	fc 81       	ldd	r31, Y+4	; 0x04
    753e:	82 89       	ldd	r24, Z+18	; 0x12
    7540:	8e 7f       	andi	r24, 0xFE	; 254
    7542:	eb 81       	ldd	r30, Y+3	; 0x03
    7544:	fc 81       	ldd	r31, Y+4	; 0x04
    7546:	82 8b       	std	Z+18, r24	; 0x12
    7548:	37 c0       	rjmp	.+110    	; 0x75b8 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    754a:	eb 81       	ldd	r30, Y+3	; 0x03
    754c:	fc 81       	ldd	r31, Y+4	; 0x04
    754e:	82 89       	ldd	r24, Z+18	; 0x12
    7550:	81 60       	ori	r24, 0x01	; 1
    7552:	eb 81       	ldd	r30, Y+3	; 0x03
    7554:	fc 81       	ldd	r31, Y+4	; 0x04
    7556:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    7558:	8e 81       	ldd	r24, Y+6	; 0x06
    755a:	9f 81       	ldd	r25, Y+7	; 0x07
    755c:	eb 81       	ldd	r30, Y+3	; 0x03
    755e:	fc 81       	ldd	r31, Y+4	; 0x04
    7560:	95 87       	std	Z+13, r25	; 0x0d
    7562:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    7564:	eb 81       	ldd	r30, Y+3	; 0x03
    7566:	fc 81       	ldd	r31, Y+4	; 0x04
    7568:	24 85       	ldd	r18, Z+12	; 0x0c
    756a:	35 85       	ldd	r19, Z+13	; 0x0d
    756c:	89 81       	ldd	r24, Y+1	; 0x01
    756e:	9a 81       	ldd	r25, Y+2	; 0x02
    7570:	a9 01       	movw	r20, r18
    7572:	48 0f       	add	r20, r24
    7574:	59 1f       	adc	r21, r25
    7576:	8b 81       	ldd	r24, Y+3	; 0x03
    7578:	9c 81       	ldd	r25, Y+4	; 0x04
    757a:	29 81       	ldd	r18, Y+1	; 0x01
    757c:	3a 81       	ldd	r19, Y+2	; 0x02
    757e:	e9 81       	ldd	r30, Y+1	; 0x01
    7580:	fa 81       	ldd	r31, Y+2	; 0x02
    7582:	ba 01       	movw	r22, r20
    7584:	a9 01       	movw	r20, r18
    7586:	9f 01       	movw	r18, r30
    7588:	0e 94 91 39 	call	0x7322	; 0x7322 <prvInsertTimerInActiveList>
    758c:	15 c0       	rjmp	.+42     	; 0x75b8 <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    758e:	eb 81       	ldd	r30, Y+3	; 0x03
    7590:	fc 81       	ldd	r31, Y+4	; 0x04
    7592:	82 89       	ldd	r24, Z+18	; 0x12
    7594:	88 2f       	mov	r24, r24
    7596:	90 e0       	ldi	r25, 0x00	; 0
    7598:	82 70       	andi	r24, 0x02	; 2
    759a:	90 70       	andi	r25, 0x00	; 0
    759c:	00 97       	sbiw	r24, 0x00	; 0
    759e:	29 f4       	brne	.+10     	; 0x75aa <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    75a0:	8b 81       	ldd	r24, Y+3	; 0x03
    75a2:	9c 81       	ldd	r25, Y+4	; 0x04
    75a4:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <vPortFree>
    75a8:	07 c0       	rjmp	.+14     	; 0x75b8 <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    75aa:	eb 81       	ldd	r30, Y+3	; 0x03
    75ac:	fc 81       	ldd	r31, Y+4	; 0x04
    75ae:	82 89       	ldd	r24, Z+18	; 0x12
    75b0:	8e 7f       	andi	r24, 0xFE	; 254
    75b2:	eb 81       	ldd	r30, Y+3	; 0x03
    75b4:	fc 81       	ldd	r31, Y+4	; 0x04
    75b6:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    75b8:	80 91 a6 07 	lds	r24, 0x07A6
    75bc:	90 91 a7 07 	lds	r25, 0x07A7
    75c0:	9e 01       	movw	r18, r28
    75c2:	2b 5f       	subi	r18, 0xFB	; 251
    75c4:	3f 4f       	sbci	r19, 0xFF	; 255
    75c6:	b9 01       	movw	r22, r18
    75c8:	40 e0       	ldi	r20, 0x00	; 0
    75ca:	50 e0       	ldi	r21, 0x00	; 0
    75cc:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <xQueueReceive>
    75d0:	88 23       	and	r24, r24
    75d2:	09 f0       	breq	.+2      	; 0x75d6 <prvProcessReceivedCommands+0x1e4>
    75d4:	19 cf       	rjmp	.-462    	; 0x7408 <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    75d6:	2c 96       	adiw	r28, 0x0c	; 12
    75d8:	0f b6       	in	r0, 0x3f	; 63
    75da:	f8 94       	cli
    75dc:	de bf       	out	0x3e, r29	; 62
    75de:	0f be       	out	0x3f, r0	; 63
    75e0:	cd bf       	out	0x3d, r28	; 61
    75e2:	cf 91       	pop	r28
    75e4:	df 91       	pop	r29
    75e6:	08 95       	ret

000075e8 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    75e8:	df 93       	push	r29
    75ea:	cf 93       	push	r28
    75ec:	00 d0       	rcall	.+0      	; 0x75ee <prvSwitchTimerLists+0x6>
    75ee:	00 d0       	rcall	.+0      	; 0x75f0 <prvSwitchTimerLists+0x8>
    75f0:	cd b7       	in	r28, 0x3d	; 61
    75f2:	de b7       	in	r29, 0x3e	; 62
    75f4:	11 c0       	rjmp	.+34     	; 0x7618 <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    75f6:	e0 91 be 07 	lds	r30, 0x07BE
    75fa:	f0 91 bf 07 	lds	r31, 0x07BF
    75fe:	05 80       	ldd	r0, Z+5	; 0x05
    7600:	f6 81       	ldd	r31, Z+6	; 0x06
    7602:	e0 2d       	mov	r30, r0
    7604:	80 81       	ld	r24, Z
    7606:	91 81       	ldd	r25, Z+1	; 0x01
    7608:	9c 83       	std	Y+4, r25	; 0x04
    760a:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    760c:	8b 81       	ldd	r24, Y+3	; 0x03
    760e:	9c 81       	ldd	r25, Y+4	; 0x04
    7610:	6f ef       	ldi	r22, 0xFF	; 255
    7612:	7f ef       	ldi	r23, 0xFF	; 255
    7614:	0e 94 7a 38 	call	0x70f4	; 0x70f4 <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    7618:	e0 91 be 07 	lds	r30, 0x07BE
    761c:	f0 91 bf 07 	lds	r31, 0x07BF
    7620:	80 81       	ld	r24, Z
    7622:	88 23       	and	r24, r24
    7624:	41 f7       	brne	.-48     	; 0x75f6 <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    7626:	80 91 be 07 	lds	r24, 0x07BE
    762a:	90 91 bf 07 	lds	r25, 0x07BF
    762e:	9a 83       	std	Y+2, r25	; 0x02
    7630:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    7632:	80 91 c0 07 	lds	r24, 0x07C0
    7636:	90 91 c1 07 	lds	r25, 0x07C1
    763a:	90 93 bf 07 	sts	0x07BF, r25
    763e:	80 93 be 07 	sts	0x07BE, r24
        pxOverflowTimerList = pxTemp;
    7642:	89 81       	ldd	r24, Y+1	; 0x01
    7644:	9a 81       	ldd	r25, Y+2	; 0x02
    7646:	90 93 c1 07 	sts	0x07C1, r25
    764a:	80 93 c0 07 	sts	0x07C0, r24
    }
    764e:	0f 90       	pop	r0
    7650:	0f 90       	pop	r0
    7652:	0f 90       	pop	r0
    7654:	0f 90       	pop	r0
    7656:	cf 91       	pop	r28
    7658:	df 91       	pop	r29
    765a:	08 95       	ret

0000765c <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    765c:	df 93       	push	r29
    765e:	cf 93       	push	r28
    7660:	cd b7       	in	r28, 0x3d	; 61
    7662:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    7664:	0f b6       	in	r0, 0x3f	; 63
    7666:	f8 94       	cli
    7668:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    766a:	80 91 a6 07 	lds	r24, 0x07A6
    766e:	90 91 a7 07 	lds	r25, 0x07A7
    7672:	00 97       	sbiw	r24, 0x00	; 0
    7674:	e9 f4       	brne	.+58     	; 0x76b0 <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    7676:	8c ea       	ldi	r24, 0xAC	; 172
    7678:	97 e0       	ldi	r25, 0x07	; 7
    767a:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    767e:	85 eb       	ldi	r24, 0xB5	; 181
    7680:	97 e0       	ldi	r25, 0x07	; 7
    7682:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    7686:	8c ea       	ldi	r24, 0xAC	; 172
    7688:	97 e0       	ldi	r25, 0x07	; 7
    768a:	90 93 bf 07 	sts	0x07BF, r25
    768e:	80 93 be 07 	sts	0x07BE, r24
                pxOverflowTimerList = &xActiveTimerList2;
    7692:	85 eb       	ldi	r24, 0xB5	; 181
    7694:	97 e0       	ldi	r25, 0x07	; 7
    7696:	90 93 c1 07 	sts	0x07C1, r25
    769a:	80 93 c0 07 	sts	0x07C0, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    769e:	8a e0       	ldi	r24, 0x0A	; 10
    76a0:	65 e0       	ldi	r22, 0x05	; 5
    76a2:	40 e0       	ldi	r20, 0x00	; 0
    76a4:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <xQueueGenericCreate>
    76a8:	90 93 a7 07 	sts	0x07A7, r25
    76ac:	80 93 a6 07 	sts	0x07A6, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    76b0:	0f 90       	pop	r0
    76b2:	0f be       	out	0x3f, r0	; 63
    }
    76b4:	cf 91       	pop	r28
    76b6:	df 91       	pop	r29
    76b8:	08 95       	ret

000076ba <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    76ba:	df 93       	push	r29
    76bc:	cf 93       	push	r28
    76be:	00 d0       	rcall	.+0      	; 0x76c0 <xTimerIsTimerActive+0x6>
    76c0:	00 d0       	rcall	.+0      	; 0x76c2 <xTimerIsTimerActive+0x8>
    76c2:	0f 92       	push	r0
    76c4:	cd b7       	in	r28, 0x3d	; 61
    76c6:	de b7       	in	r29, 0x3e	; 62
    76c8:	9d 83       	std	Y+5, r25	; 0x05
    76ca:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    76cc:	8c 81       	ldd	r24, Y+4	; 0x04
    76ce:	9d 81       	ldd	r25, Y+5	; 0x05
    76d0:	9a 83       	std	Y+2, r25	; 0x02
    76d2:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    76d4:	0f b6       	in	r0, 0x3f	; 63
    76d6:	f8 94       	cli
    76d8:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    76da:	e9 81       	ldd	r30, Y+1	; 0x01
    76dc:	fa 81       	ldd	r31, Y+2	; 0x02
    76de:	82 89       	ldd	r24, Z+18	; 0x12
    76e0:	88 2f       	mov	r24, r24
    76e2:	90 e0       	ldi	r25, 0x00	; 0
    76e4:	81 70       	andi	r24, 0x01	; 1
    76e6:	90 70       	andi	r25, 0x00	; 0
    76e8:	00 97       	sbiw	r24, 0x00	; 0
    76ea:	11 f4       	brne	.+4      	; 0x76f0 <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    76ec:	1b 82       	std	Y+3, r1	; 0x03
    76ee:	02 c0       	rjmp	.+4      	; 0x76f4 <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    76f0:	81 e0       	ldi	r24, 0x01	; 1
    76f2:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    76f4:	0f 90       	pop	r0
    76f6:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    76f8:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    76fa:	0f 90       	pop	r0
    76fc:	0f 90       	pop	r0
    76fe:	0f 90       	pop	r0
    7700:	0f 90       	pop	r0
    7702:	0f 90       	pop	r0
    7704:	cf 91       	pop	r28
    7706:	df 91       	pop	r29
    7708:	08 95       	ret

0000770a <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    770a:	df 93       	push	r29
    770c:	cf 93       	push	r28
    770e:	00 d0       	rcall	.+0      	; 0x7710 <pvTimerGetTimerID+0x6>
    7710:	00 d0       	rcall	.+0      	; 0x7712 <pvTimerGetTimerID+0x8>
    7712:	00 d0       	rcall	.+0      	; 0x7714 <pvTimerGetTimerID+0xa>
    7714:	cd b7       	in	r28, 0x3d	; 61
    7716:	de b7       	in	r29, 0x3e	; 62
    7718:	9e 83       	std	Y+6, r25	; 0x06
    771a:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    771c:	8d 81       	ldd	r24, Y+5	; 0x05
    771e:	9e 81       	ldd	r25, Y+6	; 0x06
    7720:	9c 83       	std	Y+4, r25	; 0x04
    7722:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    7724:	0f b6       	in	r0, 0x3f	; 63
    7726:	f8 94       	cli
    7728:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    772a:	eb 81       	ldd	r30, Y+3	; 0x03
    772c:	fc 81       	ldd	r31, Y+4	; 0x04
    772e:	86 85       	ldd	r24, Z+14	; 0x0e
    7730:	97 85       	ldd	r25, Z+15	; 0x0f
    7732:	9a 83       	std	Y+2, r25	; 0x02
    7734:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    7736:	0f 90       	pop	r0
    7738:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    773a:	89 81       	ldd	r24, Y+1	; 0x01
    773c:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    773e:	26 96       	adiw	r28, 0x06	; 6
    7740:	0f b6       	in	r0, 0x3f	; 63
    7742:	f8 94       	cli
    7744:	de bf       	out	0x3e, r29	; 62
    7746:	0f be       	out	0x3f, r0	; 63
    7748:	cd bf       	out	0x3d, r28	; 61
    774a:	cf 91       	pop	r28
    774c:	df 91       	pop	r29
    774e:	08 95       	ret

00007750 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    7750:	df 93       	push	r29
    7752:	cf 93       	push	r28
    7754:	00 d0       	rcall	.+0      	; 0x7756 <vTimerSetTimerID+0x6>
    7756:	00 d0       	rcall	.+0      	; 0x7758 <vTimerSetTimerID+0x8>
    7758:	00 d0       	rcall	.+0      	; 0x775a <vTimerSetTimerID+0xa>
    775a:	cd b7       	in	r28, 0x3d	; 61
    775c:	de b7       	in	r29, 0x3e	; 62
    775e:	9c 83       	std	Y+4, r25	; 0x04
    7760:	8b 83       	std	Y+3, r24	; 0x03
    7762:	7e 83       	std	Y+6, r23	; 0x06
    7764:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    7766:	8b 81       	ldd	r24, Y+3	; 0x03
    7768:	9c 81       	ldd	r25, Y+4	; 0x04
    776a:	9a 83       	std	Y+2, r25	; 0x02
    776c:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    776e:	0f b6       	in	r0, 0x3f	; 63
    7770:	f8 94       	cli
    7772:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    7774:	e9 81       	ldd	r30, Y+1	; 0x01
    7776:	fa 81       	ldd	r31, Y+2	; 0x02
    7778:	8d 81       	ldd	r24, Y+5	; 0x05
    777a:	9e 81       	ldd	r25, Y+6	; 0x06
    777c:	97 87       	std	Z+15, r25	; 0x0f
    777e:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    7780:	0f 90       	pop	r0
    7782:	0f be       	out	0x3f, r0	; 63
    }
    7784:	26 96       	adiw	r28, 0x06	; 6
    7786:	0f b6       	in	r0, 0x3f	; 63
    7788:	f8 94       	cli
    778a:	de bf       	out	0x3e, r29	; 62
    778c:	0f be       	out	0x3f, r0	; 63
    778e:	cd bf       	out	0x3d, r28	; 61
    7790:	cf 91       	pop	r28
    7792:	df 91       	pop	r29
    7794:	08 95       	ret

00007796 <__udivmodhi4>:
    7796:	aa 1b       	sub	r26, r26
    7798:	bb 1b       	sub	r27, r27
    779a:	51 e1       	ldi	r21, 0x11	; 17
    779c:	07 c0       	rjmp	.+14     	; 0x77ac <__udivmodhi4_ep>

0000779e <__udivmodhi4_loop>:
    779e:	aa 1f       	adc	r26, r26
    77a0:	bb 1f       	adc	r27, r27
    77a2:	a6 17       	cp	r26, r22
    77a4:	b7 07       	cpc	r27, r23
    77a6:	10 f0       	brcs	.+4      	; 0x77ac <__udivmodhi4_ep>
    77a8:	a6 1b       	sub	r26, r22
    77aa:	b7 0b       	sbc	r27, r23

000077ac <__udivmodhi4_ep>:
    77ac:	88 1f       	adc	r24, r24
    77ae:	99 1f       	adc	r25, r25
    77b0:	5a 95       	dec	r21
    77b2:	a9 f7       	brne	.-22     	; 0x779e <__udivmodhi4_loop>
    77b4:	80 95       	com	r24
    77b6:	90 95       	com	r25
    77b8:	bc 01       	movw	r22, r24
    77ba:	cd 01       	movw	r24, r26
    77bc:	08 95       	ret

000077be <__prologue_saves__>:
    77be:	2f 92       	push	r2
    77c0:	3f 92       	push	r3
    77c2:	4f 92       	push	r4
    77c4:	5f 92       	push	r5
    77c6:	6f 92       	push	r6
    77c8:	7f 92       	push	r7
    77ca:	8f 92       	push	r8
    77cc:	9f 92       	push	r9
    77ce:	af 92       	push	r10
    77d0:	bf 92       	push	r11
    77d2:	cf 92       	push	r12
    77d4:	df 92       	push	r13
    77d6:	ef 92       	push	r14
    77d8:	ff 92       	push	r15
    77da:	0f 93       	push	r16
    77dc:	1f 93       	push	r17
    77de:	cf 93       	push	r28
    77e0:	df 93       	push	r29
    77e2:	cd b7       	in	r28, 0x3d	; 61
    77e4:	de b7       	in	r29, 0x3e	; 62
    77e6:	ca 1b       	sub	r28, r26
    77e8:	db 0b       	sbc	r29, r27
    77ea:	0f b6       	in	r0, 0x3f	; 63
    77ec:	f8 94       	cli
    77ee:	de bf       	out	0x3e, r29	; 62
    77f0:	0f be       	out	0x3f, r0	; 63
    77f2:	cd bf       	out	0x3d, r28	; 61
    77f4:	09 94       	ijmp

000077f6 <__epilogue_restores__>:
    77f6:	2a 88       	ldd	r2, Y+18	; 0x12
    77f8:	39 88       	ldd	r3, Y+17	; 0x11
    77fa:	48 88       	ldd	r4, Y+16	; 0x10
    77fc:	5f 84       	ldd	r5, Y+15	; 0x0f
    77fe:	6e 84       	ldd	r6, Y+14	; 0x0e
    7800:	7d 84       	ldd	r7, Y+13	; 0x0d
    7802:	8c 84       	ldd	r8, Y+12	; 0x0c
    7804:	9b 84       	ldd	r9, Y+11	; 0x0b
    7806:	aa 84       	ldd	r10, Y+10	; 0x0a
    7808:	b9 84       	ldd	r11, Y+9	; 0x09
    780a:	c8 84       	ldd	r12, Y+8	; 0x08
    780c:	df 80       	ldd	r13, Y+7	; 0x07
    780e:	ee 80       	ldd	r14, Y+6	; 0x06
    7810:	fd 80       	ldd	r15, Y+5	; 0x05
    7812:	0c 81       	ldd	r16, Y+4	; 0x04
    7814:	1b 81       	ldd	r17, Y+3	; 0x03
    7816:	aa 81       	ldd	r26, Y+2	; 0x02
    7818:	b9 81       	ldd	r27, Y+1	; 0x01
    781a:	ce 0f       	add	r28, r30
    781c:	d1 1d       	adc	r29, r1
    781e:	0f b6       	in	r0, 0x3f	; 63
    7820:	f8 94       	cli
    7822:	de bf       	out	0x3e, r29	; 62
    7824:	0f be       	out	0x3f, r0	; 63
    7826:	cd bf       	out	0x3d, r28	; 61
    7828:	ed 01       	movw	r28, r26
    782a:	08 95       	ret

0000782c <memcpy>:
    782c:	fb 01       	movw	r30, r22
    782e:	dc 01       	movw	r26, r24
    7830:	02 c0       	rjmp	.+4      	; 0x7836 <memcpy+0xa>
    7832:	01 90       	ld	r0, Z+
    7834:	0d 92       	st	X+, r0
    7836:	41 50       	subi	r20, 0x01	; 1
    7838:	50 40       	sbci	r21, 0x00	; 0
    783a:	d8 f7       	brcc	.-10     	; 0x7832 <memcpy+0x6>
    783c:	08 95       	ret

0000783e <memset>:
    783e:	dc 01       	movw	r26, r24
    7840:	01 c0       	rjmp	.+2      	; 0x7844 <memset+0x6>
    7842:	6d 93       	st	X+, r22
    7844:	41 50       	subi	r20, 0x01	; 1
    7846:	50 40       	sbci	r21, 0x00	; 0
    7848:	e0 f7       	brcc	.-8      	; 0x7842 <memset+0x4>
    784a:	08 95       	ret

0000784c <_exit>:
    784c:	f8 94       	cli

0000784e <__stop_program>:
    784e:	ff cf       	rjmp	.-2      	; 0x784e <__stop_program>
